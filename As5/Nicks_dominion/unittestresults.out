
Testing whoseTurn() with seed 1234
Game Initialized! :)
initial whoseTurn: 0
__ALL TESTS PASSED!__

File 'dominion.c'
Lines executed:16.02% of 568
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
       30:    8:int compare(const void* a, const void* b) {
       30:    9:  if (*(int*)a > *(int*)b)
    #####:   10:    return 1;
       30:   11:  if (*(int*)a < *(int*)b)
        8:   12:    return -1;
       22:   13:  return 0;
        -:   14:}
        -:   15:
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
        -:   21:
    #####:   22:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   23:		  int k8, int k9, int k10) {
    #####:   24:  int* k = malloc(10 * sizeof(int));
    #####:   25:  k[0] = k1;
    #####:   26:  k[1] = k2;
    #####:   27:  k[2] = k3;
    #####:   28:  k[3] = k4;
    #####:   29:  k[4] = k5;
    #####:   30:  k[5] = k6;
    #####:   31:  k[6] = k7;
    #####:   32:  k[7] = k8;
    #####:   33:  k[8] = k9;
    #####:   34:  k[9] = k10;
    #####:   35:  return k;
        -:   36:}
        -:   37:
        1:   38:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   39:		   struct gameState *state) {
        -:   40:
        -:   41:  int i;
        -:   42:  int j;
        -:   43:  int it;			
        -:   44:  //set up random number generator
        1:   45:  SelectStream(1);
        1:   46:  PutSeed((long)randomSeed);
        -:   47:  
        -:   48:  //check number of players
        1:   49:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   50:    {
    #####:   51:      return -1;
        -:   52:    }
        -:   53:
        -:   54:  //set number of players
        1:   55:  state->numPlayers = numPlayers;
        -:   56:
        -:   57:  //check selected kingdom cards are different
       11:   58:  for (i = 0; i < 10; i++)
        -:   59:    {
      110:   60:      for (j = 0; j < 10; j++)
        -:   61:        {
      100:   62:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   63:	    {
    #####:   64:	      return -1;
        -:   65:	    }
        -:   66:        }
        -:   67:    }
        -:   68:
        -:   69:
        -:   70:  //initialize supply
        -:   71:  ///////////////////////////////
        -:   72:
        -:   73:  //set number of Curse cards
        1:   74:  if (numPlayers == 2)
        -:   75:    {
        1:   76:      state->supplyCount[curse] = 10;
        -:   77:    }
    #####:   78:  else if (numPlayers == 3)
        -:   79:    {
    #####:   80:      state->supplyCount[curse] = 20;
        -:   81:    }
        -:   82:  else
        -:   83:    {
    #####:   84:      state->supplyCount[curse] = 30;
        -:   85:    }
        -:   86:
        -:   87:  //set number of Victory cards
        1:   88:  if (numPlayers == 2)
        -:   89:    {
        1:   90:      state->supplyCount[estate] = 8;
        1:   91:      state->supplyCount[duchy] = 8;
        1:   92:      state->supplyCount[province] = 8;
        -:   93:    }
        -:   94:  else
        -:   95:    {
    #####:   96:      state->supplyCount[estate] = 12;
    #####:   97:      state->supplyCount[duchy] = 12;
    #####:   98:      state->supplyCount[province] = 12;
        -:   99:    }
        -:  100:
        -:  101:  //set number of Treasure cards
        1:  102:  state->supplyCount[copper] = 60 - (7 * numPlayers);
        1:  103:  state->supplyCount[silver] = 40;
        1:  104:  state->supplyCount[gold] = 30;
        -:  105:
        -:  106:  //set number of Kingdom cards
       21:  107:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  108:    {
      165:  109:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  110:	{
      155:  111:	  if (kingdomCards[j] == i)
        -:  112:	    {
        -:  113:	      //check if card is a 'Victory' Kingdom card
       10:  114:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  115:		{
        2:  116:		  if (numPlayers == 2){ 
        1:  117:		    state->supplyCount[i] = 8; 
        -:  118:		  }
    #####:  119:		  else{ state->supplyCount[i] = 12; }
        -:  120:		}
        -:  121:	      else
        -:  122:		{
        9:  123:		  state->supplyCount[i] = 10;
        -:  124:		}
       10:  125:	      break;
        -:  126:	    }
        -:  127:	  else    //card is not in the set choosen for the game
        -:  128:	    {
      145:  129:	      state->supplyCount[i] = -1;
        -:  130:	    }
        -:  131:	}
        -:  132:
        -:  133:    }
        -:  134:
        -:  135:  ////////////////////////
        -:  136:  //supply intilization complete
        -:  137:
        -:  138:  //set player decks
        3:  139:  for (i = 0; i < numPlayers; i++)
        -:  140:    {
        2:  141:      state->deckCount[i] = 0;
        8:  142:      for (j = 0; j < 3; j++)
        -:  143:	{
        6:  144:	  state->deck[i][j] = estate;
        6:  145:	  state->deckCount[i]++;
        -:  146:	}
       16:  147:      for (j = 3; j < 10; j++)
        -:  148:	{
       14:  149:	  state->deck[i][j] = copper;
       14:  150:	  state->deckCount[i]++;		
        -:  151:	}
        -:  152:    }
        -:  153:
        -:  154:  //shuffle player decks
        3:  155:  for (i = 0; i < numPlayers; i++)
        -:  156:    {
        2:  157:      if ( shuffle(i, state) < 0 )
        -:  158:	{
    #####:  159:	  return -1;
        -:  160:	}
        -:  161:    }
        -:  162:
        -:  163:  //draw player hands
        3:  164:  for (i = 0; i < numPlayers; i++)
        -:  165:    {  
        -:  166:      //initialize hand size to zero
        2:  167:      state->handCount[i] = 0;
        2:  168:      state->discardCount[i] = 0;
        -:  169:      //draw 5 cards
        -:  170:      // for (j = 0; j < 5; j++)
        -:  171:      //	{
        -:  172:      //	  drawCard(i, state);
        -:  173:      //	}
        -:  174:    }
        -:  175:  
        -:  176:  //set embargo tokens to 0 for all supply piles
       28:  177:  for (i = 0; i <= treasure_map; i++)
        -:  178:    {
       27:  179:      state->embargoTokens[i] = 0;
        -:  180:    }
        -:  181:
        -:  182:  //initialize first player's turn
        1:  183:  state->outpostPlayed = 0;
        1:  184:  state->phase = 0;
        1:  185:  state->numActions = 1;
        1:  186:  state->numBuys = 1;
        1:  187:  state->playedCardCount = 0;
        1:  188:  state->whoseTurn = 0;
        1:  189:  state->handCount[state->whoseTurn] = 0;
        -:  190:  //int it; move to top
        -:  191:
        -:  192:  //Moved draw cards to here, only drawing at the start of a turn
        6:  193:  for (it = 0; it < 5; it++){
        5:  194:    drawCard(state->whoseTurn, state);
        -:  195:  }
        -:  196:
        1:  197:  updateCoins(state->whoseTurn, state, 0);
        -:  198:
        1:  199:  return 0;
        -:  200:}
        -:  201:
        2:  202:int shuffle(int player, struct gameState *state) {
        -:  203: 
        -:  204:
        -:  205:  int newDeck[MAX_DECK];
        2:  206:  int newDeckPos = 0;
        -:  207:  int card;
        -:  208:  int i;
        -:  209:
        2:  210:  if (state->deckCount[player] < 1)
    #####:  211:    return -1;
        2:  212:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  213:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  214:
       24:  215:  while (state->deckCount[player] > 0) {
       20:  216:    card = floor(Random() * state->deckCount[player]);
       20:  217:    newDeck[newDeckPos] = state->deck[player][card];
       20:  218:    newDeckPos++;
       77:  219:    for (i = card; i < state->deckCount[player]-1; i++) {
       57:  220:      state->deck[player][i] = state->deck[player][i+1];
        -:  221:    }
       20:  222:    state->deckCount[player]--;
        -:  223:  }
       22:  224:  for (i = 0; i < newDeckPos; i++) {
       20:  225:    state->deck[player][i] = newDeck[i];
       20:  226:    state->deckCount[player]++;
        -:  227:  }
        -:  228:
        2:  229:  return 0;
        -:  230:}
        -:  231:
    #####:  232:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  233:{	
        -:  234:  int card;
    #####:  235:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  236:
        -:  237:  //check if it is the right phase
    #####:  238:  if (state->phase != 0)
        -:  239:    {
    #####:  240:      return -1;
        -:  241:    }
        -:  242:	
        -:  243:  //check if player has enough actions
    #####:  244:  if ( state->numActions < 1 )
        -:  245:    {
    #####:  246:      return -1;
        -:  247:    }
        -:  248:	
        -:  249:  //get card played
    #####:  250:  card = handCard(handPos, state);
        -:  251:	
        -:  252:  //check if selected card is an action
    #####:  253:  if ( card < adventurer || card > treasure_map )
        -:  254:    {
    #####:  255:      return -1;
        -:  256:    }
        -:  257:	
        -:  258:  //play card
    #####:  259:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  260:    {
    #####:  261:      return -1;
        -:  262:    }
        -:  263:	
        -:  264:  //reduce number of actions
    #####:  265:  state->numActions--;
        -:  266:
        -:  267:  //update coins (Treasure cards may be added with card draws)
    #####:  268:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  269:	
    #####:  270:  return 0;
        -:  271:}
        -:  272:
    #####:  273:int buyCard(int supplyPos, struct gameState *state) {
        -:  274:  int who;
        -:  275:  if (DEBUG){
        -:  276:    printf("Entering buyCard...\n");
        -:  277:  }
        -:  278:
        -:  279:  // I don't know what to do about the phase thing.
        -:  280:
    #####:  281:  who = state->whoseTurn;
        -:  282:
    #####:  283:  if (state->numBuys < 1){
        -:  284:    if (DEBUG)
        -:  285:      printf("You do not have any buys left\n");
    #####:  286:    return -1;
    #####:  287:  } else if (supplyCount(supplyPos, state) <1){
        -:  288:    if (DEBUG)
        -:  289:      printf("There are not any of that type of card left\n");
    #####:  290:    return -1;
    #####:  291:  } else if (state->coins < getCost(supplyPos)){
        -:  292:    if (DEBUG) 
        -:  293:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  294:    return -1;
        -:  295:  } else {
    #####:  296:    state->phase=1;
        -:  297:    //state->supplyCount[supplyPos]--;
    #####:  298:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  299:  
    #####:  300:    state->coins = (state->coins) - (getCost(supplyPos));
    #####:  301:    state->numBuys--;
        -:  302:    if (DEBUG)
        -:  303:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  304:  }
        -:  305:
        -:  306:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  307:  //state->discardCount[who]++;
        -:  308:    
    #####:  309:  return 0;
        -:  310:}
        -:  311:
    #####:  312:int numHandCards(struct gameState *state) {
    #####:  313:  return state->handCount[ whoseTurn(state) ];
        -:  314:}
        -:  315:
    #####:  316:int handCard(int handPos, struct gameState *state) {
    #####:  317:  int currentPlayer = whoseTurn(state);
    #####:  318:  return state->hand[currentPlayer][handPos];
        -:  319:}
        -:  320:
    #####:  321:int supplyCount(int card, struct gameState *state) {
    #####:  322:  return state->supplyCount[card];
        -:  323:}
        -:  324:
    #####:  325:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  326:  int i;
    #####:  327:  int count = 0;
        -:  328:
    #####:  329:  for (i = 0; i < state->deckCount[player]; i++)
        -:  330:    {
    #####:  331:      if (state->deck[player][i] == card) count++;
        -:  332:    }
        -:  333:
    #####:  334:  for (i = 0; i < state->handCount[player]; i++)
        -:  335:    {
    #####:  336:      if (state->hand[player][i] == card) count++;
        -:  337:    }
        -:  338:
    #####:  339:  for (i = 0; i < state->discardCount[player]; i++)
        -:  340:    {
    #####:  341:      if (state->discard[player][i] == card) count++;
        -:  342:    }
        -:  343:
    #####:  344:  return count;
        -:  345:}
        -:  346:
        6:  347:int whoseTurn(struct gameState *state) {
        6:  348:  return state->whoseTurn;
        -:  349:}
        -:  350:
    #####:  351:int endTurn(struct gameState *state) {
        -:  352:  int k;
        -:  353:  int i;
    #####:  354:  int currentPlayer = whoseTurn(state);
        -:  355:  
        -:  356:  //Discard hand
    #####:  357:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  358:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  359:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  360:  }
    #####:  361:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  362:    
        -:  363:  //Code for determining the player
    #####:  364:  if (currentPlayer < (state->numPlayers - 1)){ 
    #####:  365:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  366:  }
        -:  367:  else{
    #####:  368:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  369:  }
        -:  370:
    #####:  371:  state->outpostPlayed = 0;
    #####:  372:  state->phase = 0;
    #####:  373:  state->numActions = 1;
    #####:  374:  state->coins = 0;
    #####:  375:  state->numBuys = 1;
    #####:  376:  state->playedCardCount = 0;
    #####:  377:  state->handCount[state->whoseTurn] = 0;
        -:  378:
        -:  379:  //int k; move to top
        -:  380:  //Next player draws hand
    #####:  381:  for (k = 0; k < 5; k++){
    #####:  382:    drawCard(state->whoseTurn, state);//Draw a card
        -:  383:  }
        -:  384:
        -:  385:  //Update money
    #####:  386:  updateCoins(state->whoseTurn, state , 0);
        -:  387:
    #####:  388:  return 0;
        -:  389:}
        -:  390:
    #####:  391:int isGameOver(struct gameState *state) {
        -:  392:  int i;
        -:  393:  int j;
        -:  394:	
        -:  395:  //if stack of Province cards is empty, the game ends
    #####:  396:  if (state->supplyCount[province] == 0)
        -:  397:    {
    #####:  398:      return 1;
        -:  399:    }
        -:  400:
        -:  401:  //if three supply pile are at 0, the game ends
    #####:  402:    j = 0;
    #####:  403:    for (i = 0; i < 25; i++)
        -:  404:    {
    #####:  405:      if (state->supplyCount[i] == 0)
        -:  406:        {
    #####:  407:          j++;
        -:  408:        }
        -:  409:    }
    #####:  410:    if ( j >= 3)
        -:  411:    {
    #####:  412:      return 1;
        -:  413:    }
        -:  414:
    #####:  415:  return 0;
        -:  416:}
        -:  417:
    #####:  418:int scoreFor (int player, struct gameState *state) {
        -:  419:
        -:  420:  int i;
    #####:  421:  int score = 0;
        -:  422:  //score from hand
    #####:  423:  for (i = 0; i < state->handCount[player]; i++)
        -:  424:    {
    #####:  425:      if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  426:      if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  427:      if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  428:      if (state->hand[player][i] == province) { score = score + 6; };
    #####:  429:      if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  430:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  431:    }
        -:  432:
        -:  433:  //score from discard
    #####:  434:  for (i = 0; i < state->discardCount[player]; i++)
        -:  435:    {
    #####:  436:      if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  437:      if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  438:      if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  439:      if (state->discard[player][i] == province) { score = score + 6; };
    #####:  440:      if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  441:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  442:    }
        -:  443:
        -:  444:  //score from deck
    #####:  445:  for (i = 0; i < state->discardCount[player]; i++)
        -:  446:    {
    #####:  447:      if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  448:      if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  449:      if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  450:      if (state->deck[player][i] == province) { score = score + 6; };
    #####:  451:      if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  452:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  453:    }
        -:  454:
    #####:  455:  return score;
        -:  456:}
        -:  457:
    #####:  458:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  459:  int i;	
        -:  460:  int j;
        -:  461:  int highScore;
        -:  462:  int currentPlayer;
        -:  463:
        -:  464:  //get score for each player
    #####:  465:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  466:    {
        -:  467:      //set unused player scores to -9999
    #####:  468:      if (i >= state->numPlayers)
        -:  469:	{
    #####:  470:	  players[i] = -9999;
        -:  471:	}
        -:  472:      else
        -:  473:	{
    #####:  474:	  players[i] = scoreFor (i, state);
        -:  475:	}
        -:  476:    }
        -:  477:
        -:  478:  //find highest score
    #####:  479:  j = 0;
    #####:  480:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  481:    {
    #####:  482:      if (players[i] > players[j])
        -:  483:	{
    #####:  484:	  j = i;
        -:  485:	}
        -:  486:    }
    #####:  487:  highScore = players[j];
        -:  488:
        -:  489:  //add 1 to players who had less turns
    #####:  490:  currentPlayer = whoseTurn(state);
    #####:  491:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  492:    {
    #####:  493:      if ( players[i] == highScore && i > currentPlayer )
        -:  494:	{
    #####:  495:	  players[i]++;
        -:  496:	}
        -:  497:    }
        -:  498:
        -:  499:  //find new highest score
    #####:  500:  j = 0;
    #####:  501:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  502:    {
    #####:  503:      if ( players[i] > players[j] )
        -:  504:	{
    #####:  505:	  j = i;
        -:  506:	}
        -:  507:    }
    #####:  508:  highScore = players[j];
        -:  509:
        -:  510:  //set winners in array to 1 and rest to 0
    #####:  511:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  512:    {
    #####:  513:      if ( players[i] == highScore )
        -:  514:	{
    #####:  515:	  players[i] = 1;
        -:  516:	}
        -:  517:      else
        -:  518:	{
    #####:  519:	  players[i] = 0;
        -:  520:	}
        -:  521:    }
        -:  522:
    #####:  523:  return 0;
        -:  524:}
        -:  525:
        5:  526:int drawCard(int player, struct gameState *state)
        -:  527:{	int count;
        -:  528:  int deckCounter;
        5:  529:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  530:    
        -:  531:    //Step 1 Shuffle the discard pile back into a deck
        -:  532:    int i;
        -:  533:    //Move discard to deck
    #####:  534:    for (i = 0; i < state->discardCount[player];i++){
    #####:  535:      state->deck[player][i] = state->discard[player][i];
    #####:  536:      state->discard[player][i] = -1;
        -:  537:    }
        -:  538:
    #####:  539:    state->deckCount[player] = state->discardCount[player];
    #####:  540:    state->discardCount[player] = 0;//Reset discard
        -:  541:
        -:  542:    //Shufffle the deck
    #####:  543:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  544:   
        -:  545:    if (DEBUG){//Debug statements
        -:  546:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  547:    }
        -:  548:    
    #####:  549:    state->discardCount[player] = 0;
        -:  550:
        -:  551:    //Step 2 Draw Card
    #####:  552:    count = state->handCount[player];//Get current player's hand count
        -:  553:    
        -:  554:    if (DEBUG){//Debug statements
        -:  555:      printf("Current hand count: %d\n", count);
        -:  556:    }
        -:  557:    
    #####:  558:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  559:
    #####:  560:    if (deckCounter == 0)
    #####:  561:      return -1;
        -:  562:
    #####:  563:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  564:    state->deckCount[player]--;
    #####:  565:    state->handCount[player]++;//Increment hand count
        -:  566:  }
        -:  567:
        -:  568:  else{
        5:  569:    int count = state->handCount[player];//Get current hand count for player
        -:  570:    int deckCounter;
        -:  571:    if (DEBUG){//Debug statements
        -:  572:      printf("Current hand count: %d\n", count);
        -:  573:    }
        -:  574:
        5:  575:    deckCounter = state->deckCount[player];//Create holder for the deck count
        5:  576:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
        5:  577:    state->deckCount[player]--;
        5:  578:    state->handCount[player]++;//Increment hand count
        -:  579:  }
        -:  580:
        5:  581:  return 0;
        -:  582:}
        -:  583:
    #####:  584:int getCost(int cardNumber)
        -:  585:{
    #####:  586:  switch( cardNumber ) 
        -:  587:    {
        -:  588:    case curse:
    #####:  589:      return 0;
        -:  590:    case estate:
    #####:  591:      return 2;
        -:  592:    case duchy:
    #####:  593:      return 5;
        -:  594:    case province:
    #####:  595:      return 8;
        -:  596:    case copper:
    #####:  597:      return 0;
        -:  598:    case silver:
    #####:  599:      return 3;
        -:  600:    case gold:
    #####:  601:      return 6;
        -:  602:    case adventurer:
    #####:  603:      return 6;
        -:  604:    case council_room:
    #####:  605:      return 5;
        -:  606:    case feast:
    #####:  607:      return 4;
        -:  608:    case gardens:
    #####:  609:      return 4;
        -:  610:    case mine:
    #####:  611:      return 5;
        -:  612:    case remodel:
    #####:  613:      return 4;
        -:  614:    case smithy:
    #####:  615:      return 4;
        -:  616:    case village:
    #####:  617:      return 3;
        -:  618:    case baron:
    #####:  619:      return 4;
        -:  620:    case great_hall:
    #####:  621:      return 3;
        -:  622:    case minion:
    #####:  623:      return 5;
        -:  624:    case steward:
    #####:  625:      return 3;
        -:  626:    case tribute:
    #####:  627:      return 5;
        -:  628:    case ambassador:
    #####:  629:      return 3;
        -:  630:    case cutpurse:
    #####:  631:      return 4;
        -:  632:    case embargo: 
    #####:  633:      return 2;
        -:  634:    case outpost:
    #####:  635:      return 5;
        -:  636:    case salvager:
    #####:  637:      return 4;
        -:  638:    case sea_hag:
    #####:  639:      return 4;
        -:  640:    case treasure_map:
    #####:  641:      return 4;
        -:  642:    }
        -:  643:	
    #####:  644:  return -1;
        -:  645:}
        -:  646:
        -:  647:
    #####:  648:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  649:{
        -:  650:  int i;
        -:  651:  int j;
        -:  652://  int k;
        -:  653:  int x;
        -:  654:  int index;
    #####:  655:  int currentPlayer = whoseTurn(state);
    #####:  656:  int nextPlayer = currentPlayer + 1;
        -:  657:
    #####:  658:  int tributeRevealedCards[2] = {-1, -1};
        -:  659:  int temphand[MAX_HAND];// moved above the if statement
    #####:  660:  int drawntreasure=0;
        -:  661:  int cardDrawn;
    #####:  662:  int z = 0;// this is the counter for the temp hand
    #####:  663:  if (nextPlayer > (state->numPlayers - 1)){
    #####:  664:    nextPlayer = 0;
        -:  665:  }
        -:  666:  
        -:  667:	
        -:  668:  //uses switch to select card and perform actions
    #####:  669:  switch( card ) 
        -:  670:    {
        -:  671:    case adventurer:
    #####:  672:	 return playAdventurer(state);
        -:  673:			
        -:  674:    case council_room:
    #####:  675:	  return playCouncil_Room(state, handPos);
        -:  676:			
        -:  677:    case feast:
        -:  678:      //gain card with cost up to 5
        -:  679:      //Backup hand
    #####:  680:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  681:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  682:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  683:      }
        -:  684:      //Backup hand
        -:  685:
        -:  686:      //Update Coins for Buy
    #####:  687:      updateCoins(currentPlayer, state, 5);
    #####:  688:      x = 1;//Condition to loop on
    #####:  689:      while( x == 1) {//Buy one card
    #####:  690:	if (supplyCount(choice1, state) <= 0){
        -:  691:	  if (DEBUG)
        -:  692:	    printf("None of that card left, sorry!\n");
        -:  693:
        -:  694:	  if (DEBUG){
        -:  695:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  696:	  }
        -:  697:	}
    #####:  698:	else if (state->coins < getCost(choice1)){
    #####:  699:	  printf("That card is too expensive!\n");
        -:  700:
        -:  701:	  if (DEBUG){
        -:  702:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  703:	  }
        -:  704:	}
        -:  705:	else{
        -:  706:
        -:  707:	  if (DEBUG){
        -:  708:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  709:	  }
        -:  710:
    #####:  711:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  712:	  x = 0;//No more buying cards
        -:  713:
        -:  714:	  if (DEBUG){
        -:  715:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  716:	  }
        -:  717:
        -:  718:	}
        -:  719:      }     
        -:  720:
        -:  721:      //Reset Hand
    #####:  722:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  723:	state->hand[currentPlayer][i] = temphand[i];
    #####:  724:	temphand[i] = -1;
        -:  725:      }
        -:  726:      //Reset Hand
        -:  727:      			
    #####:  728:      return 0;
        -:  729:			
        -:  730:    case gardens:
    #####:  731:      return -1;
        -:  732:			
        -:  733:    case mine:
    #####:  734:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  735:
    #####:  736:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  737:	{
    #####:  738:	  return -1;
        -:  739:	}
        -:  740:		
    #####:  741:      if (choice2 > treasure_map || choice2 < curse)
        -:  742:	{
    #####:  743:	  return -1;
        -:  744:	}
        -:  745:
    #####:  746:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
        -:  747:	{
    #####:  748:	  return -1;
        -:  749:	}
        -:  750:
    #####:  751:      gainCard(choice2, state, 2, currentPlayer);
        -:  752:
        -:  753:      //discard card from hand
    #####:  754:      discardCard(handPos, currentPlayer, state, 0);
        -:  755:
        -:  756:      //discard trashed card
    #####:  757:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  758:	{
    #####:  759:	  if (state->hand[currentPlayer][i] == j)
        -:  760:	    {
    #####:  761:	      discardCard(i, currentPlayer, state, 0);			
    #####:  762:	      break;
        -:  763:	    }
        -:  764:	}
        -:  765:			
    #####:  766:      return 0;
        -:  767:			
        -:  768:    case remodel:
    #####:  769:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  770:
    #####:  771:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  772:	{
    #####:  773:	  return -1;
        -:  774:	}
        -:  775:
    #####:  776:      gainCard(choice2, state, 0, currentPlayer);
        -:  777:
        -:  778:      //discard card from hand
    #####:  779:      discardCard(handPos, currentPlayer, state, 0);
        -:  780:
        -:  781:      //discard trashed card
    #####:  782:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  783:	{
    #####:  784:	  if (state->hand[currentPlayer][i] == j)
        -:  785:	    {
    #####:  786:	      discardCard(i, currentPlayer, state, 0);			
    #####:  787:	      break;
        -:  788:	    }
        -:  789:	}
        -:  790:
        -:  791:
    #####:  792:      return 0;
        -:  793:		
        -:  794:    case smithy:
    #####:  795:	  return playSmithy(state, handPos);
        -:  796:      /* //+3 Cards
        -:  797:      for (i = 0; i < 3; i++)
        -:  798:	  {
        -:  799:	    drawCard(currentPlayer, state);
        -:  800:	  }
        -:  801:			
        -:  802:      //discard card from hand
        -:  803:      discardCard(handPos, currentPlayer, state, 0);
        -:  804:      return 0; */
        -:  805:		
        -:  806:    case village:
    #####:  807:        return playVillage(state, handPos);
        -:  808:      /*
        -:  809:      //+1 Card
        -:  810:      drawCard(currentPlayer, state);
        -:  811:			
        -:  812:      //+2 Actions
        -:  813:      state->numActions = state->numActions + 2;
        -:  814:			
        -:  815:      //discard played card from hand
        -:  816:      discardCard(handPos, currentPlayer, state, 0);
        -:  817:      return 0;
        -:  818:       */	
        -:  819:    case baron:
    #####:  820:      state->numBuys++;//Increase buys by 1!
    #####:  821:      if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  822:	int p = 0;//Iterator for hand!
    #####:  823:	int card_not_discarded = 1;//Flag for discard set!
    #####:  824:	while(card_not_discarded){
    #####:  825:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
    #####:  826:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  827:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  828:	    state->discardCount[currentPlayer]++;
    #####:  829:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:  830:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  831:	    }
    #####:  832:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  833:	    state->handCount[currentPlayer]--;
    #####:  834:	    card_not_discarded = 0;//Exit the loop
        -:  835:	  }
    #####:  836:	  else if (p > state->handCount[currentPlayer]){
        -:  837:	    if(DEBUG) {
        -:  838:	      printf("No estate cards in your hand, invalid choice\n");
        -:  839:	      printf("Must gain an estate if there are any\n");
        -:  840:	    }
    #####:  841:	    if (supplyCount(estate, state) > 0){
    #####:  842:	      gainCard(estate, state, 0, currentPlayer);
    #####:  843:	      state->supplyCount[estate]--;//Decrement estates
    #####:  844:	      if (supplyCount(estate, state) == 0){
    #####:  845:		isGameOver(state);
        -:  846:	      }
        -:  847:	    }
    #####:  848:	    card_not_discarded = 0;//Exit the loop
        -:  849:	  }
        -:  850:			    
        -:  851:	  else{
    #####:  852:	    p++;//Next card
        -:  853:	  }
        -:  854:	}
        -:  855:      }
        -:  856:			    
        -:  857:      else{
    #####:  858:	if (supplyCount(estate, state) > 0){
    #####:  859:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  860:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  861:	  if (supplyCount(estate, state) == 0){
    #####:  862:	    isGameOver(state);
        -:  863:	  }
        -:  864:	}
        -:  865:      }
        -:  866:	    
        -:  867:      
    #####:  868:      return 0;
        -:  869:		
        -:  870:    case great_hall:
        -:  871:      //+1 Card
    #####:  872:      drawCard(currentPlayer, state);
        -:  873:			
        -:  874:      //+1 Actions
    #####:  875:      state->numActions++;
        -:  876:			
        -:  877:      //discard card from hand
    #####:  878:      discardCard(handPos, currentPlayer, state, 0);
    #####:  879:      return 0;
        -:  880:		
        -:  881:    case minion:
        -:  882:      //+1 action
    #####:  883:      state->numActions++;
        -:  884:			
        -:  885:      //discard card from hand
    #####:  886:      discardCard(handPos, currentPlayer, state, 0);
        -:  887:			
    #####:  888:      if (choice1)		//+2 coins
        -:  889:	{
    #####:  890:	  state->coins = state->coins + 2;
        -:  891:	}
        -:  892:			
    #####:  893:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  894:	{
        -:  895:	  //discard hand
    #####:  896:	  while(numHandCards(state) > 0)
        -:  897:	    {
    #####:  898:	      discardCard(handPos, currentPlayer, state, 0);
        -:  899:	    }
        -:  900:				
        -:  901:	  //draw 4
    #####:  902:	  for (i = 0; i < 4; i++)
        -:  903:	    {
    #####:  904:	      drawCard(currentPlayer, state);
        -:  905:	    }
        -:  906:				
        -:  907:	  //other players discard hand and redraw if hand size > 4
    #####:  908:	  for (i = 0; i < state->numPlayers; i++)
        -:  909:	    {
    #####:  910:	      if (i != currentPlayer)
        -:  911:		{
    #####:  912:		  if ( state->handCount[i] > 4 )
        -:  913:		    {
        -:  914:		      //discard hand
    #####:  915:		      while( state->handCount[i] > 0 )
        -:  916:			{
    #####:  917:			  discardCard(handPos, i, state, 0);
        -:  918:			}
        -:  919:							
        -:  920:		      //draw 4
    #####:  921:		      for (j = 0; j < 4; j++)
        -:  922:			{
    #####:  923:			  drawCard(i, state);
        -:  924:			}
        -:  925:		    }
        -:  926:		}
        -:  927:	    }
        -:  928:				
        -:  929:	}
    #####:  930:      return 0;
        -:  931:		
        -:  932:    case steward:
    #####:  933:	  return playSteward(state, handPos, choice1, choice2, choice3);
        -:  934:
        -:  935:		
        -:  936:    case tribute:
    #####:  937:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####:  938:	if (state->deckCount[nextPlayer] > 0){
    #####:  939:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  940:	  state->deckCount[nextPlayer]--;
        -:  941:	}
    #####:  942:	else if (state->discardCount[nextPlayer] > 0){
    #####:  943:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  944:	  state->discardCount[nextPlayer]--;
        -:  945:	}
        -:  946:	else{
        -:  947:	  //No Card to Reveal
        -:  948:	  if (DEBUG){
        -:  949:	    printf("No cards to reveal\n");
        -:  950:	  }
        -:  951:	}
        -:  952:      }
        -:  953:	    
        -:  954:      else{
    #####:  955:	if (state->deckCount[nextPlayer] == 0){
    #####:  956:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####:  957:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  958:	    state->deckCount[nextPlayer]++;
    #####:  959:	    state->discard[nextPlayer][i] = -1;
    #####:  960:	    state->discardCount[nextPlayer]--;
        -:  961:	  }
        -:  962:			    
    #####:  963:	  shuffle(nextPlayer,state);//Shuffle the deck
        -:  964:	} 
    #####:  965:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  966:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  967:	state->deckCount[nextPlayer]--;
    #####:  968:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  969:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  970:	state->deckCount[nextPlayer]--;
        -:  971:      }    
        -:  972:		       
    #####:  973:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####:  974:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  975:	state->playedCardCount++;
    #####:  976:	tributeRevealedCards[1] = -1;
        -:  977:      } 
        -:  978:
    #####:  979:      for (i = 0; i <= 2; i ++){
    #####:  980:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####:  981:	  state->coins += 2;
        -:  982:	}
        -:  983:		    
    #####:  984:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####:  985:	  drawCard(currentPlayer, state);
    #####:  986:	  drawCard(currentPlayer, state);
        -:  987:	}
        -:  988:	else{//Action Card
    #####:  989:	  state->numActions = state->numActions + 2;
        -:  990:	}
        -:  991:      }
        -:  992:	    
    #####:  993:      return 0;
        -:  994:		
        -:  995:    case ambassador:
    #####:  996:      j = 0;		//used to check if player has enough cards to discard
        -:  997:
    #####:  998:      if (choice2 > 2 || choice2 < 0)
        -:  999:	{
    #####: 1000:	  return -1;				
        -: 1001:	}
        -: 1002:
    #####: 1003:      if (choice1 == handPos)
        -: 1004:	{
    #####: 1005:	  return -1;
        -: 1006:	}
        -: 1007:
    #####: 1008:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1009:	{
    #####: 1010:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1011:	    {
    #####: 1012:	      j++;
        -: 1013:	    }
        -: 1014:	}
    #####: 1015:      if (j < choice2)
        -: 1016:	{
    #####: 1017:	  return -1;				
        -: 1018:	}
        -: 1019:
        -: 1020:      if (DEBUG) 
        -: 1021:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1022:
        -: 1023:      //increase supply count for choosen card by amount being discarded
    #####: 1024:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1025:			
        -: 1026:      //each other player gains a copy of revealed card
    #####: 1027:      for (i = 0; i < state->numPlayers; i++)
        -: 1028:	{
    #####: 1029:	  if (i != currentPlayer)
        -: 1030:	    {
    #####: 1031:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1032:	    }
        -: 1033:	}
        -: 1034:
        -: 1035:      //discard played card from hand
    #####: 1036:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1037:
        -: 1038:      //trash copies of cards returned to supply
    #####: 1039:      for (j = 0; j < choice2; j++)
        -: 1040:	{
    #####: 1041:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1042:	    {
    #####: 1043:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1044:		{
    #####: 1045:		  discardCard(i, currentPlayer, state, 1);
    #####: 1046:		  break;
        -: 1047:		}
        -: 1048:	    }
        -: 1049:	}			
        -: 1050:
    #####: 1051:      return 0;
        -: 1052:		
        -: 1053:    case cutpurse:
        -: 1054:
        -: 1055:/*       updateCoins(currentPlayer, state, 2);
        -: 1056:      for (i = 0; i < state->numPlayers; i++)
        -: 1057:	{
        -: 1058:	  if (i != currentPlayer)
        -: 1059:	    {
        -: 1060:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1061:		{
        -: 1062:		  if (state->hand[i][j] == copper)
        -: 1063:		    {
        -: 1064:		      discardCard(j, i, state, 0);
        -: 1065:		      break;
        -: 1066:		    }
        -: 1067:		  if (j == state->handCount[i])
        -: 1068:		    {
        -: 1069:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1070:			{
        -: 1071:			  if (DEBUG)
        -: 1072:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1073:			}	
        -: 1074:		      break;
        -: 1075:		    }		
        -: 1076:		}
        -: 1077:					
        -: 1078:	    }
        -: 1079:				
        -: 1080:	}				
        -: 1081:
        -: 1082:      //discard played card from hand
        -: 1083:      discardCard(handPos, currentPlayer, state, 0); */			
        -: 1084:
    #####: 1085:      return playCutpurse(state, handPos);
        -: 1086:
        -: 1087:		
        -: 1088:    case embargo: 
        -: 1089:      //+2 Coins
    #####: 1090:      state->coins = state->coins + 2;
        -: 1091:			
        -: 1092:      //see if selected pile is in play
    #####: 1093:      if ( state->supplyCount[choice1] == -1 )
        -: 1094:	{
    #####: 1095:	  return -1;
        -: 1096:	}
        -: 1097:			
        -: 1098:      //add embargo token to selected supply pile
    #####: 1099:      state->embargoTokens[choice1]++;
        -: 1100:			
        -: 1101:      //trash card
    #####: 1102:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1103:      return 0;
        -: 1104:		
        -: 1105:    case outpost:
        -: 1106:      //set outpost flag
    #####: 1107:      state->outpostPlayed++;
        -: 1108:			
        -: 1109:      //discard card
    #####: 1110:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1111:      return 0;
        -: 1112:		
        -: 1113:    case salvager:
        -: 1114:      //+1 buy
    #####: 1115:      state->numBuys++;
        -: 1116:			
    #####: 1117:      if (choice1)
        -: 1118:	{
        -: 1119:	  //gain coins equal to trashed card
    #####: 1120:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1121:	  //trash card
    #####: 1122:	  discardCard(choice1, currentPlayer, state, 1);	
        -: 1123:	}
        -: 1124:			
        -: 1125:      //discard card
    #####: 1126:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1127:      return 0;
        -: 1128:		
        -: 1129:    case sea_hag:
    #####: 1130:      for (i = 0; i < state->numPlayers; i++){
    #####: 1131:	if (i != currentPlayer){
    #####: 1132:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1133:	  state->discardCount[i]++;
    #####: 1134:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1135:	}
        -: 1136:      }
    #####: 1137:      return 0;
        -: 1138:		
        -: 1139:    case treasure_map:
        -: 1140:      //search hand for another treasure_map
    #####: 1141:      index = -1;
    #####: 1142:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1143:	{
    #####: 1144:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1145:	    {
    #####: 1146:	      index = i;
    #####: 1147:	      break;
        -: 1148:	    }
        -: 1149:	}
    #####: 1150:      if (index > -1)
        -: 1151:	{
        -: 1152:	  //trash both treasure cards
    #####: 1153:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1154:	  discardCard(index, currentPlayer, state, 1);
        -: 1155:
        -: 1156:	  //gain 4 Gold cards
    #####: 1157:	  for (i = 0; i < 4; i++)
        -: 1158:	    {
    #####: 1159:	      gainCard(gold, state, 1, currentPlayer);
        -: 1160:	    }
        -: 1161:				
        -: 1162:	  //return success
    #####: 1163:	  return 1;
        -: 1164:	}
        -: 1165:			
        -: 1166:      //no second treasure_map found in hand
    #####: 1167:      return -1;
        -: 1168:    }
        -: 1169:	
    #####: 1170:  return -1;
        -: 1171:}
        -: 1172:
    #####: 1173:int playAdventurer(struct gameState *state){
    #####: 1174:	int drawntreasure = 0;
        -: 1175:	int cardDrawn;
    #####: 1176:	int currentPlayer = whoseTurn(state);
        -: 1177:    int temphand[MAX_HAND];// moved above the if statement
    #####: 1178:    int z = 0;// this is the counter for the temp hand
        -: 1179:
        -: 1180:	
    #####: 1181:	while(drawntreasure<3){
    #####: 1182:		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
    #####: 1183:		  shuffle(currentPlayer, state);
        -: 1184:		}
    #####: 1185:		drawCard(currentPlayer, state);
    #####: 1186:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####: 1187:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####: 1188:		  drawntreasure++;
        -: 1189:		else{
    #####: 1190:		  temphand[z]=cardDrawn;
    #####: 1191:		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####: 1192:		  z++;
        -: 1193:		}
        -: 1194:	  }
    #####: 1195:	  while(z-1>=0){
    #####: 1196:		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####: 1197:	   z=z-1;
        -: 1198:	  }
        -: 1199:	  
    #####: 1200:	return 0;
        -: 1201:}
        -: 1202:
        -: 1203://Add 4 cards
    #####: 1204:int playCouncil_Room(struct gameState *state, int handPos){
    #####: 1205:	int currentPlayer = whoseTurn(state);
        -: 1206:	int i;
        -: 1207:  
    #####: 1208:    for (i = 0; i < 5; i++)
        -: 1209:	{
    #####: 1210:	  drawCard(currentPlayer, state);
        -: 1211:	}
        -: 1212:			
        -: 1213:    //+1 Buy
    #####: 1214:    state->numBuys++;
        -: 1215:			
        -: 1216:    //Each other player draws a card
    #####: 1217:    for (i = 0; i < state->numPlayers; i++)
        -: 1218:	{
    #####: 1219:	  if ( i != currentPlayer )
        -: 1220:	  {
    #####: 1221:	    drawCard(i, state);
        -: 1222:	  }
        -: 1223:	}
        -: 1224:			
        -: 1225:    //put played card in played card pile
    #####: 1226:    discardCard(handPos, currentPlayer, state, 0);
    #####: 1227:	return 0;
        -: 1228:}
        -: 1229:
    #####: 1230:int playSmithy(struct gameState *state, int handPos){
        -: 1231:    int i;
    #####: 1232:    int currentPlayer = whoseTurn(state);
        -: 1233:
        -: 1234:    //+3 Cards
    #####: 1235:    for (i = 0; i < 3; i++)
        -: 1236:    {
    #####: 1237:      drawCard(currentPlayer, state);
        -: 1238:    }
        -: 1239:    	
        -: 1240:    //discard card from hand
    #####: 1241:    discardCard(handPos, currentPlayer, state, 0-1);
    #####: 1242:    return 0;
        -: 1243:}
        -: 1244:
    #####: 1245:int playCutpurse(struct gameState *state, int handPos){
        -: 1246:	int i, j, k;
    #####: 1247:	int currentPlayer = whoseTurn(state);
        -: 1248:
        -: 1249:	
    #####: 1250:    updateCoins(currentPlayer, state, 2);
    #####: 1251:    for (i = 0; i < state->numPlayers; i++)
        -: 1252:	{
    #####: 1253:	  if (i != currentPlayer)
        -: 1254:	  {
    #####: 1255:	    for (j = 0; j <= state->handCount[i]; j++){
    #####: 1256:          if (state->hand[i][j] == copper){
    #####: 1257:	        discardCard(j, i, state, 0);
    #####: 1258:		    return -1;
        -: 1259:	      }
    #####: 1260:	      if (j = state->handCount[i]){
    #####: 1261:            for (k = 0; k < state->handCount[i]; k++){
        -: 1262:		      if (DEBUG)
        -: 1263:                printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1264:            }	
    #####: 1265:		  return -1;
        -: 1266:          }		
        -: 1267:		}
        -: 1268:					
        -: 1269:	  }//end != currentPlayer switch		
        -: 1270:	}
        -: 1271:
        -: 1272:    //discard played card from hand
    #####: 1273:	discardCard(handPos, currentPlayer, state, 0);
        -: 1274:	
    #####: 1275:	return 0;
        -: 1276:}
        -: 1277:
    #####: 1278:int playSteward(struct gameState *state, int handPos, int choice1, int choice2, int choice3){
    #####: 1279:  int currentPlayer = whoseTurn(state);
        -: 1280:
    #####: 1281:  if (choice1 == 1) {
        -: 1282:  //+2 cards
    #####: 1283:    drawCard(currentPlayer, state);
    #####: 1284:    drawCard(currentPlayer, state);
        -: 1285:  }
    #####: 1286:  else if (choice1 == 2) {
        -: 1287:  //+2 coins
    #####: 1288:    state->coins = state->coins + 2;
        -: 1289:  }
        -: 1290:  else {
        -: 1291:  //trash 2 cards in hand
    #####: 1292:    discardCard(choice2, currentPlayer, state, 1);
    #####: 1293:    discardCard(choice3, currentPlayer, state, 1);
        -: 1294:  }
        -: 1295:	
        -: 1296:  //discard card from hand
    #####: 1297:  discardCard(handPos, currentPlayer, state, 0);
    #####: 1298:  return 0;
        -: 1299:}
        -: 1300:
    #####: 1301:int playVillage(struct gameState *state, int handPos){
    #####: 1302:    int currentPlayer = whoseTurn(state);
        -: 1303:
        -: 1304:    //+1 Card
    #####: 1305:     drawCard(currentPlayer, state);
        -: 1306:
        -: 1307:     //+2 Actions
    #####: 1308:     state->numActions = state->numActions + 2;
        -: 1309:
        -: 1310:     //discard played card from hand
    #####: 1311:     discardCard(handPos, currentPlayer, state, 0);
    #####: 1312:     return 0;
        -: 1313:}
        -: 1314:
    #####: 1315:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1316:{
        -: 1317:	
        -: 1318:  //if card is not trashed, added to Played pile 
    #####: 1319:  if (trashFlag < 1)
        -: 1320:    {
        -: 1321:      //add card to played pile
    #####: 1322:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1323:      state->playedCardCount++;
        -: 1324:    }
        -: 1325:	
        -: 1326:  //set played card to -1
    #####: 1327:  state->hand[currentPlayer][handPos] = -1;
        -: 1328:	
        -: 1329:  //remove card from player's hand
    #####: 1330:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1331:    {
        -: 1332:      //reduce number of cards in hand
    #####: 1333:      state->handCount[currentPlayer]--;
        -: 1334:    }
    #####: 1335:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1336:    {
        -: 1337:      //reduce number of cards in hand
    #####: 1338:      state->handCount[currentPlayer]--;
        -: 1339:    }
        -: 1340:  else 	
        -: 1341:    {
        -: 1342:      //replace discarded card with last card in hand
    #####: 1343:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1344:      //set last card to -1
    #####: 1345:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1346:      //reduce number of cards in hand
    #####: 1347:      state->handCount[currentPlayer]--;
        -: 1348:    }
        -: 1349:	
    #####: 1350:  return 0;
        -: 1351:}
        -: 1352:
    #####: 1353:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1354:{
        -: 1355:  //Note: supplyPos is enum of choosen card
        -: 1356:	
        -: 1357:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1358:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1359:    {
    #####: 1360:      return -1;
        -: 1361:    }
        -: 1362:	
        -: 1363:  //added card for [whoseTurn] current player:
        -: 1364:  // toFlag = 0 : add to discard
        -: 1365:  // toFlag = 1 : add to deck
        -: 1366:  // toFlag = 2 : add to hand
        -: 1367:
    #####: 1368:  if (toFlag == 1)
        -: 1369:    {
    #####: 1370:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1371:      state->deckCount[player]++;
        -: 1372:    }
    #####: 1373:  else if (toFlag == 2)
        -: 1374:    {
    #####: 1375:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1376:      state->handCount[player]++;
        -: 1377:    }
        -: 1378:  else
        -: 1379:    {
    #####: 1380:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1381:      state->discardCount[player]++;
        -: 1382:    }
        -: 1383:	
        -: 1384:  //decrease number in supply pile
    #####: 1385:  state->supplyCount[supplyPos]--;
        -: 1386:	 
    #####: 1387:  return 0;
        -: 1388:}
        -: 1389:
        1: 1390:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1391:{
        -: 1392:  int i;
        -: 1393:	
        -: 1394:  //reset coin count
        1: 1395:  state->coins = 0;
        -: 1396:
        -: 1397:  //add coins for each Treasure card in player's hand
        6: 1398:  for (i = 0; i < state->handCount[player]; i++)
        -: 1399:    {
        5: 1400:      if (state->hand[player][i] == copper)
        -: 1401:	{
        4: 1402:	  state->coins += 1;
        -: 1403:	}
        1: 1404:      else if (state->hand[player][i] == silver)
        -: 1405:	{
    #####: 1406:	  state->coins += 2;
        -: 1407:	}
        1: 1408:      else if (state->hand[player][i] == gold)
        -: 1409:	{
    #####: 1410:	  state->coins += 3;
        -: 1411:	}	
        -: 1412:    }	
        -: 1413:
        -: 1414:  //add bonus
        1: 1415:  state->coins += bonus;
        -: 1416:
        1: 1417:  return 0;
        -: 1418:}
        -: 1419:
        -: 1420:
        -: 1421://end of dominion.c
        -: 1422:
Handcount p0: 5 
Handcount p1: 0 

Testing updateCoins() with seed 1234
Game Initialized! :)
__ALL TESTS PASSED!__

File 'dominion.c'
Lines executed:16.37% of 568
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:3
        -:    0:Programs:2
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
       90:    8:int compare(const void* a, const void* b) {
       90:    9:  if (*(int*)a > *(int*)b)
    #####:   10:    return 1;
       90:   11:  if (*(int*)a < *(int*)b)
       24:   12:    return -1;
       66:   13:  return 0;
        -:   14:}
        -:   15:
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
        -:   21:
    #####:   22:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   23:		  int k8, int k9, int k10) {
    #####:   24:  int* k = malloc(10 * sizeof(int));
    #####:   25:  k[0] = k1;
    #####:   26:  k[1] = k2;
    #####:   27:  k[2] = k3;
    #####:   28:  k[3] = k4;
    #####:   29:  k[4] = k5;
    #####:   30:  k[5] = k6;
    #####:   31:  k[6] = k7;
    #####:   32:  k[7] = k8;
    #####:   33:  k[8] = k9;
    #####:   34:  k[9] = k10;
    #####:   35:  return k;
        -:   36:}
        -:   37:
        3:   38:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   39:		   struct gameState *state) {
        -:   40:
        -:   41:  int i;
        -:   42:  int j;
        -:   43:  int it;			
        -:   44:  //set up random number generator
        3:   45:  SelectStream(1);
        3:   46:  PutSeed((long)randomSeed);
        -:   47:  
        -:   48:  //check number of players
        3:   49:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   50:    {
    #####:   51:      return -1;
        -:   52:    }
        -:   53:
        -:   54:  //set number of players
        3:   55:  state->numPlayers = numPlayers;
        -:   56:
        -:   57:  //check selected kingdom cards are different
       33:   58:  for (i = 0; i < 10; i++)
        -:   59:    {
      330:   60:      for (j = 0; j < 10; j++)
        -:   61:        {
      300:   62:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   63:	    {
    #####:   64:	      return -1;
        -:   65:	    }
        -:   66:        }
        -:   67:    }
        -:   68:
        -:   69:
        -:   70:  //initialize supply
        -:   71:  ///////////////////////////////
        -:   72:
        -:   73:  //set number of Curse cards
        3:   74:  if (numPlayers == 2)
        -:   75:    {
        3:   76:      state->supplyCount[curse] = 10;
        -:   77:    }
    #####:   78:  else if (numPlayers == 3)
        -:   79:    {
    #####:   80:      state->supplyCount[curse] = 20;
        -:   81:    }
        -:   82:  else
        -:   83:    {
    #####:   84:      state->supplyCount[curse] = 30;
        -:   85:    }
        -:   86:
        -:   87:  //set number of Victory cards
        3:   88:  if (numPlayers == 2)
        -:   89:    {
        3:   90:      state->supplyCount[estate] = 8;
        3:   91:      state->supplyCount[duchy] = 8;
        3:   92:      state->supplyCount[province] = 8;
        -:   93:    }
        -:   94:  else
        -:   95:    {
    #####:   96:      state->supplyCount[estate] = 12;
    #####:   97:      state->supplyCount[duchy] = 12;
    #####:   98:      state->supplyCount[province] = 12;
        -:   99:    }
        -:  100:
        -:  101:  //set number of Treasure cards
        3:  102:  state->supplyCount[copper] = 60 - (7 * numPlayers);
        3:  103:  state->supplyCount[silver] = 40;
        3:  104:  state->supplyCount[gold] = 30;
        -:  105:
        -:  106:  //set number of Kingdom cards
       63:  107:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  108:    {
      495:  109:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  110:	{
      465:  111:	  if (kingdomCards[j] == i)
        -:  112:	    {
        -:  113:	      //check if card is a 'Victory' Kingdom card
       30:  114:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  115:		{
        6:  116:		  if (numPlayers == 2){ 
        3:  117:		    state->supplyCount[i] = 8; 
        -:  118:		  }
    #####:  119:		  else{ state->supplyCount[i] = 12; }
        -:  120:		}
        -:  121:	      else
        -:  122:		{
       27:  123:		  state->supplyCount[i] = 10;
        -:  124:		}
       30:  125:	      break;
        -:  126:	    }
        -:  127:	  else    //card is not in the set choosen for the game
        -:  128:	    {
      435:  129:	      state->supplyCount[i] = -1;
        -:  130:	    }
        -:  131:	}
        -:  132:
        -:  133:    }
        -:  134:
        -:  135:  ////////////////////////
        -:  136:  //supply intilization complete
        -:  137:
        -:  138:  //set player decks
        9:  139:  for (i = 0; i < numPlayers; i++)
        -:  140:    {
        6:  141:      state->deckCount[i] = 0;
       24:  142:      for (j = 0; j < 3; j++)
        -:  143:	{
       18:  144:	  state->deck[i][j] = estate;
       18:  145:	  state->deckCount[i]++;
        -:  146:	}
       48:  147:      for (j = 3; j < 10; j++)
        -:  148:	{
       42:  149:	  state->deck[i][j] = copper;
       42:  150:	  state->deckCount[i]++;		
        -:  151:	}
        -:  152:    }
        -:  153:
        -:  154:  //shuffle player decks
        9:  155:  for (i = 0; i < numPlayers; i++)
        -:  156:    {
        6:  157:      if ( shuffle(i, state) < 0 )
        -:  158:	{
    #####:  159:	  return -1;
        -:  160:	}
        -:  161:    }
        -:  162:
        -:  163:  //draw player hands
        9:  164:  for (i = 0; i < numPlayers; i++)
        -:  165:    {  
        -:  166:      //initialize hand size to zero
        6:  167:      state->handCount[i] = 0;
        6:  168:      state->discardCount[i] = 0;
        -:  169:      //draw 5 cards
        -:  170:      // for (j = 0; j < 5; j++)
        -:  171:      //	{
        -:  172:      //	  drawCard(i, state);
        -:  173:      //	}
        -:  174:    }
        -:  175:  
        -:  176:  //set embargo tokens to 0 for all supply piles
       84:  177:  for (i = 0; i <= treasure_map; i++)
        -:  178:    {
       81:  179:      state->embargoTokens[i] = 0;
        -:  180:    }
        -:  181:
        -:  182:  //initialize first player's turn
        3:  183:  state->outpostPlayed = 0;
        3:  184:  state->phase = 0;
        3:  185:  state->numActions = 1;
        3:  186:  state->numBuys = 1;
        3:  187:  state->playedCardCount = 0;
        3:  188:  state->whoseTurn = 0;
        3:  189:  state->handCount[state->whoseTurn] = 0;
        -:  190:  //int it; move to top
        -:  191:
        -:  192:  //Moved draw cards to here, only drawing at the start of a turn
       18:  193:  for (it = 0; it < 5; it++){
       15:  194:    drawCard(state->whoseTurn, state);
        -:  195:  }
        -:  196:
        3:  197:  updateCoins(state->whoseTurn, state, 0);
        -:  198:
        3:  199:  return 0;
        -:  200:}
        -:  201:
        6:  202:int shuffle(int player, struct gameState *state) {
        -:  203: 
        -:  204:
        -:  205:  int newDeck[MAX_DECK];
        6:  206:  int newDeckPos = 0;
        -:  207:  int card;
        -:  208:  int i;
        -:  209:
        6:  210:  if (state->deckCount[player] < 1)
    #####:  211:    return -1;
        6:  212:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  213:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  214:
       72:  215:  while (state->deckCount[player] > 0) {
       60:  216:    card = floor(Random() * state->deckCount[player]);
       60:  217:    newDeck[newDeckPos] = state->deck[player][card];
       60:  218:    newDeckPos++;
      231:  219:    for (i = card; i < state->deckCount[player]-1; i++) {
      171:  220:      state->deck[player][i] = state->deck[player][i+1];
        -:  221:    }
       60:  222:    state->deckCount[player]--;
        -:  223:  }
       66:  224:  for (i = 0; i < newDeckPos; i++) {
       60:  225:    state->deck[player][i] = newDeck[i];
       60:  226:    state->deckCount[player]++;
        -:  227:  }
        -:  228:
        6:  229:  return 0;
        -:  230:}
        -:  231:
    #####:  232:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  233:{	
        -:  234:  int card;
    #####:  235:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  236:
        -:  237:  //check if it is the right phase
    #####:  238:  if (state->phase != 0)
        -:  239:    {
    #####:  240:      return -1;
        -:  241:    }
        -:  242:	
        -:  243:  //check if player has enough actions
    #####:  244:  if ( state->numActions < 1 )
        -:  245:    {
    #####:  246:      return -1;
        -:  247:    }
        -:  248:	
        -:  249:  //get card played
    #####:  250:  card = handCard(handPos, state);
        -:  251:	
        -:  252:  //check if selected card is an action
    #####:  253:  if ( card < adventurer || card > treasure_map )
        -:  254:    {
    #####:  255:      return -1;
        -:  256:    }
        -:  257:	
        -:  258:  //play card
    #####:  259:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  260:    {
    #####:  261:      return -1;
        -:  262:    }
        -:  263:	
        -:  264:  //reduce number of actions
    #####:  265:  state->numActions--;
        -:  266:
        -:  267:  //update coins (Treasure cards may be added with card draws)
    #####:  268:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  269:	
    #####:  270:  return 0;
        -:  271:}
        -:  272:
    #####:  273:int buyCard(int supplyPos, struct gameState *state) {
        -:  274:  int who;
        -:  275:  if (DEBUG){
        -:  276:    printf("Entering buyCard...\n");
        -:  277:  }
        -:  278:
        -:  279:  // I don't know what to do about the phase thing.
        -:  280:
    #####:  281:  who = state->whoseTurn;
        -:  282:
    #####:  283:  if (state->numBuys < 1){
        -:  284:    if (DEBUG)
        -:  285:      printf("You do not have any buys left\n");
    #####:  286:    return -1;
    #####:  287:  } else if (supplyCount(supplyPos, state) <1){
        -:  288:    if (DEBUG)
        -:  289:      printf("There are not any of that type of card left\n");
    #####:  290:    return -1;
    #####:  291:  } else if (state->coins < getCost(supplyPos)){
        -:  292:    if (DEBUG) 
        -:  293:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  294:    return -1;
        -:  295:  } else {
    #####:  296:    state->phase=1;
        -:  297:    //state->supplyCount[supplyPos]--;
    #####:  298:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  299:  
    #####:  300:    state->coins = (state->coins) - (getCost(supplyPos));
    #####:  301:    state->numBuys--;
        -:  302:    if (DEBUG)
        -:  303:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  304:  }
        -:  305:
        -:  306:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  307:  //state->discardCount[who]++;
        -:  308:    
    #####:  309:  return 0;
        -:  310:}
        -:  311:
    #####:  312:int numHandCards(struct gameState *state) {
    #####:  313:  return state->handCount[ whoseTurn(state) ];
        -:  314:}
        -:  315:
    #####:  316:int handCard(int handPos, struct gameState *state) {
    #####:  317:  int currentPlayer = whoseTurn(state);
    #####:  318:  return state->hand[currentPlayer][handPos];
        -:  319:}
        -:  320:
    #####:  321:int supplyCount(int card, struct gameState *state) {
    #####:  322:  return state->supplyCount[card];
        -:  323:}
        -:  324:
    #####:  325:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  326:  int i;
    #####:  327:  int count = 0;
        -:  328:
    #####:  329:  for (i = 0; i < state->deckCount[player]; i++)
        -:  330:    {
    #####:  331:      if (state->deck[player][i] == card) count++;
        -:  332:    }
        -:  333:
    #####:  334:  for (i = 0; i < state->handCount[player]; i++)
        -:  335:    {
    #####:  336:      if (state->hand[player][i] == card) count++;
        -:  337:    }
        -:  338:
    #####:  339:  for (i = 0; i < state->discardCount[player]; i++)
        -:  340:    {
    #####:  341:      if (state->discard[player][i] == card) count++;
        -:  342:    }
        -:  343:
    #####:  344:  return count;
        -:  345:}
        -:  346:
       12:  347:int whoseTurn(struct gameState *state) {
       12:  348:  return state->whoseTurn;
        -:  349:}
        -:  350:
    #####:  351:int endTurn(struct gameState *state) {
        -:  352:  int k;
        -:  353:  int i;
    #####:  354:  int currentPlayer = whoseTurn(state);
        -:  355:  
        -:  356:  //Discard hand
    #####:  357:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  358:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  359:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  360:  }
    #####:  361:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  362:    
        -:  363:  //Code for determining the player
    #####:  364:  if (currentPlayer < (state->numPlayers - 1)){ 
    #####:  365:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  366:  }
        -:  367:  else{
    #####:  368:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  369:  }
        -:  370:
    #####:  371:  state->outpostPlayed = 0;
    #####:  372:  state->phase = 0;
    #####:  373:  state->numActions = 1;
    #####:  374:  state->coins = 0;
    #####:  375:  state->numBuys = 1;
    #####:  376:  state->playedCardCount = 0;
    #####:  377:  state->handCount[state->whoseTurn] = 0;
        -:  378:
        -:  379:  //int k; move to top
        -:  380:  //Next player draws hand
    #####:  381:  for (k = 0; k < 5; k++){
    #####:  382:    drawCard(state->whoseTurn, state);//Draw a card
        -:  383:  }
        -:  384:
        -:  385:  //Update money
    #####:  386:  updateCoins(state->whoseTurn, state , 0);
        -:  387:
    #####:  388:  return 0;
        -:  389:}
        -:  390:
    #####:  391:int isGameOver(struct gameState *state) {
        -:  392:  int i;
        -:  393:  int j;
        -:  394:	
        -:  395:  //if stack of Province cards is empty, the game ends
    #####:  396:  if (state->supplyCount[province] == 0)
        -:  397:    {
    #####:  398:      return 1;
        -:  399:    }
        -:  400:
        -:  401:  //if three supply pile are at 0, the game ends
    #####:  402:    j = 0;
    #####:  403:    for (i = 0; i < 25; i++)
        -:  404:    {
    #####:  405:      if (state->supplyCount[i] == 0)
        -:  406:        {
    #####:  407:          j++;
        -:  408:        }
        -:  409:    }
    #####:  410:    if ( j >= 3)
        -:  411:    {
    #####:  412:      return 1;
        -:  413:    }
        -:  414:
    #####:  415:  return 0;
        -:  416:}
        -:  417:
    #####:  418:int scoreFor (int player, struct gameState *state) {
        -:  419:
        -:  420:  int i;
    #####:  421:  int score = 0;
        -:  422:  //score from hand
    #####:  423:  for (i = 0; i < state->handCount[player]; i++)
        -:  424:    {
    #####:  425:      if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  426:      if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  427:      if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  428:      if (state->hand[player][i] == province) { score = score + 6; };
    #####:  429:      if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  430:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  431:    }
        -:  432:
        -:  433:  //score from discard
    #####:  434:  for (i = 0; i < state->discardCount[player]; i++)
        -:  435:    {
    #####:  436:      if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  437:      if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  438:      if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  439:      if (state->discard[player][i] == province) { score = score + 6; };
    #####:  440:      if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  441:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  442:    }
        -:  443:
        -:  444:  //score from deck
    #####:  445:  for (i = 0; i < state->discardCount[player]; i++)
        -:  446:    {
    #####:  447:      if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  448:      if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  449:      if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  450:      if (state->deck[player][i] == province) { score = score + 6; };
    #####:  451:      if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  452:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  453:    }
        -:  454:
    #####:  455:  return score;
        -:  456:}
        -:  457:
    #####:  458:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  459:  int i;	
        -:  460:  int j;
        -:  461:  int highScore;
        -:  462:  int currentPlayer;
        -:  463:
        -:  464:  //get score for each player
    #####:  465:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  466:    {
        -:  467:      //set unused player scores to -9999
    #####:  468:      if (i >= state->numPlayers)
        -:  469:	{
    #####:  470:	  players[i] = -9999;
        -:  471:	}
        -:  472:      else
        -:  473:	{
    #####:  474:	  players[i] = scoreFor (i, state);
        -:  475:	}
        -:  476:    }
        -:  477:
        -:  478:  //find highest score
    #####:  479:  j = 0;
    #####:  480:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  481:    {
    #####:  482:      if (players[i] > players[j])
        -:  483:	{
    #####:  484:	  j = i;
        -:  485:	}
        -:  486:    }
    #####:  487:  highScore = players[j];
        -:  488:
        -:  489:  //add 1 to players who had less turns
    #####:  490:  currentPlayer = whoseTurn(state);
    #####:  491:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  492:    {
    #####:  493:      if ( players[i] == highScore && i > currentPlayer )
        -:  494:	{
    #####:  495:	  players[i]++;
        -:  496:	}
        -:  497:    }
        -:  498:
        -:  499:  //find new highest score
    #####:  500:  j = 0;
    #####:  501:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  502:    {
    #####:  503:      if ( players[i] > players[j] )
        -:  504:	{
    #####:  505:	  j = i;
        -:  506:	}
        -:  507:    }
    #####:  508:  highScore = players[j];
        -:  509:
        -:  510:  //set winners in array to 1 and rest to 0
    #####:  511:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  512:    {
    #####:  513:      if ( players[i] == highScore )
        -:  514:	{
    #####:  515:	  players[i] = 1;
        -:  516:	}
        -:  517:      else
        -:  518:	{
    #####:  519:	  players[i] = 0;
        -:  520:	}
        -:  521:    }
        -:  522:
    #####:  523:  return 0;
        -:  524:}
        -:  525:
       15:  526:int drawCard(int player, struct gameState *state)
        -:  527:{	int count;
        -:  528:  int deckCounter;
       15:  529:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  530:    
        -:  531:    //Step 1 Shuffle the discard pile back into a deck
        -:  532:    int i;
        -:  533:    //Move discard to deck
    #####:  534:    for (i = 0; i < state->discardCount[player];i++){
    #####:  535:      state->deck[player][i] = state->discard[player][i];
    #####:  536:      state->discard[player][i] = -1;
        -:  537:    }
        -:  538:
    #####:  539:    state->deckCount[player] = state->discardCount[player];
    #####:  540:    state->discardCount[player] = 0;//Reset discard
        -:  541:
        -:  542:    //Shufffle the deck
    #####:  543:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  544:   
        -:  545:    if (DEBUG){//Debug statements
        -:  546:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  547:    }
        -:  548:    
    #####:  549:    state->discardCount[player] = 0;
        -:  550:
        -:  551:    //Step 2 Draw Card
    #####:  552:    count = state->handCount[player];//Get current player's hand count
        -:  553:    
        -:  554:    if (DEBUG){//Debug statements
        -:  555:      printf("Current hand count: %d\n", count);
        -:  556:    }
        -:  557:    
    #####:  558:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  559:
    #####:  560:    if (deckCounter == 0)
    #####:  561:      return -1;
        -:  562:
    #####:  563:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  564:    state->deckCount[player]--;
    #####:  565:    state->handCount[player]++;//Increment hand count
        -:  566:  }
        -:  567:
        -:  568:  else{
       15:  569:    int count = state->handCount[player];//Get current hand count for player
        -:  570:    int deckCounter;
        -:  571:    if (DEBUG){//Debug statements
        -:  572:      printf("Current hand count: %d\n", count);
        -:  573:    }
        -:  574:
       15:  575:    deckCounter = state->deckCount[player];//Create holder for the deck count
       15:  576:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
       15:  577:    state->deckCount[player]--;
       15:  578:    state->handCount[player]++;//Increment hand count
        -:  579:  }
        -:  580:
       15:  581:  return 0;
        -:  582:}
        -:  583:
    #####:  584:int getCost(int cardNumber)
        -:  585:{
    #####:  586:  switch( cardNumber ) 
        -:  587:    {
        -:  588:    case curse:
    #####:  589:      return 0;
        -:  590:    case estate:
    #####:  591:      return 2;
        -:  592:    case duchy:
    #####:  593:      return 5;
        -:  594:    case province:
    #####:  595:      return 8;
        -:  596:    case copper:
    #####:  597:      return 0;
        -:  598:    case silver:
    #####:  599:      return 3;
        -:  600:    case gold:
    #####:  601:      return 6;
        -:  602:    case adventurer:
    #####:  603:      return 6;
        -:  604:    case council_room:
    #####:  605:      return 5;
        -:  606:    case feast:
    #####:  607:      return 4;
        -:  608:    case gardens:
    #####:  609:      return 4;
        -:  610:    case mine:
    #####:  611:      return 5;
        -:  612:    case remodel:
    #####:  613:      return 4;
        -:  614:    case smithy:
    #####:  615:      return 4;
        -:  616:    case village:
    #####:  617:      return 3;
        -:  618:    case baron:
    #####:  619:      return 4;
        -:  620:    case great_hall:
    #####:  621:      return 3;
        -:  622:    case minion:
    #####:  623:      return 5;
        -:  624:    case steward:
    #####:  625:      return 3;
        -:  626:    case tribute:
    #####:  627:      return 5;
        -:  628:    case ambassador:
    #####:  629:      return 3;
        -:  630:    case cutpurse:
    #####:  631:      return 4;
        -:  632:    case embargo: 
    #####:  633:      return 2;
        -:  634:    case outpost:
    #####:  635:      return 5;
        -:  636:    case salvager:
    #####:  637:      return 4;
        -:  638:    case sea_hag:
    #####:  639:      return 4;
        -:  640:    case treasure_map:
    #####:  641:      return 4;
        -:  642:    }
        -:  643:	
    #####:  644:  return -1;
        -:  645:}
        -:  646:
        -:  647:
    #####:  648:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  649:{
        -:  650:  int i;
        -:  651:  int j;
        -:  652://  int k;
        -:  653:  int x;
        -:  654:  int index;
    #####:  655:  int currentPlayer = whoseTurn(state);
    #####:  656:  int nextPlayer = currentPlayer + 1;
        -:  657:
    #####:  658:  int tributeRevealedCards[2] = {-1, -1};
        -:  659:  int temphand[MAX_HAND];// moved above the if statement
    #####:  660:  int drawntreasure=0;
        -:  661:  int cardDrawn;
    #####:  662:  int z = 0;// this is the counter for the temp hand
    #####:  663:  if (nextPlayer > (state->numPlayers - 1)){
    #####:  664:    nextPlayer = 0;
        -:  665:  }
        -:  666:  
        -:  667:	
        -:  668:  //uses switch to select card and perform actions
    #####:  669:  switch( card ) 
        -:  670:    {
        -:  671:    case adventurer:
    #####:  672:	 return playAdventurer(state);
        -:  673:			
        -:  674:    case council_room:
    #####:  675:	  return playCouncil_Room(state, handPos);
        -:  676:			
        -:  677:    case feast:
        -:  678:      //gain card with cost up to 5
        -:  679:      //Backup hand
    #####:  680:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  681:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  682:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  683:      }
        -:  684:      //Backup hand
        -:  685:
        -:  686:      //Update Coins for Buy
    #####:  687:      updateCoins(currentPlayer, state, 5);
    #####:  688:      x = 1;//Condition to loop on
    #####:  689:      while( x == 1) {//Buy one card
    #####:  690:	if (supplyCount(choice1, state) <= 0){
        -:  691:	  if (DEBUG)
        -:  692:	    printf("None of that card left, sorry!\n");
        -:  693:
        -:  694:	  if (DEBUG){
        -:  695:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  696:	  }
        -:  697:	}
    #####:  698:	else if (state->coins < getCost(choice1)){
    #####:  699:	  printf("That card is too expensive!\n");
        -:  700:
        -:  701:	  if (DEBUG){
        -:  702:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  703:	  }
        -:  704:	}
        -:  705:	else{
        -:  706:
        -:  707:	  if (DEBUG){
        -:  708:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  709:	  }
        -:  710:
    #####:  711:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  712:	  x = 0;//No more buying cards
        -:  713:
        -:  714:	  if (DEBUG){
        -:  715:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  716:	  }
        -:  717:
        -:  718:	}
        -:  719:      }     
        -:  720:
        -:  721:      //Reset Hand
    #####:  722:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  723:	state->hand[currentPlayer][i] = temphand[i];
    #####:  724:	temphand[i] = -1;
        -:  725:      }
        -:  726:      //Reset Hand
        -:  727:      			
    #####:  728:      return 0;
        -:  729:			
        -:  730:    case gardens:
    #####:  731:      return -1;
        -:  732:			
        -:  733:    case mine:
    #####:  734:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  735:
    #####:  736:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  737:	{
    #####:  738:	  return -1;
        -:  739:	}
        -:  740:		
    #####:  741:      if (choice2 > treasure_map || choice2 < curse)
        -:  742:	{
    #####:  743:	  return -1;
        -:  744:	}
        -:  745:
    #####:  746:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
        -:  747:	{
    #####:  748:	  return -1;
        -:  749:	}
        -:  750:
    #####:  751:      gainCard(choice2, state, 2, currentPlayer);
        -:  752:
        -:  753:      //discard card from hand
    #####:  754:      discardCard(handPos, currentPlayer, state, 0);
        -:  755:
        -:  756:      //discard trashed card
    #####:  757:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  758:	{
    #####:  759:	  if (state->hand[currentPlayer][i] == j)
        -:  760:	    {
    #####:  761:	      discardCard(i, currentPlayer, state, 0);			
    #####:  762:	      break;
        -:  763:	    }
        -:  764:	}
        -:  765:			
    #####:  766:      return 0;
        -:  767:			
        -:  768:    case remodel:
    #####:  769:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  770:
    #####:  771:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  772:	{
    #####:  773:	  return -1;
        -:  774:	}
        -:  775:
    #####:  776:      gainCard(choice2, state, 0, currentPlayer);
        -:  777:
        -:  778:      //discard card from hand
    #####:  779:      discardCard(handPos, currentPlayer, state, 0);
        -:  780:
        -:  781:      //discard trashed card
    #####:  782:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  783:	{
    #####:  784:	  if (state->hand[currentPlayer][i] == j)
        -:  785:	    {
    #####:  786:	      discardCard(i, currentPlayer, state, 0);			
    #####:  787:	      break;
        -:  788:	    }
        -:  789:	}
        -:  790:
        -:  791:
    #####:  792:      return 0;
        -:  793:		
        -:  794:    case smithy:
    #####:  795:	  return playSmithy(state, handPos);
        -:  796:      /* //+3 Cards
        -:  797:      for (i = 0; i < 3; i++)
        -:  798:	  {
        -:  799:	    drawCard(currentPlayer, state);
        -:  800:	  }
        -:  801:			
        -:  802:      //discard card from hand
        -:  803:      discardCard(handPos, currentPlayer, state, 0);
        -:  804:      return 0; */
        -:  805:		
        -:  806:    case village:
    #####:  807:        return playVillage(state, handPos);
        -:  808:      /*
        -:  809:      //+1 Card
        -:  810:      drawCard(currentPlayer, state);
        -:  811:			
        -:  812:      //+2 Actions
        -:  813:      state->numActions = state->numActions + 2;
        -:  814:			
        -:  815:      //discard played card from hand
        -:  816:      discardCard(handPos, currentPlayer, state, 0);
        -:  817:      return 0;
        -:  818:       */	
        -:  819:    case baron:
    #####:  820:      state->numBuys++;//Increase buys by 1!
    #####:  821:      if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  822:	int p = 0;//Iterator for hand!
    #####:  823:	int card_not_discarded = 1;//Flag for discard set!
    #####:  824:	while(card_not_discarded){
    #####:  825:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
    #####:  826:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  827:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  828:	    state->discardCount[currentPlayer]++;
    #####:  829:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:  830:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  831:	    }
    #####:  832:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  833:	    state->handCount[currentPlayer]--;
    #####:  834:	    card_not_discarded = 0;//Exit the loop
        -:  835:	  }
    #####:  836:	  else if (p > state->handCount[currentPlayer]){
        -:  837:	    if(DEBUG) {
        -:  838:	      printf("No estate cards in your hand, invalid choice\n");
        -:  839:	      printf("Must gain an estate if there are any\n");
        -:  840:	    }
    #####:  841:	    if (supplyCount(estate, state) > 0){
    #####:  842:	      gainCard(estate, state, 0, currentPlayer);
    #####:  843:	      state->supplyCount[estate]--;//Decrement estates
    #####:  844:	      if (supplyCount(estate, state) == 0){
    #####:  845:		isGameOver(state);
        -:  846:	      }
        -:  847:	    }
    #####:  848:	    card_not_discarded = 0;//Exit the loop
        -:  849:	  }
        -:  850:			    
        -:  851:	  else{
    #####:  852:	    p++;//Next card
        -:  853:	  }
        -:  854:	}
        -:  855:      }
        -:  856:			    
        -:  857:      else{
    #####:  858:	if (supplyCount(estate, state) > 0){
    #####:  859:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  860:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  861:	  if (supplyCount(estate, state) == 0){
    #####:  862:	    isGameOver(state);
        -:  863:	  }
        -:  864:	}
        -:  865:      }
        -:  866:	    
        -:  867:      
    #####:  868:      return 0;
        -:  869:		
        -:  870:    case great_hall:
        -:  871:      //+1 Card
    #####:  872:      drawCard(currentPlayer, state);
        -:  873:			
        -:  874:      //+1 Actions
    #####:  875:      state->numActions++;
        -:  876:			
        -:  877:      //discard card from hand
    #####:  878:      discardCard(handPos, currentPlayer, state, 0);
    #####:  879:      return 0;
        -:  880:		
        -:  881:    case minion:
        -:  882:      //+1 action
    #####:  883:      state->numActions++;
        -:  884:			
        -:  885:      //discard card from hand
    #####:  886:      discardCard(handPos, currentPlayer, state, 0);
        -:  887:			
    #####:  888:      if (choice1)		//+2 coins
        -:  889:	{
    #####:  890:	  state->coins = state->coins + 2;
        -:  891:	}
        -:  892:			
    #####:  893:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  894:	{
        -:  895:	  //discard hand
    #####:  896:	  while(numHandCards(state) > 0)
        -:  897:	    {
    #####:  898:	      discardCard(handPos, currentPlayer, state, 0);
        -:  899:	    }
        -:  900:				
        -:  901:	  //draw 4
    #####:  902:	  for (i = 0; i < 4; i++)
        -:  903:	    {
    #####:  904:	      drawCard(currentPlayer, state);
        -:  905:	    }
        -:  906:				
        -:  907:	  //other players discard hand and redraw if hand size > 4
    #####:  908:	  for (i = 0; i < state->numPlayers; i++)
        -:  909:	    {
    #####:  910:	      if (i != currentPlayer)
        -:  911:		{
    #####:  912:		  if ( state->handCount[i] > 4 )
        -:  913:		    {
        -:  914:		      //discard hand
    #####:  915:		      while( state->handCount[i] > 0 )
        -:  916:			{
    #####:  917:			  discardCard(handPos, i, state, 0);
        -:  918:			}
        -:  919:							
        -:  920:		      //draw 4
    #####:  921:		      for (j = 0; j < 4; j++)
        -:  922:			{
    #####:  923:			  drawCard(i, state);
        -:  924:			}
        -:  925:		    }
        -:  926:		}
        -:  927:	    }
        -:  928:				
        -:  929:	}
    #####:  930:      return 0;
        -:  931:		
        -:  932:    case steward:
    #####:  933:	  return playSteward(state, handPos, choice1, choice2, choice3);
        -:  934:
        -:  935:		
        -:  936:    case tribute:
    #####:  937:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####:  938:	if (state->deckCount[nextPlayer] > 0){
    #####:  939:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  940:	  state->deckCount[nextPlayer]--;
        -:  941:	}
    #####:  942:	else if (state->discardCount[nextPlayer] > 0){
    #####:  943:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  944:	  state->discardCount[nextPlayer]--;
        -:  945:	}
        -:  946:	else{
        -:  947:	  //No Card to Reveal
        -:  948:	  if (DEBUG){
        -:  949:	    printf("No cards to reveal\n");
        -:  950:	  }
        -:  951:	}
        -:  952:      }
        -:  953:	    
        -:  954:      else{
    #####:  955:	if (state->deckCount[nextPlayer] == 0){
    #####:  956:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####:  957:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  958:	    state->deckCount[nextPlayer]++;
    #####:  959:	    state->discard[nextPlayer][i] = -1;
    #####:  960:	    state->discardCount[nextPlayer]--;
        -:  961:	  }
        -:  962:			    
    #####:  963:	  shuffle(nextPlayer,state);//Shuffle the deck
        -:  964:	} 
    #####:  965:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  966:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  967:	state->deckCount[nextPlayer]--;
    #####:  968:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  969:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  970:	state->deckCount[nextPlayer]--;
        -:  971:      }    
        -:  972:		       
    #####:  973:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####:  974:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  975:	state->playedCardCount++;
    #####:  976:	tributeRevealedCards[1] = -1;
        -:  977:      } 
        -:  978:
    #####:  979:      for (i = 0; i <= 2; i ++){
    #####:  980:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####:  981:	  state->coins += 2;
        -:  982:	}
        -:  983:		    
    #####:  984:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####:  985:	  drawCard(currentPlayer, state);
    #####:  986:	  drawCard(currentPlayer, state);
        -:  987:	}
        -:  988:	else{//Action Card
    #####:  989:	  state->numActions = state->numActions + 2;
        -:  990:	}
        -:  991:      }
        -:  992:	    
    #####:  993:      return 0;
        -:  994:		
        -:  995:    case ambassador:
    #####:  996:      j = 0;		//used to check if player has enough cards to discard
        -:  997:
    #####:  998:      if (choice2 > 2 || choice2 < 0)
        -:  999:	{
    #####: 1000:	  return -1;				
        -: 1001:	}
        -: 1002:
    #####: 1003:      if (choice1 == handPos)
        -: 1004:	{
    #####: 1005:	  return -1;
        -: 1006:	}
        -: 1007:
    #####: 1008:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1009:	{
    #####: 1010:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1011:	    {
    #####: 1012:	      j++;
        -: 1013:	    }
        -: 1014:	}
    #####: 1015:      if (j < choice2)
        -: 1016:	{
    #####: 1017:	  return -1;				
        -: 1018:	}
        -: 1019:
        -: 1020:      if (DEBUG) 
        -: 1021:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1022:
        -: 1023:      //increase supply count for choosen card by amount being discarded
    #####: 1024:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1025:			
        -: 1026:      //each other player gains a copy of revealed card
    #####: 1027:      for (i = 0; i < state->numPlayers; i++)
        -: 1028:	{
    #####: 1029:	  if (i != currentPlayer)
        -: 1030:	    {
    #####: 1031:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1032:	    }
        -: 1033:	}
        -: 1034:
        -: 1035:      //discard played card from hand
    #####: 1036:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1037:
        -: 1038:      //trash copies of cards returned to supply
    #####: 1039:      for (j = 0; j < choice2; j++)
        -: 1040:	{
    #####: 1041:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1042:	    {
    #####: 1043:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1044:		{
    #####: 1045:		  discardCard(i, currentPlayer, state, 1);
    #####: 1046:		  break;
        -: 1047:		}
        -: 1048:	    }
        -: 1049:	}			
        -: 1050:
    #####: 1051:      return 0;
        -: 1052:		
        -: 1053:    case cutpurse:
        -: 1054:
        -: 1055:/*       updateCoins(currentPlayer, state, 2);
        -: 1056:      for (i = 0; i < state->numPlayers; i++)
        -: 1057:	{
        -: 1058:	  if (i != currentPlayer)
        -: 1059:	    {
        -: 1060:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1061:		{
        -: 1062:		  if (state->hand[i][j] == copper)
        -: 1063:		    {
        -: 1064:		      discardCard(j, i, state, 0);
        -: 1065:		      break;
        -: 1066:		    }
        -: 1067:		  if (j == state->handCount[i])
        -: 1068:		    {
        -: 1069:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1070:			{
        -: 1071:			  if (DEBUG)
        -: 1072:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1073:			}	
        -: 1074:		      break;
        -: 1075:		    }		
        -: 1076:		}
        -: 1077:					
        -: 1078:	    }
        -: 1079:				
        -: 1080:	}				
        -: 1081:
        -: 1082:      //discard played card from hand
        -: 1083:      discardCard(handPos, currentPlayer, state, 0); */			
        -: 1084:
    #####: 1085:      return playCutpurse(state, handPos);
        -: 1086:
        -: 1087:		
        -: 1088:    case embargo: 
        -: 1089:      //+2 Coins
    #####: 1090:      state->coins = state->coins + 2;
        -: 1091:			
        -: 1092:      //see if selected pile is in play
    #####: 1093:      if ( state->supplyCount[choice1] == -1 )
        -: 1094:	{
    #####: 1095:	  return -1;
        -: 1096:	}
        -: 1097:			
        -: 1098:      //add embargo token to selected supply pile
    #####: 1099:      state->embargoTokens[choice1]++;
        -: 1100:			
        -: 1101:      //trash card
    #####: 1102:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1103:      return 0;
        -: 1104:		
        -: 1105:    case outpost:
        -: 1106:      //set outpost flag
    #####: 1107:      state->outpostPlayed++;
        -: 1108:			
        -: 1109:      //discard card
    #####: 1110:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1111:      return 0;
        -: 1112:		
        -: 1113:    case salvager:
        -: 1114:      //+1 buy
    #####: 1115:      state->numBuys++;
        -: 1116:			
    #####: 1117:      if (choice1)
        -: 1118:	{
        -: 1119:	  //gain coins equal to trashed card
    #####: 1120:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1121:	  //trash card
    #####: 1122:	  discardCard(choice1, currentPlayer, state, 1);	
        -: 1123:	}
        -: 1124:			
        -: 1125:      //discard card
    #####: 1126:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1127:      return 0;
        -: 1128:		
        -: 1129:    case sea_hag:
    #####: 1130:      for (i = 0; i < state->numPlayers; i++){
    #####: 1131:	if (i != currentPlayer){
    #####: 1132:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1133:	  state->discardCount[i]++;
    #####: 1134:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1135:	}
        -: 1136:      }
    #####: 1137:      return 0;
        -: 1138:		
        -: 1139:    case treasure_map:
        -: 1140:      //search hand for another treasure_map
    #####: 1141:      index = -1;
    #####: 1142:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1143:	{
    #####: 1144:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1145:	    {
    #####: 1146:	      index = i;
    #####: 1147:	      break;
        -: 1148:	    }
        -: 1149:	}
    #####: 1150:      if (index > -1)
        -: 1151:	{
        -: 1152:	  //trash both treasure cards
    #####: 1153:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1154:	  discardCard(index, currentPlayer, state, 1);
        -: 1155:
        -: 1156:	  //gain 4 Gold cards
    #####: 1157:	  for (i = 0; i < 4; i++)
        -: 1158:	    {
    #####: 1159:	      gainCard(gold, state, 1, currentPlayer);
        -: 1160:	    }
        -: 1161:				
        -: 1162:	  //return success
    #####: 1163:	  return 1;
        -: 1164:	}
        -: 1165:			
        -: 1166:      //no second treasure_map found in hand
    #####: 1167:      return -1;
        -: 1168:    }
        -: 1169:	
    #####: 1170:  return -1;
        -: 1171:}
        -: 1172:
    #####: 1173:int playAdventurer(struct gameState *state){
    #####: 1174:	int drawntreasure = 0;
        -: 1175:	int cardDrawn;
    #####: 1176:	int currentPlayer = whoseTurn(state);
        -: 1177:    int temphand[MAX_HAND];// moved above the if statement
    #####: 1178:    int z = 0;// this is the counter for the temp hand
        -: 1179:
        -: 1180:	
    #####: 1181:	while(drawntreasure<3){
    #####: 1182:		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
    #####: 1183:		  shuffle(currentPlayer, state);
        -: 1184:		}
    #####: 1185:		drawCard(currentPlayer, state);
    #####: 1186:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####: 1187:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####: 1188:		  drawntreasure++;
        -: 1189:		else{
    #####: 1190:		  temphand[z]=cardDrawn;
    #####: 1191:		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####: 1192:		  z++;
        -: 1193:		}
        -: 1194:	  }
    #####: 1195:	  while(z-1>=0){
    #####: 1196:		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####: 1197:	   z=z-1;
        -: 1198:	  }
        -: 1199:	  
    #####: 1200:	return 0;
        -: 1201:}
        -: 1202:
        -: 1203://Add 4 cards
    #####: 1204:int playCouncil_Room(struct gameState *state, int handPos){
    #####: 1205:	int currentPlayer = whoseTurn(state);
        -: 1206:	int i;
        -: 1207:  
    #####: 1208:    for (i = 0; i < 5; i++)
        -: 1209:	{
    #####: 1210:	  drawCard(currentPlayer, state);
        -: 1211:	}
        -: 1212:			
        -: 1213:    //+1 Buy
    #####: 1214:    state->numBuys++;
        -: 1215:			
        -: 1216:    //Each other player draws a card
    #####: 1217:    for (i = 0; i < state->numPlayers; i++)
        -: 1218:	{
    #####: 1219:	  if ( i != currentPlayer )
        -: 1220:	  {
    #####: 1221:	    drawCard(i, state);
        -: 1222:	  }
        -: 1223:	}
        -: 1224:			
        -: 1225:    //put played card in played card pile
    #####: 1226:    discardCard(handPos, currentPlayer, state, 0);
    #####: 1227:	return 0;
        -: 1228:}
        -: 1229:
    #####: 1230:int playSmithy(struct gameState *state, int handPos){
        -: 1231:    int i;
    #####: 1232:    int currentPlayer = whoseTurn(state);
        -: 1233:
        -: 1234:    //+3 Cards
    #####: 1235:    for (i = 0; i < 3; i++)
        -: 1236:    {
    #####: 1237:      drawCard(currentPlayer, state);
        -: 1238:    }
        -: 1239:    	
        -: 1240:    //discard card from hand
    #####: 1241:    discardCard(handPos, currentPlayer, state, 0-1);
    #####: 1242:    return 0;
        -: 1243:}
        -: 1244:
    #####: 1245:int playCutpurse(struct gameState *state, int handPos){
        -: 1246:	int i, j, k;
    #####: 1247:	int currentPlayer = whoseTurn(state);
        -: 1248:
        -: 1249:	
    #####: 1250:    updateCoins(currentPlayer, state, 2);
    #####: 1251:    for (i = 0; i < state->numPlayers; i++)
        -: 1252:	{
    #####: 1253:	  if (i != currentPlayer)
        -: 1254:	  {
    #####: 1255:	    for (j = 0; j <= state->handCount[i]; j++){
    #####: 1256:          if (state->hand[i][j] == copper){
    #####: 1257:	        discardCard(j, i, state, 0);
    #####: 1258:		    return -1;
        -: 1259:	      }
    #####: 1260:	      if (j = state->handCount[i]){
    #####: 1261:            for (k = 0; k < state->handCount[i]; k++){
        -: 1262:		      if (DEBUG)
        -: 1263:                printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1264:            }	
    #####: 1265:		  return -1;
        -: 1266:          }		
        -: 1267:		}
        -: 1268:					
        -: 1269:	  }//end != currentPlayer switch		
        -: 1270:	}
        -: 1271:
        -: 1272:    //discard played card from hand
    #####: 1273:	discardCard(handPos, currentPlayer, state, 0);
        -: 1274:	
    #####: 1275:	return 0;
        -: 1276:}
        -: 1277:
    #####: 1278:int playSteward(struct gameState *state, int handPos, int choice1, int choice2, int choice3){
    #####: 1279:  int currentPlayer = whoseTurn(state);
        -: 1280:
    #####: 1281:  if (choice1 == 1) {
        -: 1282:  //+2 cards
    #####: 1283:    drawCard(currentPlayer, state);
    #####: 1284:    drawCard(currentPlayer, state);
        -: 1285:  }
    #####: 1286:  else if (choice1 == 2) {
        -: 1287:  //+2 coins
    #####: 1288:    state->coins = state->coins + 2;
        -: 1289:  }
        -: 1290:  else {
        -: 1291:  //trash 2 cards in hand
    #####: 1292:    discardCard(choice2, currentPlayer, state, 1);
    #####: 1293:    discardCard(choice3, currentPlayer, state, 1);
        -: 1294:  }
        -: 1295:	
        -: 1296:  //discard card from hand
    #####: 1297:  discardCard(handPos, currentPlayer, state, 0);
    #####: 1298:  return 0;
        -: 1299:}
        -: 1300:
    #####: 1301:int playVillage(struct gameState *state, int handPos){
    #####: 1302:    int currentPlayer = whoseTurn(state);
        -: 1303:
        -: 1304:    //+1 Card
    #####: 1305:     drawCard(currentPlayer, state);
        -: 1306:
        -: 1307:     //+2 Actions
    #####: 1308:     state->numActions = state->numActions + 2;
        -: 1309:
        -: 1310:     //discard played card from hand
    #####: 1311:     discardCard(handPos, currentPlayer, state, 0);
    #####: 1312:     return 0;
        -: 1313:}
        -: 1314:
    #####: 1315:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1316:{
        -: 1317:	
        -: 1318:  //if card is not trashed, added to Played pile 
    #####: 1319:  if (trashFlag < 1)
        -: 1320:    {
        -: 1321:      //add card to played pile
    #####: 1322:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1323:      state->playedCardCount++;
        -: 1324:    }
        -: 1325:	
        -: 1326:  //set played card to -1
    #####: 1327:  state->hand[currentPlayer][handPos] = -1;
        -: 1328:	
        -: 1329:  //remove card from player's hand
    #####: 1330:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1331:    {
        -: 1332:      //reduce number of cards in hand
    #####: 1333:      state->handCount[currentPlayer]--;
        -: 1334:    }
    #####: 1335:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1336:    {
        -: 1337:      //reduce number of cards in hand
    #####: 1338:      state->handCount[currentPlayer]--;
        -: 1339:    }
        -: 1340:  else 	
        -: 1341:    {
        -: 1342:      //replace discarded card with last card in hand
    #####: 1343:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1344:      //set last card to -1
    #####: 1345:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1346:      //reduce number of cards in hand
    #####: 1347:      state->handCount[currentPlayer]--;
        -: 1348:    }
        -: 1349:	
    #####: 1350:  return 0;
        -: 1351:}
        -: 1352:
    #####: 1353:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1354:{
        -: 1355:  //Note: supplyPos is enum of choosen card
        -: 1356:	
        -: 1357:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1358:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1359:    {
    #####: 1360:      return -1;
        -: 1361:    }
        -: 1362:	
        -: 1363:  //added card for [whoseTurn] current player:
        -: 1364:  // toFlag = 0 : add to discard
        -: 1365:  // toFlag = 1 : add to deck
        -: 1366:  // toFlag = 2 : add to hand
        -: 1367:
    #####: 1368:  if (toFlag == 1)
        -: 1369:    {
    #####: 1370:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1371:      state->deckCount[player]++;
        -: 1372:    }
    #####: 1373:  else if (toFlag == 2)
        -: 1374:    {
    #####: 1375:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1376:      state->handCount[player]++;
        -: 1377:    }
        -: 1378:  else
        -: 1379:    {
    #####: 1380:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1381:      state->discardCount[player]++;
        -: 1382:    }
        -: 1383:	
        -: 1384:  //decrease number in supply pile
    #####: 1385:  state->supplyCount[supplyPos]--;
        -: 1386:	 
    #####: 1387:  return 0;
        -: 1388:}
        -: 1389:
      405: 1390:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1391:{
        -: 1392:  int i;
        -: 1393:	
        -: 1394:  //reset coin count
      405: 1395:  state->coins = 0;
        -: 1396:
        -: 1397:  //add coins for each Treasure card in player's hand
     1925: 1398:  for (i = 0; i < state->handCount[player]; i++)
        -: 1399:    {
     1520: 1400:      if (state->hand[player][i] == copper)
        -: 1401:	{
      516: 1402:	  state->coins += 1;
        -: 1403:	}
     1004: 1404:      else if (state->hand[player][i] == silver)
        -: 1405:	{
      500: 1406:	  state->coins += 2;
        -: 1407:	}
      504: 1408:      else if (state->hand[player][i] == gold)
        -: 1409:	{
      500: 1410:	  state->coins += 3;
        -: 1411:	}	
        -: 1412:    }	
        -: 1413:
        -: 1414:  //add bonus
      405: 1415:  state->coins += bonus;
        -: 1416:
      405: 1417:  return 0;
        -: 1418:}
        -: 1419:
        -: 1420:
        -: 1421://end of dominion.c
        -: 1422:
Handcount p0: 5 
Handcount p1: 0 
Handcount p2: 0 
Handcount p3: 0 

Testing getCost() with seed 1234
Game Initialized! :)
__ALL TESTS PASSED!__

File 'dominion.c'
Lines executed:22.71% of 568
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:5
        -:    0:Programs:3
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
      180:    8:int compare(const void* a, const void* b) {
      180:    9:  if (*(int*)a > *(int*)b)
    #####:   10:    return 1;
      180:   11:  if (*(int*)a < *(int*)b)
       48:   12:    return -1;
      132:   13:  return 0;
        -:   14:}
        -:   15:
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
        -:   21:
    #####:   22:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   23:		  int k8, int k9, int k10) {
    #####:   24:  int* k = malloc(10 * sizeof(int));
    #####:   25:  k[0] = k1;
    #####:   26:  k[1] = k2;
    #####:   27:  k[2] = k3;
    #####:   28:  k[3] = k4;
    #####:   29:  k[4] = k5;
    #####:   30:  k[5] = k6;
    #####:   31:  k[6] = k7;
    #####:   32:  k[7] = k8;
    #####:   33:  k[8] = k9;
    #####:   34:  k[9] = k10;
    #####:   35:  return k;
        -:   36:}
        -:   37:
        5:   38:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   39:		   struct gameState *state) {
        -:   40:
        -:   41:  int i;
        -:   42:  int j;
        -:   43:  int it;			
        -:   44:  //set up random number generator
        5:   45:  SelectStream(1);
        5:   46:  PutSeed((long)randomSeed);
        -:   47:  
        -:   48:  //check number of players
        5:   49:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   50:    {
    #####:   51:      return -1;
        -:   52:    }
        -:   53:
        -:   54:  //set number of players
        5:   55:  state->numPlayers = numPlayers;
        -:   56:
        -:   57:  //check selected kingdom cards are different
       55:   58:  for (i = 0; i < 10; i++)
        -:   59:    {
      550:   60:      for (j = 0; j < 10; j++)
        -:   61:        {
      500:   62:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   63:	    {
    #####:   64:	      return -1;
        -:   65:	    }
        -:   66:        }
        -:   67:    }
        -:   68:
        -:   69:
        -:   70:  //initialize supply
        -:   71:  ///////////////////////////////
        -:   72:
        -:   73:  //set number of Curse cards
        5:   74:  if (numPlayers == 2)
        -:   75:    {
        4:   76:      state->supplyCount[curse] = 10;
        -:   77:    }
        1:   78:  else if (numPlayers == 3)
        -:   79:    {
    #####:   80:      state->supplyCount[curse] = 20;
        -:   81:    }
        -:   82:  else
        -:   83:    {
        1:   84:      state->supplyCount[curse] = 30;
        -:   85:    }
        -:   86:
        -:   87:  //set number of Victory cards
        5:   88:  if (numPlayers == 2)
        -:   89:    {
        4:   90:      state->supplyCount[estate] = 8;
        4:   91:      state->supplyCount[duchy] = 8;
        4:   92:      state->supplyCount[province] = 8;
        -:   93:    }
        -:   94:  else
        -:   95:    {
        1:   96:      state->supplyCount[estate] = 12;
        1:   97:      state->supplyCount[duchy] = 12;
        1:   98:      state->supplyCount[province] = 12;
        -:   99:    }
        -:  100:
        -:  101:  //set number of Treasure cards
        5:  102:  state->supplyCount[copper] = 60 - (7 * numPlayers);
        5:  103:  state->supplyCount[silver] = 40;
        5:  104:  state->supplyCount[gold] = 30;
        -:  105:
        -:  106:  //set number of Kingdom cards
      105:  107:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  108:    {
      825:  109:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  110:	{
      775:  111:	  if (kingdomCards[j] == i)
        -:  112:	    {
        -:  113:	      //check if card is a 'Victory' Kingdom card
       50:  114:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  115:		{
       10:  116:		  if (numPlayers == 2){ 
        4:  117:		    state->supplyCount[i] = 8; 
        -:  118:		  }
        1:  119:		  else{ state->supplyCount[i] = 12; }
        -:  120:		}
        -:  121:	      else
        -:  122:		{
       45:  123:		  state->supplyCount[i] = 10;
        -:  124:		}
       50:  125:	      break;
        -:  126:	    }
        -:  127:	  else    //card is not in the set choosen for the game
        -:  128:	    {
      725:  129:	      state->supplyCount[i] = -1;
        -:  130:	    }
        -:  131:	}
        -:  132:
        -:  133:    }
        -:  134:
        -:  135:  ////////////////////////
        -:  136:  //supply intilization complete
        -:  137:
        -:  138:  //set player decks
       17:  139:  for (i = 0; i < numPlayers; i++)
        -:  140:    {
       12:  141:      state->deckCount[i] = 0;
       48:  142:      for (j = 0; j < 3; j++)
        -:  143:	{
       36:  144:	  state->deck[i][j] = estate;
       36:  145:	  state->deckCount[i]++;
        -:  146:	}
       96:  147:      for (j = 3; j < 10; j++)
        -:  148:	{
       84:  149:	  state->deck[i][j] = copper;
       84:  150:	  state->deckCount[i]++;		
        -:  151:	}
        -:  152:    }
        -:  153:
        -:  154:  //shuffle player decks
       17:  155:  for (i = 0; i < numPlayers; i++)
        -:  156:    {
       12:  157:      if ( shuffle(i, state) < 0 )
        -:  158:	{
    #####:  159:	  return -1;
        -:  160:	}
        -:  161:    }
        -:  162:
        -:  163:  //draw player hands
       17:  164:  for (i = 0; i < numPlayers; i++)
        -:  165:    {  
        -:  166:      //initialize hand size to zero
       12:  167:      state->handCount[i] = 0;
       12:  168:      state->discardCount[i] = 0;
        -:  169:      //draw 5 cards
        -:  170:      // for (j = 0; j < 5; j++)
        -:  171:      //	{
        -:  172:      //	  drawCard(i, state);
        -:  173:      //	}
        -:  174:    }
        -:  175:  
        -:  176:  //set embargo tokens to 0 for all supply piles
      140:  177:  for (i = 0; i <= treasure_map; i++)
        -:  178:    {
      135:  179:      state->embargoTokens[i] = 0;
        -:  180:    }
        -:  181:
        -:  182:  //initialize first player's turn
        5:  183:  state->outpostPlayed = 0;
        5:  184:  state->phase = 0;
        5:  185:  state->numActions = 1;
        5:  186:  state->numBuys = 1;
        5:  187:  state->playedCardCount = 0;
        5:  188:  state->whoseTurn = 0;
        5:  189:  state->handCount[state->whoseTurn] = 0;
        -:  190:  //int it; move to top
        -:  191:
        -:  192:  //Moved draw cards to here, only drawing at the start of a turn
       30:  193:  for (it = 0; it < 5; it++){
       25:  194:    drawCard(state->whoseTurn, state);
        -:  195:  }
        -:  196:
        5:  197:  updateCoins(state->whoseTurn, state, 0);
        -:  198:
        5:  199:  return 0;
        -:  200:}
        -:  201:
       12:  202:int shuffle(int player, struct gameState *state) {
        -:  203: 
        -:  204:
        -:  205:  int newDeck[MAX_DECK];
       12:  206:  int newDeckPos = 0;
        -:  207:  int card;
        -:  208:  int i;
        -:  209:
       12:  210:  if (state->deckCount[player] < 1)
    #####:  211:    return -1;
       12:  212:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  213:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  214:
      144:  215:  while (state->deckCount[player] > 0) {
      120:  216:    card = floor(Random() * state->deckCount[player]);
      120:  217:    newDeck[newDeckPos] = state->deck[player][card];
      120:  218:    newDeckPos++;
      439:  219:    for (i = card; i < state->deckCount[player]-1; i++) {
      319:  220:      state->deck[player][i] = state->deck[player][i+1];
        -:  221:    }
      120:  222:    state->deckCount[player]--;
        -:  223:  }
      132:  224:  for (i = 0; i < newDeckPos; i++) {
      120:  225:    state->deck[player][i] = newDeck[i];
      120:  226:    state->deckCount[player]++;
        -:  227:  }
        -:  228:
       12:  229:  return 0;
        -:  230:}
        -:  231:
    #####:  232:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  233:{	
        -:  234:  int card;
    #####:  235:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  236:
        -:  237:  //check if it is the right phase
    #####:  238:  if (state->phase != 0)
        -:  239:    {
    #####:  240:      return -1;
        -:  241:    }
        -:  242:	
        -:  243:  //check if player has enough actions
    #####:  244:  if ( state->numActions < 1 )
        -:  245:    {
    #####:  246:      return -1;
        -:  247:    }
        -:  248:	
        -:  249:  //get card played
    #####:  250:  card = handCard(handPos, state);
        -:  251:	
        -:  252:  //check if selected card is an action
    #####:  253:  if ( card < adventurer || card > treasure_map )
        -:  254:    {
    #####:  255:      return -1;
        -:  256:    }
        -:  257:	
        -:  258:  //play card
    #####:  259:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  260:    {
    #####:  261:      return -1;
        -:  262:    }
        -:  263:	
        -:  264:  //reduce number of actions
    #####:  265:  state->numActions--;
        -:  266:
        -:  267:  //update coins (Treasure cards may be added with card draws)
    #####:  268:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  269:	
    #####:  270:  return 0;
        -:  271:}
        -:  272:
    #####:  273:int buyCard(int supplyPos, struct gameState *state) {
        -:  274:  int who;
        -:  275:  if (DEBUG){
        -:  276:    printf("Entering buyCard...\n");
        -:  277:  }
        -:  278:
        -:  279:  // I don't know what to do about the phase thing.
        -:  280:
    #####:  281:  who = state->whoseTurn;
        -:  282:
    #####:  283:  if (state->numBuys < 1){
        -:  284:    if (DEBUG)
        -:  285:      printf("You do not have any buys left\n");
    #####:  286:    return -1;
    #####:  287:  } else if (supplyCount(supplyPos, state) <1){
        -:  288:    if (DEBUG)
        -:  289:      printf("There are not any of that type of card left\n");
    #####:  290:    return -1;
    #####:  291:  } else if (state->coins < getCost(supplyPos)){
        -:  292:    if (DEBUG) 
        -:  293:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  294:    return -1;
        -:  295:  } else {
    #####:  296:    state->phase=1;
        -:  297:    //state->supplyCount[supplyPos]--;
    #####:  298:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  299:  
    #####:  300:    state->coins = (state->coins) - (getCost(supplyPos));
    #####:  301:    state->numBuys--;
        -:  302:    if (DEBUG)
        -:  303:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  304:  }
        -:  305:
        -:  306:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  307:  //state->discardCount[who]++;
        -:  308:    
    #####:  309:  return 0;
        -:  310:}
        -:  311:
    #####:  312:int numHandCards(struct gameState *state) {
    #####:  313:  return state->handCount[ whoseTurn(state) ];
        -:  314:}
        -:  315:
    #####:  316:int handCard(int handPos, struct gameState *state) {
    #####:  317:  int currentPlayer = whoseTurn(state);
    #####:  318:  return state->hand[currentPlayer][handPos];
        -:  319:}
        -:  320:
    #####:  321:int supplyCount(int card, struct gameState *state) {
    #####:  322:  return state->supplyCount[card];
        -:  323:}
        -:  324:
    #####:  325:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  326:  int i;
    #####:  327:  int count = 0;
        -:  328:
    #####:  329:  for (i = 0; i < state->deckCount[player]; i++)
        -:  330:    {
    #####:  331:      if (state->deck[player][i] == card) count++;
        -:  332:    }
        -:  333:
    #####:  334:  for (i = 0; i < state->handCount[player]; i++)
        -:  335:    {
    #####:  336:      if (state->hand[player][i] == card) count++;
        -:  337:    }
        -:  338:
    #####:  339:  for (i = 0; i < state->discardCount[player]; i++)
        -:  340:    {
    #####:  341:      if (state->discard[player][i] == card) count++;
        -:  342:    }
        -:  343:
    #####:  344:  return count;
        -:  345:}
        -:  346:
       12:  347:int whoseTurn(struct gameState *state) {
       12:  348:  return state->whoseTurn;
        -:  349:}
        -:  350:
    #####:  351:int endTurn(struct gameState *state) {
        -:  352:  int k;
        -:  353:  int i;
    #####:  354:  int currentPlayer = whoseTurn(state);
        -:  355:  
        -:  356:  //Discard hand
    #####:  357:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  358:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  359:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  360:  }
    #####:  361:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  362:    
        -:  363:  //Code for determining the player
    #####:  364:  if (currentPlayer < (state->numPlayers - 1)){ 
    #####:  365:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  366:  }
        -:  367:  else{
    #####:  368:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  369:  }
        -:  370:
    #####:  371:  state->outpostPlayed = 0;
    #####:  372:  state->phase = 0;
    #####:  373:  state->numActions = 1;
    #####:  374:  state->coins = 0;
    #####:  375:  state->numBuys = 1;
    #####:  376:  state->playedCardCount = 0;
    #####:  377:  state->handCount[state->whoseTurn] = 0;
        -:  378:
        -:  379:  //int k; move to top
        -:  380:  //Next player draws hand
    #####:  381:  for (k = 0; k < 5; k++){
    #####:  382:    drawCard(state->whoseTurn, state);//Draw a card
        -:  383:  }
        -:  384:
        -:  385:  //Update money
    #####:  386:  updateCoins(state->whoseTurn, state , 0);
        -:  387:
    #####:  388:  return 0;
        -:  389:}
        -:  390:
    #####:  391:int isGameOver(struct gameState *state) {
        -:  392:  int i;
        -:  393:  int j;
        -:  394:	
        -:  395:  //if stack of Province cards is empty, the game ends
    #####:  396:  if (state->supplyCount[province] == 0)
        -:  397:    {
    #####:  398:      return 1;
        -:  399:    }
        -:  400:
        -:  401:  //if three supply pile are at 0, the game ends
    #####:  402:    j = 0;
    #####:  403:    for (i = 0; i < 25; i++)
        -:  404:    {
    #####:  405:      if (state->supplyCount[i] == 0)
        -:  406:        {
    #####:  407:          j++;
        -:  408:        }
        -:  409:    }
    #####:  410:    if ( j >= 3)
        -:  411:    {
    #####:  412:      return 1;
        -:  413:    }
        -:  414:
    #####:  415:  return 0;
        -:  416:}
        -:  417:
    #####:  418:int scoreFor (int player, struct gameState *state) {
        -:  419:
        -:  420:  int i;
    #####:  421:  int score = 0;
        -:  422:  //score from hand
    #####:  423:  for (i = 0; i < state->handCount[player]; i++)
        -:  424:    {
    #####:  425:      if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  426:      if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  427:      if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  428:      if (state->hand[player][i] == province) { score = score + 6; };
    #####:  429:      if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  430:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  431:    }
        -:  432:
        -:  433:  //score from discard
    #####:  434:  for (i = 0; i < state->discardCount[player]; i++)
        -:  435:    {
    #####:  436:      if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  437:      if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  438:      if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  439:      if (state->discard[player][i] == province) { score = score + 6; };
    #####:  440:      if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  441:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  442:    }
        -:  443:
        -:  444:  //score from deck
    #####:  445:  for (i = 0; i < state->discardCount[player]; i++)
        -:  446:    {
    #####:  447:      if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  448:      if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  449:      if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  450:      if (state->deck[player][i] == province) { score = score + 6; };
    #####:  451:      if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  452:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  453:    }
        -:  454:
    #####:  455:  return score;
        -:  456:}
        -:  457:
    #####:  458:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  459:  int i;	
        -:  460:  int j;
        -:  461:  int highScore;
        -:  462:  int currentPlayer;
        -:  463:
        -:  464:  //get score for each player
    #####:  465:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  466:    {
        -:  467:      //set unused player scores to -9999
    #####:  468:      if (i >= state->numPlayers)
        -:  469:	{
    #####:  470:	  players[i] = -9999;
        -:  471:	}
        -:  472:      else
        -:  473:	{
    #####:  474:	  players[i] = scoreFor (i, state);
        -:  475:	}
        -:  476:    }
        -:  477:
        -:  478:  //find highest score
    #####:  479:  j = 0;
    #####:  480:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  481:    {
    #####:  482:      if (players[i] > players[j])
        -:  483:	{
    #####:  484:	  j = i;
        -:  485:	}
        -:  486:    }
    #####:  487:  highScore = players[j];
        -:  488:
        -:  489:  //add 1 to players who had less turns
    #####:  490:  currentPlayer = whoseTurn(state);
    #####:  491:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  492:    {
    #####:  493:      if ( players[i] == highScore && i > currentPlayer )
        -:  494:	{
    #####:  495:	  players[i]++;
        -:  496:	}
        -:  497:    }
        -:  498:
        -:  499:  //find new highest score
    #####:  500:  j = 0;
    #####:  501:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  502:    {
    #####:  503:      if ( players[i] > players[j] )
        -:  504:	{
    #####:  505:	  j = i;
        -:  506:	}
        -:  507:    }
    #####:  508:  highScore = players[j];
        -:  509:
        -:  510:  //set winners in array to 1 and rest to 0
    #####:  511:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  512:    {
    #####:  513:      if ( players[i] == highScore )
        -:  514:	{
    #####:  515:	  players[i] = 1;
        -:  516:	}
        -:  517:      else
        -:  518:	{
    #####:  519:	  players[i] = 0;
        -:  520:	}
        -:  521:    }
        -:  522:
    #####:  523:  return 0;
        -:  524:}
        -:  525:
       25:  526:int drawCard(int player, struct gameState *state)
        -:  527:{	int count;
        -:  528:  int deckCounter;
       25:  529:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  530:    
        -:  531:    //Step 1 Shuffle the discard pile back into a deck
        -:  532:    int i;
        -:  533:    //Move discard to deck
    #####:  534:    for (i = 0; i < state->discardCount[player];i++){
    #####:  535:      state->deck[player][i] = state->discard[player][i];
    #####:  536:      state->discard[player][i] = -1;
        -:  537:    }
        -:  538:
    #####:  539:    state->deckCount[player] = state->discardCount[player];
    #####:  540:    state->discardCount[player] = 0;//Reset discard
        -:  541:
        -:  542:    //Shufffle the deck
    #####:  543:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  544:   
        -:  545:    if (DEBUG){//Debug statements
        -:  546:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  547:    }
        -:  548:    
    #####:  549:    state->discardCount[player] = 0;
        -:  550:
        -:  551:    //Step 2 Draw Card
    #####:  552:    count = state->handCount[player];//Get current player's hand count
        -:  553:    
        -:  554:    if (DEBUG){//Debug statements
        -:  555:      printf("Current hand count: %d\n", count);
        -:  556:    }
        -:  557:    
    #####:  558:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  559:
    #####:  560:    if (deckCounter == 0)
    #####:  561:      return -1;
        -:  562:
    #####:  563:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  564:    state->deckCount[player]--;
    #####:  565:    state->handCount[player]++;//Increment hand count
        -:  566:  }
        -:  567:
        -:  568:  else{
       25:  569:    int count = state->handCount[player];//Get current hand count for player
        -:  570:    int deckCounter;
        -:  571:    if (DEBUG){//Debug statements
        -:  572:      printf("Current hand count: %d\n", count);
        -:  573:    }
        -:  574:
       25:  575:    deckCounter = state->deckCount[player];//Create holder for the deck count
       25:  576:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
       25:  577:    state->deckCount[player]--;
       25:  578:    state->handCount[player]++;//Increment hand count
        -:  579:  }
        -:  580:
       25:  581:  return 0;
        -:  582:}
        -:  583:
       28:  584:int getCost(int cardNumber)
        -:  585:{
       28:  586:  switch( cardNumber ) 
        -:  587:    {
        -:  588:    case curse:
        1:  589:      return 0;
        -:  590:    case estate:
        1:  591:      return 2;
        -:  592:    case duchy:
        1:  593:      return 5;
        -:  594:    case province:
        1:  595:      return 8;
        -:  596:    case copper:
        1:  597:      return 0;
        -:  598:    case silver:
        1:  599:      return 3;
        -:  600:    case gold:
        1:  601:      return 6;
        -:  602:    case adventurer:
        1:  603:      return 6;
        -:  604:    case council_room:
        1:  605:      return 5;
        -:  606:    case feast:
        1:  607:      return 4;
        -:  608:    case gardens:
        1:  609:      return 4;
        -:  610:    case mine:
        1:  611:      return 5;
        -:  612:    case remodel:
        1:  613:      return 4;
        -:  614:    case smithy:
        1:  615:      return 4;
        -:  616:    case village:
        1:  617:      return 3;
        -:  618:    case baron:
        1:  619:      return 4;
        -:  620:    case great_hall:
        1:  621:      return 3;
        -:  622:    case minion:
        1:  623:      return 5;
        -:  624:    case steward:
        1:  625:      return 3;
        -:  626:    case tribute:
        1:  627:      return 5;
        -:  628:    case ambassador:
        1:  629:      return 3;
        -:  630:    case cutpurse:
        1:  631:      return 4;
        -:  632:    case embargo: 
        1:  633:      return 2;
        -:  634:    case outpost:
        1:  635:      return 5;
        -:  636:    case salvager:
        1:  637:      return 4;
        -:  638:    case sea_hag:
        1:  639:      return 4;
        -:  640:    case treasure_map:
        1:  641:      return 4;
        -:  642:    }
        -:  643:	
        1:  644:  return -1;
        -:  645:}
        -:  646:
        -:  647:
    #####:  648:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  649:{
        -:  650:  int i;
        -:  651:  int j;
        -:  652://  int k;
        -:  653:  int x;
        -:  654:  int index;
    #####:  655:  int currentPlayer = whoseTurn(state);
    #####:  656:  int nextPlayer = currentPlayer + 1;
        -:  657:
    #####:  658:  int tributeRevealedCards[2] = {-1, -1};
        -:  659:  int temphand[MAX_HAND];// moved above the if statement
    #####:  660:  int drawntreasure=0;
        -:  661:  int cardDrawn;
    #####:  662:  int z = 0;// this is the counter for the temp hand
    #####:  663:  if (nextPlayer > (state->numPlayers - 1)){
    #####:  664:    nextPlayer = 0;
        -:  665:  }
        -:  666:  
        -:  667:	
        -:  668:  //uses switch to select card and perform actions
    #####:  669:  switch( card ) 
        -:  670:    {
        -:  671:    case adventurer:
    #####:  672:	 return playAdventurer(state);
        -:  673:			
        -:  674:    case council_room:
    #####:  675:	  return playCouncil_Room(state, handPos);
        -:  676:			
        -:  677:    case feast:
        -:  678:      //gain card with cost up to 5
        -:  679:      //Backup hand
    #####:  680:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  681:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  682:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  683:      }
        -:  684:      //Backup hand
        -:  685:
        -:  686:      //Update Coins for Buy
    #####:  687:      updateCoins(currentPlayer, state, 5);
    #####:  688:      x = 1;//Condition to loop on
    #####:  689:      while( x == 1) {//Buy one card
    #####:  690:	if (supplyCount(choice1, state) <= 0){
        -:  691:	  if (DEBUG)
        -:  692:	    printf("None of that card left, sorry!\n");
        -:  693:
        -:  694:	  if (DEBUG){
        -:  695:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  696:	  }
        -:  697:	}
    #####:  698:	else if (state->coins < getCost(choice1)){
    #####:  699:	  printf("That card is too expensive!\n");
        -:  700:
        -:  701:	  if (DEBUG){
        -:  702:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  703:	  }
        -:  704:	}
        -:  705:	else{
        -:  706:
        -:  707:	  if (DEBUG){
        -:  708:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  709:	  }
        -:  710:
    #####:  711:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  712:	  x = 0;//No more buying cards
        -:  713:
        -:  714:	  if (DEBUG){
        -:  715:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  716:	  }
        -:  717:
        -:  718:	}
        -:  719:      }     
        -:  720:
        -:  721:      //Reset Hand
    #####:  722:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  723:	state->hand[currentPlayer][i] = temphand[i];
    #####:  724:	temphand[i] = -1;
        -:  725:      }
        -:  726:      //Reset Hand
        -:  727:      			
    #####:  728:      return 0;
        -:  729:			
        -:  730:    case gardens:
    #####:  731:      return -1;
        -:  732:			
        -:  733:    case mine:
    #####:  734:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  735:
    #####:  736:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  737:	{
    #####:  738:	  return -1;
        -:  739:	}
        -:  740:		
    #####:  741:      if (choice2 > treasure_map || choice2 < curse)
        -:  742:	{
    #####:  743:	  return -1;
        -:  744:	}
        -:  745:
    #####:  746:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
        -:  747:	{
    #####:  748:	  return -1;
        -:  749:	}
        -:  750:
    #####:  751:      gainCard(choice2, state, 2, currentPlayer);
        -:  752:
        -:  753:      //discard card from hand
    #####:  754:      discardCard(handPos, currentPlayer, state, 0);
        -:  755:
        -:  756:      //discard trashed card
    #####:  757:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  758:	{
    #####:  759:	  if (state->hand[currentPlayer][i] == j)
        -:  760:	    {
    #####:  761:	      discardCard(i, currentPlayer, state, 0);			
    #####:  762:	      break;
        -:  763:	    }
        -:  764:	}
        -:  765:			
    #####:  766:      return 0;
        -:  767:			
        -:  768:    case remodel:
    #####:  769:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  770:
    #####:  771:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  772:	{
    #####:  773:	  return -1;
        -:  774:	}
        -:  775:
    #####:  776:      gainCard(choice2, state, 0, currentPlayer);
        -:  777:
        -:  778:      //discard card from hand
    #####:  779:      discardCard(handPos, currentPlayer, state, 0);
        -:  780:
        -:  781:      //discard trashed card
    #####:  782:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  783:	{
    #####:  784:	  if (state->hand[currentPlayer][i] == j)
        -:  785:	    {
    #####:  786:	      discardCard(i, currentPlayer, state, 0);			
    #####:  787:	      break;
        -:  788:	    }
        -:  789:	}
        -:  790:
        -:  791:
    #####:  792:      return 0;
        -:  793:		
        -:  794:    case smithy:
    #####:  795:	  return playSmithy(state, handPos);
        -:  796:      /* //+3 Cards
        -:  797:      for (i = 0; i < 3; i++)
        -:  798:	  {
        -:  799:	    drawCard(currentPlayer, state);
        -:  800:	  }
        -:  801:			
        -:  802:      //discard card from hand
        -:  803:      discardCard(handPos, currentPlayer, state, 0);
        -:  804:      return 0; */
        -:  805:		
        -:  806:    case village:
    #####:  807:        return playVillage(state, handPos);
        -:  808:      /*
        -:  809:      //+1 Card
        -:  810:      drawCard(currentPlayer, state);
        -:  811:			
        -:  812:      //+2 Actions
        -:  813:      state->numActions = state->numActions + 2;
        -:  814:			
        -:  815:      //discard played card from hand
        -:  816:      discardCard(handPos, currentPlayer, state, 0);
        -:  817:      return 0;
        -:  818:       */	
        -:  819:    case baron:
    #####:  820:      state->numBuys++;//Increase buys by 1!
    #####:  821:      if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  822:	int p = 0;//Iterator for hand!
    #####:  823:	int card_not_discarded = 1;//Flag for discard set!
    #####:  824:	while(card_not_discarded){
    #####:  825:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
    #####:  826:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  827:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  828:	    state->discardCount[currentPlayer]++;
    #####:  829:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:  830:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  831:	    }
    #####:  832:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  833:	    state->handCount[currentPlayer]--;
    #####:  834:	    card_not_discarded = 0;//Exit the loop
        -:  835:	  }
    #####:  836:	  else if (p > state->handCount[currentPlayer]){
        -:  837:	    if(DEBUG) {
        -:  838:	      printf("No estate cards in your hand, invalid choice\n");
        -:  839:	      printf("Must gain an estate if there are any\n");
        -:  840:	    }
    #####:  841:	    if (supplyCount(estate, state) > 0){
    #####:  842:	      gainCard(estate, state, 0, currentPlayer);
    #####:  843:	      state->supplyCount[estate]--;//Decrement estates
    #####:  844:	      if (supplyCount(estate, state) == 0){
    #####:  845:		isGameOver(state);
        -:  846:	      }
        -:  847:	    }
    #####:  848:	    card_not_discarded = 0;//Exit the loop
        -:  849:	  }
        -:  850:			    
        -:  851:	  else{
    #####:  852:	    p++;//Next card
        -:  853:	  }
        -:  854:	}
        -:  855:      }
        -:  856:			    
        -:  857:      else{
    #####:  858:	if (supplyCount(estate, state) > 0){
    #####:  859:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  860:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  861:	  if (supplyCount(estate, state) == 0){
    #####:  862:	    isGameOver(state);
        -:  863:	  }
        -:  864:	}
        -:  865:      }
        -:  866:	    
        -:  867:      
    #####:  868:      return 0;
        -:  869:		
        -:  870:    case great_hall:
        -:  871:      //+1 Card
    #####:  872:      drawCard(currentPlayer, state);
        -:  873:			
        -:  874:      //+1 Actions
    #####:  875:      state->numActions++;
        -:  876:			
        -:  877:      //discard card from hand
    #####:  878:      discardCard(handPos, currentPlayer, state, 0);
    #####:  879:      return 0;
        -:  880:		
        -:  881:    case minion:
        -:  882:      //+1 action
    #####:  883:      state->numActions++;
        -:  884:			
        -:  885:      //discard card from hand
    #####:  886:      discardCard(handPos, currentPlayer, state, 0);
        -:  887:			
    #####:  888:      if (choice1)		//+2 coins
        -:  889:	{
    #####:  890:	  state->coins = state->coins + 2;
        -:  891:	}
        -:  892:			
    #####:  893:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  894:	{
        -:  895:	  //discard hand
    #####:  896:	  while(numHandCards(state) > 0)
        -:  897:	    {
    #####:  898:	      discardCard(handPos, currentPlayer, state, 0);
        -:  899:	    }
        -:  900:				
        -:  901:	  //draw 4
    #####:  902:	  for (i = 0; i < 4; i++)
        -:  903:	    {
    #####:  904:	      drawCard(currentPlayer, state);
        -:  905:	    }
        -:  906:				
        -:  907:	  //other players discard hand and redraw if hand size > 4
    #####:  908:	  for (i = 0; i < state->numPlayers; i++)
        -:  909:	    {
    #####:  910:	      if (i != currentPlayer)
        -:  911:		{
    #####:  912:		  if ( state->handCount[i] > 4 )
        -:  913:		    {
        -:  914:		      //discard hand
    #####:  915:		      while( state->handCount[i] > 0 )
        -:  916:			{
    #####:  917:			  discardCard(handPos, i, state, 0);
        -:  918:			}
        -:  919:							
        -:  920:		      //draw 4
    #####:  921:		      for (j = 0; j < 4; j++)
        -:  922:			{
    #####:  923:			  drawCard(i, state);
        -:  924:			}
        -:  925:		    }
        -:  926:		}
        -:  927:	    }
        -:  928:				
        -:  929:	}
    #####:  930:      return 0;
        -:  931:		
        -:  932:    case steward:
    #####:  933:	  return playSteward(state, handPos, choice1, choice2, choice3);
        -:  934:
        -:  935:		
        -:  936:    case tribute:
    #####:  937:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####:  938:	if (state->deckCount[nextPlayer] > 0){
    #####:  939:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  940:	  state->deckCount[nextPlayer]--;
        -:  941:	}
    #####:  942:	else if (state->discardCount[nextPlayer] > 0){
    #####:  943:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  944:	  state->discardCount[nextPlayer]--;
        -:  945:	}
        -:  946:	else{
        -:  947:	  //No Card to Reveal
        -:  948:	  if (DEBUG){
        -:  949:	    printf("No cards to reveal\n");
        -:  950:	  }
        -:  951:	}
        -:  952:      }
        -:  953:	    
        -:  954:      else{
    #####:  955:	if (state->deckCount[nextPlayer] == 0){
    #####:  956:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####:  957:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  958:	    state->deckCount[nextPlayer]++;
    #####:  959:	    state->discard[nextPlayer][i] = -1;
    #####:  960:	    state->discardCount[nextPlayer]--;
        -:  961:	  }
        -:  962:			    
    #####:  963:	  shuffle(nextPlayer,state);//Shuffle the deck
        -:  964:	} 
    #####:  965:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  966:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  967:	state->deckCount[nextPlayer]--;
    #####:  968:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  969:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  970:	state->deckCount[nextPlayer]--;
        -:  971:      }    
        -:  972:		       
    #####:  973:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####:  974:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  975:	state->playedCardCount++;
    #####:  976:	tributeRevealedCards[1] = -1;
        -:  977:      } 
        -:  978:
    #####:  979:      for (i = 0; i <= 2; i ++){
    #####:  980:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####:  981:	  state->coins += 2;
        -:  982:	}
        -:  983:		    
    #####:  984:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####:  985:	  drawCard(currentPlayer, state);
    #####:  986:	  drawCard(currentPlayer, state);
        -:  987:	}
        -:  988:	else{//Action Card
    #####:  989:	  state->numActions = state->numActions + 2;
        -:  990:	}
        -:  991:      }
        -:  992:	    
    #####:  993:      return 0;
        -:  994:		
        -:  995:    case ambassador:
    #####:  996:      j = 0;		//used to check if player has enough cards to discard
        -:  997:
    #####:  998:      if (choice2 > 2 || choice2 < 0)
        -:  999:	{
    #####: 1000:	  return -1;				
        -: 1001:	}
        -: 1002:
    #####: 1003:      if (choice1 == handPos)
        -: 1004:	{
    #####: 1005:	  return -1;
        -: 1006:	}
        -: 1007:
    #####: 1008:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1009:	{
    #####: 1010:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1011:	    {
    #####: 1012:	      j++;
        -: 1013:	    }
        -: 1014:	}
    #####: 1015:      if (j < choice2)
        -: 1016:	{
    #####: 1017:	  return -1;				
        -: 1018:	}
        -: 1019:
        -: 1020:      if (DEBUG) 
        -: 1021:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1022:
        -: 1023:      //increase supply count for choosen card by amount being discarded
    #####: 1024:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1025:			
        -: 1026:      //each other player gains a copy of revealed card
    #####: 1027:      for (i = 0; i < state->numPlayers; i++)
        -: 1028:	{
    #####: 1029:	  if (i != currentPlayer)
        -: 1030:	    {
    #####: 1031:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1032:	    }
        -: 1033:	}
        -: 1034:
        -: 1035:      //discard played card from hand
    #####: 1036:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1037:
        -: 1038:      //trash copies of cards returned to supply
    #####: 1039:      for (j = 0; j < choice2; j++)
        -: 1040:	{
    #####: 1041:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1042:	    {
    #####: 1043:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1044:		{
    #####: 1045:		  discardCard(i, currentPlayer, state, 1);
    #####: 1046:		  break;
        -: 1047:		}
        -: 1048:	    }
        -: 1049:	}			
        -: 1050:
    #####: 1051:      return 0;
        -: 1052:		
        -: 1053:    case cutpurse:
        -: 1054:
        -: 1055:/*       updateCoins(currentPlayer, state, 2);
        -: 1056:      for (i = 0; i < state->numPlayers; i++)
        -: 1057:	{
        -: 1058:	  if (i != currentPlayer)
        -: 1059:	    {
        -: 1060:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1061:		{
        -: 1062:		  if (state->hand[i][j] == copper)
        -: 1063:		    {
        -: 1064:		      discardCard(j, i, state, 0);
        -: 1065:		      break;
        -: 1066:		    }
        -: 1067:		  if (j == state->handCount[i])
        -: 1068:		    {
        -: 1069:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1070:			{
        -: 1071:			  if (DEBUG)
        -: 1072:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1073:			}	
        -: 1074:		      break;
        -: 1075:		    }		
        -: 1076:		}
        -: 1077:					
        -: 1078:	    }
        -: 1079:				
        -: 1080:	}				
        -: 1081:
        -: 1082:      //discard played card from hand
        -: 1083:      discardCard(handPos, currentPlayer, state, 0); */			
        -: 1084:
    #####: 1085:      return playCutpurse(state, handPos);
        -: 1086:
        -: 1087:		
        -: 1088:    case embargo: 
        -: 1089:      //+2 Coins
    #####: 1090:      state->coins = state->coins + 2;
        -: 1091:			
        -: 1092:      //see if selected pile is in play
    #####: 1093:      if ( state->supplyCount[choice1] == -1 )
        -: 1094:	{
    #####: 1095:	  return -1;
        -: 1096:	}
        -: 1097:			
        -: 1098:      //add embargo token to selected supply pile
    #####: 1099:      state->embargoTokens[choice1]++;
        -: 1100:			
        -: 1101:      //trash card
    #####: 1102:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1103:      return 0;
        -: 1104:		
        -: 1105:    case outpost:
        -: 1106:      //set outpost flag
    #####: 1107:      state->outpostPlayed++;
        -: 1108:			
        -: 1109:      //discard card
    #####: 1110:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1111:      return 0;
        -: 1112:		
        -: 1113:    case salvager:
        -: 1114:      //+1 buy
    #####: 1115:      state->numBuys++;
        -: 1116:			
    #####: 1117:      if (choice1)
        -: 1118:	{
        -: 1119:	  //gain coins equal to trashed card
    #####: 1120:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1121:	  //trash card
    #####: 1122:	  discardCard(choice1, currentPlayer, state, 1);	
        -: 1123:	}
        -: 1124:			
        -: 1125:      //discard card
    #####: 1126:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1127:      return 0;
        -: 1128:		
        -: 1129:    case sea_hag:
    #####: 1130:      for (i = 0; i < state->numPlayers; i++){
    #####: 1131:	if (i != currentPlayer){
    #####: 1132:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1133:	  state->discardCount[i]++;
    #####: 1134:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1135:	}
        -: 1136:      }
    #####: 1137:      return 0;
        -: 1138:		
        -: 1139:    case treasure_map:
        -: 1140:      //search hand for another treasure_map
    #####: 1141:      index = -1;
    #####: 1142:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1143:	{
    #####: 1144:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1145:	    {
    #####: 1146:	      index = i;
    #####: 1147:	      break;
        -: 1148:	    }
        -: 1149:	}
    #####: 1150:      if (index > -1)
        -: 1151:	{
        -: 1152:	  //trash both treasure cards
    #####: 1153:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1154:	  discardCard(index, currentPlayer, state, 1);
        -: 1155:
        -: 1156:	  //gain 4 Gold cards
    #####: 1157:	  for (i = 0; i < 4; i++)
        -: 1158:	    {
    #####: 1159:	      gainCard(gold, state, 1, currentPlayer);
        -: 1160:	    }
        -: 1161:				
        -: 1162:	  //return success
    #####: 1163:	  return 1;
        -: 1164:	}
        -: 1165:			
        -: 1166:      //no second treasure_map found in hand
    #####: 1167:      return -1;
        -: 1168:    }
        -: 1169:	
    #####: 1170:  return -1;
        -: 1171:}
        -: 1172:
    #####: 1173:int playAdventurer(struct gameState *state){
    #####: 1174:	int drawntreasure = 0;
        -: 1175:	int cardDrawn;
    #####: 1176:	int currentPlayer = whoseTurn(state);
        -: 1177:    int temphand[MAX_HAND];// moved above the if statement
    #####: 1178:    int z = 0;// this is the counter for the temp hand
        -: 1179:
        -: 1180:	
    #####: 1181:	while(drawntreasure<3){
    #####: 1182:		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
    #####: 1183:		  shuffle(currentPlayer, state);
        -: 1184:		}
    #####: 1185:		drawCard(currentPlayer, state);
    #####: 1186:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####: 1187:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####: 1188:		  drawntreasure++;
        -: 1189:		else{
    #####: 1190:		  temphand[z]=cardDrawn;
    #####: 1191:		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####: 1192:		  z++;
        -: 1193:		}
        -: 1194:	  }
    #####: 1195:	  while(z-1>=0){
    #####: 1196:		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####: 1197:	   z=z-1;
        -: 1198:	  }
        -: 1199:	  
    #####: 1200:	return 0;
        -: 1201:}
        -: 1202:
        -: 1203://Add 4 cards
    #####: 1204:int playCouncil_Room(struct gameState *state, int handPos){
    #####: 1205:	int currentPlayer = whoseTurn(state);
        -: 1206:	int i;
        -: 1207:  
    #####: 1208:    for (i = 0; i < 5; i++)
        -: 1209:	{
    #####: 1210:	  drawCard(currentPlayer, state);
        -: 1211:	}
        -: 1212:			
        -: 1213:    //+1 Buy
    #####: 1214:    state->numBuys++;
        -: 1215:			
        -: 1216:    //Each other player draws a card
    #####: 1217:    for (i = 0; i < state->numPlayers; i++)
        -: 1218:	{
    #####: 1219:	  if ( i != currentPlayer )
        -: 1220:	  {
    #####: 1221:	    drawCard(i, state);
        -: 1222:	  }
        -: 1223:	}
        -: 1224:			
        -: 1225:    //put played card in played card pile
    #####: 1226:    discardCard(handPos, currentPlayer, state, 0);
    #####: 1227:	return 0;
        -: 1228:}
        -: 1229:
    #####: 1230:int playSmithy(struct gameState *state, int handPos){
        -: 1231:    int i;
    #####: 1232:    int currentPlayer = whoseTurn(state);
        -: 1233:
        -: 1234:    //+3 Cards
    #####: 1235:    for (i = 0; i < 3; i++)
        -: 1236:    {
    #####: 1237:      drawCard(currentPlayer, state);
        -: 1238:    }
        -: 1239:    	
        -: 1240:    //discard card from hand
    #####: 1241:    discardCard(handPos, currentPlayer, state, 0-1);
    #####: 1242:    return 0;
        -: 1243:}
        -: 1244:
    #####: 1245:int playCutpurse(struct gameState *state, int handPos){
        -: 1246:	int i, j, k;
    #####: 1247:	int currentPlayer = whoseTurn(state);
        -: 1248:
        -: 1249:	
    #####: 1250:    updateCoins(currentPlayer, state, 2);
    #####: 1251:    for (i = 0; i < state->numPlayers; i++)
        -: 1252:	{
    #####: 1253:	  if (i != currentPlayer)
        -: 1254:	  {
    #####: 1255:	    for (j = 0; j <= state->handCount[i]; j++){
    #####: 1256:          if (state->hand[i][j] == copper){
    #####: 1257:	        discardCard(j, i, state, 0);
    #####: 1258:		    return -1;
        -: 1259:	      }
    #####: 1260:	      if (j = state->handCount[i]){
    #####: 1261:            for (k = 0; k < state->handCount[i]; k++){
        -: 1262:		      if (DEBUG)
        -: 1263:                printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1264:            }	
    #####: 1265:		  return -1;
        -: 1266:          }		
        -: 1267:		}
        -: 1268:					
        -: 1269:	  }//end != currentPlayer switch		
        -: 1270:	}
        -: 1271:
        -: 1272:    //discard played card from hand
    #####: 1273:	discardCard(handPos, currentPlayer, state, 0);
        -: 1274:	
    #####: 1275:	return 0;
        -: 1276:}
        -: 1277:
    #####: 1278:int playSteward(struct gameState *state, int handPos, int choice1, int choice2, int choice3){
    #####: 1279:  int currentPlayer = whoseTurn(state);
        -: 1280:
    #####: 1281:  if (choice1 == 1) {
        -: 1282:  //+2 cards
    #####: 1283:    drawCard(currentPlayer, state);
    #####: 1284:    drawCard(currentPlayer, state);
        -: 1285:  }
    #####: 1286:  else if (choice1 == 2) {
        -: 1287:  //+2 coins
    #####: 1288:    state->coins = state->coins + 2;
        -: 1289:  }
        -: 1290:  else {
        -: 1291:  //trash 2 cards in hand
    #####: 1292:    discardCard(choice2, currentPlayer, state, 1);
    #####: 1293:    discardCard(choice3, currentPlayer, state, 1);
        -: 1294:  }
        -: 1295:	
        -: 1296:  //discard card from hand
    #####: 1297:  discardCard(handPos, currentPlayer, state, 0);
    #####: 1298:  return 0;
        -: 1299:}
        -: 1300:
    #####: 1301:int playVillage(struct gameState *state, int handPos){
    #####: 1302:    int currentPlayer = whoseTurn(state);
        -: 1303:
        -: 1304:    //+1 Card
    #####: 1305:     drawCard(currentPlayer, state);
        -: 1306:
        -: 1307:     //+2 Actions
    #####: 1308:     state->numActions = state->numActions + 2;
        -: 1309:
        -: 1310:     //discard played card from hand
    #####: 1311:     discardCard(handPos, currentPlayer, state, 0);
    #####: 1312:     return 0;
        -: 1313:}
        -: 1314:
    #####: 1315:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1316:{
        -: 1317:	
        -: 1318:  //if card is not trashed, added to Played pile 
    #####: 1319:  if (trashFlag < 1)
        -: 1320:    {
        -: 1321:      //add card to played pile
    #####: 1322:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1323:      state->playedCardCount++;
        -: 1324:    }
        -: 1325:	
        -: 1326:  //set played card to -1
    #####: 1327:  state->hand[currentPlayer][handPos] = -1;
        -: 1328:	
        -: 1329:  //remove card from player's hand
    #####: 1330:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1331:    {
        -: 1332:      //reduce number of cards in hand
    #####: 1333:      state->handCount[currentPlayer]--;
        -: 1334:    }
    #####: 1335:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1336:    {
        -: 1337:      //reduce number of cards in hand
    #####: 1338:      state->handCount[currentPlayer]--;
        -: 1339:    }
        -: 1340:  else 	
        -: 1341:    {
        -: 1342:      //replace discarded card with last card in hand
    #####: 1343:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1344:      //set last card to -1
    #####: 1345:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1346:      //reduce number of cards in hand
    #####: 1347:      state->handCount[currentPlayer]--;
        -: 1348:    }
        -: 1349:	
    #####: 1350:  return 0;
        -: 1351:}
        -: 1352:
    #####: 1353:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1354:{
        -: 1355:  //Note: supplyPos is enum of choosen card
        -: 1356:	
        -: 1357:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1358:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1359:    {
    #####: 1360:      return -1;
        -: 1361:    }
        -: 1362:	
        -: 1363:  //added card for [whoseTurn] current player:
        -: 1364:  // toFlag = 0 : add to discard
        -: 1365:  // toFlag = 1 : add to deck
        -: 1366:  // toFlag = 2 : add to hand
        -: 1367:
    #####: 1368:  if (toFlag == 1)
        -: 1369:    {
    #####: 1370:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1371:      state->deckCount[player]++;
        -: 1372:    }
    #####: 1373:  else if (toFlag == 2)
        -: 1374:    {
    #####: 1375:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1376:      state->handCount[player]++;
        -: 1377:    }
        -: 1378:  else
        -: 1379:    {
    #####: 1380:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1381:      state->discardCount[player]++;
        -: 1382:    }
        -: 1383:	
        -: 1384:  //decrease number in supply pile
    #####: 1385:  state->supplyCount[supplyPos]--;
        -: 1386:	 
    #####: 1387:  return 0;
        -: 1388:}
        -: 1389:
      809: 1390:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1391:{
        -: 1392:  int i;
        -: 1393:	
        -: 1394:  //reset coin count
      809: 1395:  state->coins = 0;
        -: 1396:
        -: 1397:  //add coins for each Treasure card in player's hand
     3844: 1398:  for (i = 0; i < state->handCount[player]; i++)
        -: 1399:    {
     3035: 1400:      if (state->hand[player][i] == copper)
        -: 1401:	{
     1028: 1402:	  state->coins += 1;
        -: 1403:	}
     2007: 1404:      else if (state->hand[player][i] == silver)
        -: 1405:	{
     1000: 1406:	  state->coins += 2;
        -: 1407:	}
     1007: 1408:      else if (state->hand[player][i] == gold)
        -: 1409:	{
     1000: 1410:	  state->coins += 3;
        -: 1411:	}	
        -: 1412:    }	
        -: 1413:
        -: 1414:  //add bonus
      809: 1415:  state->coins += bonus;
        -: 1416:
      809: 1417:  return 0;
        -: 1418:}
        -: 1419:
        -: 1420:
        -: 1421://end of dominion.c
        -: 1422:

Testing isGameOver() with seed 1234
Game Initialized! :)
Initial province count: 8
__ALL TESTS PASSED!__

File 'dominion.c'
Lines executed:24.47% of 568
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:7
        -:    0:Programs:4
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
      270:    8:int compare(const void* a, const void* b) {
      270:    9:  if (*(int*)a > *(int*)b)
    #####:   10:    return 1;
      270:   11:  if (*(int*)a < *(int*)b)
       72:   12:    return -1;
      198:   13:  return 0;
        -:   14:}
        -:   15:
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
        -:   21:
    #####:   22:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   23:		  int k8, int k9, int k10) {
    #####:   24:  int* k = malloc(10 * sizeof(int));
    #####:   25:  k[0] = k1;
    #####:   26:  k[1] = k2;
    #####:   27:  k[2] = k3;
    #####:   28:  k[3] = k4;
    #####:   29:  k[4] = k5;
    #####:   30:  k[5] = k6;
    #####:   31:  k[6] = k7;
    #####:   32:  k[7] = k8;
    #####:   33:  k[8] = k9;
    #####:   34:  k[9] = k10;
    #####:   35:  return k;
        -:   36:}
        -:   37:
        7:   38:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   39:		   struct gameState *state) {
        -:   40:
        -:   41:  int i;
        -:   42:  int j;
        -:   43:  int it;			
        -:   44:  //set up random number generator
        7:   45:  SelectStream(1);
        7:   46:  PutSeed((long)randomSeed);
        -:   47:  
        -:   48:  //check number of players
        7:   49:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   50:    {
    #####:   51:      return -1;
        -:   52:    }
        -:   53:
        -:   54:  //set number of players
        7:   55:  state->numPlayers = numPlayers;
        -:   56:
        -:   57:  //check selected kingdom cards are different
       77:   58:  for (i = 0; i < 10; i++)
        -:   59:    {
      770:   60:      for (j = 0; j < 10; j++)
        -:   61:        {
      700:   62:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   63:	    {
    #####:   64:	      return -1;
        -:   65:	    }
        -:   66:        }
        -:   67:    }
        -:   68:
        -:   69:
        -:   70:  //initialize supply
        -:   71:  ///////////////////////////////
        -:   72:
        -:   73:  //set number of Curse cards
        7:   74:  if (numPlayers == 2)
        -:   75:    {
        5:   76:      state->supplyCount[curse] = 10;
        -:   77:    }
        2:   78:  else if (numPlayers == 3)
        -:   79:    {
    #####:   80:      state->supplyCount[curse] = 20;
        -:   81:    }
        -:   82:  else
        -:   83:    {
        2:   84:      state->supplyCount[curse] = 30;
        -:   85:    }
        -:   86:
        -:   87:  //set number of Victory cards
        7:   88:  if (numPlayers == 2)
        -:   89:    {
        5:   90:      state->supplyCount[estate] = 8;
        5:   91:      state->supplyCount[duchy] = 8;
        5:   92:      state->supplyCount[province] = 8;
        -:   93:    }
        -:   94:  else
        -:   95:    {
        2:   96:      state->supplyCount[estate] = 12;
        2:   97:      state->supplyCount[duchy] = 12;
        2:   98:      state->supplyCount[province] = 12;
        -:   99:    }
        -:  100:
        -:  101:  //set number of Treasure cards
        7:  102:  state->supplyCount[copper] = 60 - (7 * numPlayers);
        7:  103:  state->supplyCount[silver] = 40;
        7:  104:  state->supplyCount[gold] = 30;
        -:  105:
        -:  106:  //set number of Kingdom cards
      147:  107:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  108:    {
     1155:  109:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  110:	{
     1085:  111:	  if (kingdomCards[j] == i)
        -:  112:	    {
        -:  113:	      //check if card is a 'Victory' Kingdom card
       70:  114:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  115:		{
       14:  116:		  if (numPlayers == 2){ 
        5:  117:		    state->supplyCount[i] = 8; 
        -:  118:		  }
        2:  119:		  else{ state->supplyCount[i] = 12; }
        -:  120:		}
        -:  121:	      else
        -:  122:		{
       63:  123:		  state->supplyCount[i] = 10;
        -:  124:		}
       70:  125:	      break;
        -:  126:	    }
        -:  127:	  else    //card is not in the set choosen for the game
        -:  128:	    {
     1015:  129:	      state->supplyCount[i] = -1;
        -:  130:	    }
        -:  131:	}
        -:  132:
        -:  133:    }
        -:  134:
        -:  135:  ////////////////////////
        -:  136:  //supply intilization complete
        -:  137:
        -:  138:  //set player decks
       25:  139:  for (i = 0; i < numPlayers; i++)
        -:  140:    {
       18:  141:      state->deckCount[i] = 0;
       72:  142:      for (j = 0; j < 3; j++)
        -:  143:	{
       54:  144:	  state->deck[i][j] = estate;
       54:  145:	  state->deckCount[i]++;
        -:  146:	}
      144:  147:      for (j = 3; j < 10; j++)
        -:  148:	{
      126:  149:	  state->deck[i][j] = copper;
      126:  150:	  state->deckCount[i]++;		
        -:  151:	}
        -:  152:    }
        -:  153:
        -:  154:  //shuffle player decks
       25:  155:  for (i = 0; i < numPlayers; i++)
        -:  156:    {
       18:  157:      if ( shuffle(i, state) < 0 )
        -:  158:	{
    #####:  159:	  return -1;
        -:  160:	}
        -:  161:    }
        -:  162:
        -:  163:  //draw player hands
       25:  164:  for (i = 0; i < numPlayers; i++)
        -:  165:    {  
        -:  166:      //initialize hand size to zero
       18:  167:      state->handCount[i] = 0;
       18:  168:      state->discardCount[i] = 0;
        -:  169:      //draw 5 cards
        -:  170:      // for (j = 0; j < 5; j++)
        -:  171:      //	{
        -:  172:      //	  drawCard(i, state);
        -:  173:      //	}
        -:  174:    }
        -:  175:  
        -:  176:  //set embargo tokens to 0 for all supply piles
      196:  177:  for (i = 0; i <= treasure_map; i++)
        -:  178:    {
      189:  179:      state->embargoTokens[i] = 0;
        -:  180:    }
        -:  181:
        -:  182:  //initialize first player's turn
        7:  183:  state->outpostPlayed = 0;
        7:  184:  state->phase = 0;
        7:  185:  state->numActions = 1;
        7:  186:  state->numBuys = 1;
        7:  187:  state->playedCardCount = 0;
        7:  188:  state->whoseTurn = 0;
        7:  189:  state->handCount[state->whoseTurn] = 0;
        -:  190:  //int it; move to top
        -:  191:
        -:  192:  //Moved draw cards to here, only drawing at the start of a turn
       42:  193:  for (it = 0; it < 5; it++){
       35:  194:    drawCard(state->whoseTurn, state);
        -:  195:  }
        -:  196:
        7:  197:  updateCoins(state->whoseTurn, state, 0);
        -:  198:
        7:  199:  return 0;
        -:  200:}
        -:  201:
       18:  202:int shuffle(int player, struct gameState *state) {
        -:  203: 
        -:  204:
        -:  205:  int newDeck[MAX_DECK];
       18:  206:  int newDeckPos = 0;
        -:  207:  int card;
        -:  208:  int i;
        -:  209:
       18:  210:  if (state->deckCount[player] < 1)
    #####:  211:    return -1;
       18:  212:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  213:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  214:
      216:  215:  while (state->deckCount[player] > 0) {
      180:  216:    card = floor(Random() * state->deckCount[player]);
      180:  217:    newDeck[newDeckPos] = state->deck[player][card];
      180:  218:    newDeckPos++;
      647:  219:    for (i = card; i < state->deckCount[player]-1; i++) {
      467:  220:      state->deck[player][i] = state->deck[player][i+1];
        -:  221:    }
      180:  222:    state->deckCount[player]--;
        -:  223:  }
      198:  224:  for (i = 0; i < newDeckPos; i++) {
      180:  225:    state->deck[player][i] = newDeck[i];
      180:  226:    state->deckCount[player]++;
        -:  227:  }
        -:  228:
       18:  229:  return 0;
        -:  230:}
        -:  231:
    #####:  232:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  233:{	
        -:  234:  int card;
    #####:  235:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  236:
        -:  237:  //check if it is the right phase
    #####:  238:  if (state->phase != 0)
        -:  239:    {
    #####:  240:      return -1;
        -:  241:    }
        -:  242:	
        -:  243:  //check if player has enough actions
    #####:  244:  if ( state->numActions < 1 )
        -:  245:    {
    #####:  246:      return -1;
        -:  247:    }
        -:  248:	
        -:  249:  //get card played
    #####:  250:  card = handCard(handPos, state);
        -:  251:	
        -:  252:  //check if selected card is an action
    #####:  253:  if ( card < adventurer || card > treasure_map )
        -:  254:    {
    #####:  255:      return -1;
        -:  256:    }
        -:  257:	
        -:  258:  //play card
    #####:  259:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  260:    {
    #####:  261:      return -1;
        -:  262:    }
        -:  263:	
        -:  264:  //reduce number of actions
    #####:  265:  state->numActions--;
        -:  266:
        -:  267:  //update coins (Treasure cards may be added with card draws)
    #####:  268:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  269:	
    #####:  270:  return 0;
        -:  271:}
        -:  272:
    #####:  273:int buyCard(int supplyPos, struct gameState *state) {
        -:  274:  int who;
        -:  275:  if (DEBUG){
        -:  276:    printf("Entering buyCard...\n");
        -:  277:  }
        -:  278:
        -:  279:  // I don't know what to do about the phase thing.
        -:  280:
    #####:  281:  who = state->whoseTurn;
        -:  282:
    #####:  283:  if (state->numBuys < 1){
        -:  284:    if (DEBUG)
        -:  285:      printf("You do not have any buys left\n");
    #####:  286:    return -1;
    #####:  287:  } else if (supplyCount(supplyPos, state) <1){
        -:  288:    if (DEBUG)
        -:  289:      printf("There are not any of that type of card left\n");
    #####:  290:    return -1;
    #####:  291:  } else if (state->coins < getCost(supplyPos)){
        -:  292:    if (DEBUG) 
        -:  293:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  294:    return -1;
        -:  295:  } else {
    #####:  296:    state->phase=1;
        -:  297:    //state->supplyCount[supplyPos]--;
    #####:  298:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  299:  
    #####:  300:    state->coins = (state->coins) - (getCost(supplyPos));
    #####:  301:    state->numBuys--;
        -:  302:    if (DEBUG)
        -:  303:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  304:  }
        -:  305:
        -:  306:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  307:  //state->discardCount[who]++;
        -:  308:    
    #####:  309:  return 0;
        -:  310:}
        -:  311:
    #####:  312:int numHandCards(struct gameState *state) {
    #####:  313:  return state->handCount[ whoseTurn(state) ];
        -:  314:}
        -:  315:
    #####:  316:int handCard(int handPos, struct gameState *state) {
    #####:  317:  int currentPlayer = whoseTurn(state);
    #####:  318:  return state->hand[currentPlayer][handPos];
        -:  319:}
        -:  320:
    #####:  321:int supplyCount(int card, struct gameState *state) {
    #####:  322:  return state->supplyCount[card];
        -:  323:}
        -:  324:
    #####:  325:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  326:  int i;
    #####:  327:  int count = 0;
        -:  328:
    #####:  329:  for (i = 0; i < state->deckCount[player]; i++)
        -:  330:    {
    #####:  331:      if (state->deck[player][i] == card) count++;
        -:  332:    }
        -:  333:
    #####:  334:  for (i = 0; i < state->handCount[player]; i++)
        -:  335:    {
    #####:  336:      if (state->hand[player][i] == card) count++;
        -:  337:    }
        -:  338:
    #####:  339:  for (i = 0; i < state->discardCount[player]; i++)
        -:  340:    {
    #####:  341:      if (state->discard[player][i] == card) count++;
        -:  342:    }
        -:  343:
    #####:  344:  return count;
        -:  345:}
        -:  346:
       12:  347:int whoseTurn(struct gameState *state) {
       12:  348:  return state->whoseTurn;
        -:  349:}
        -:  350:
    #####:  351:int endTurn(struct gameState *state) {
        -:  352:  int k;
        -:  353:  int i;
    #####:  354:  int currentPlayer = whoseTurn(state);
        -:  355:  
        -:  356:  //Discard hand
    #####:  357:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  358:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  359:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  360:  }
    #####:  361:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  362:    
        -:  363:  //Code for determining the player
    #####:  364:  if (currentPlayer < (state->numPlayers - 1)){ 
    #####:  365:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  366:  }
        -:  367:  else{
    #####:  368:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  369:  }
        -:  370:
    #####:  371:  state->outpostPlayed = 0;
    #####:  372:  state->phase = 0;
    #####:  373:  state->numActions = 1;
    #####:  374:  state->coins = 0;
    #####:  375:  state->numBuys = 1;
    #####:  376:  state->playedCardCount = 0;
    #####:  377:  state->handCount[state->whoseTurn] = 0;
        -:  378:
        -:  379:  //int k; move to top
        -:  380:  //Next player draws hand
    #####:  381:  for (k = 0; k < 5; k++){
    #####:  382:    drawCard(state->whoseTurn, state);//Draw a card
        -:  383:  }
        -:  384:
        -:  385:  //Update money
    #####:  386:  updateCoins(state->whoseTurn, state , 0);
        -:  387:
    #####:  388:  return 0;
        -:  389:}
        -:  390:
       78:  391:int isGameOver(struct gameState *state) {
        -:  392:  int i;
        -:  393:  int j;
        -:  394:	
        -:  395:  //if stack of Province cards is empty, the game ends
       78:  396:  if (state->supplyCount[province] == 0)
        -:  397:    {
        3:  398:      return 1;
        -:  399:    }
        -:  400:
        -:  401:  //if three supply pile are at 0, the game ends
       75:  402:    j = 0;
     1950:  403:    for (i = 0; i < 25; i++)
        -:  404:    {
     1875:  405:      if (state->supplyCount[i] == 0)
        -:  406:        {
      129:  407:          j++;
        -:  408:        }
        -:  409:    }
       75:  410:    if ( j >= 3)
        -:  411:    {
       20:  412:      return 1;
        -:  413:    }
        -:  414:
       55:  415:  return 0;
        -:  416:}
        -:  417:
    #####:  418:int scoreFor (int player, struct gameState *state) {
        -:  419:
        -:  420:  int i;
    #####:  421:  int score = 0;
        -:  422:  //score from hand
    #####:  423:  for (i = 0; i < state->handCount[player]; i++)
        -:  424:    {
    #####:  425:      if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  426:      if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  427:      if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  428:      if (state->hand[player][i] == province) { score = score + 6; };
    #####:  429:      if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  430:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  431:    }
        -:  432:
        -:  433:  //score from discard
    #####:  434:  for (i = 0; i < state->discardCount[player]; i++)
        -:  435:    {
    #####:  436:      if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  437:      if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  438:      if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  439:      if (state->discard[player][i] == province) { score = score + 6; };
    #####:  440:      if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  441:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  442:    }
        -:  443:
        -:  444:  //score from deck
    #####:  445:  for (i = 0; i < state->discardCount[player]; i++)
        -:  446:    {
    #####:  447:      if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  448:      if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  449:      if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  450:      if (state->deck[player][i] == province) { score = score + 6; };
    #####:  451:      if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  452:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  453:    }
        -:  454:
    #####:  455:  return score;
        -:  456:}
        -:  457:
    #####:  458:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  459:  int i;	
        -:  460:  int j;
        -:  461:  int highScore;
        -:  462:  int currentPlayer;
        -:  463:
        -:  464:  //get score for each player
    #####:  465:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  466:    {
        -:  467:      //set unused player scores to -9999
    #####:  468:      if (i >= state->numPlayers)
        -:  469:	{
    #####:  470:	  players[i] = -9999;
        -:  471:	}
        -:  472:      else
        -:  473:	{
    #####:  474:	  players[i] = scoreFor (i, state);
        -:  475:	}
        -:  476:    }
        -:  477:
        -:  478:  //find highest score
    #####:  479:  j = 0;
    #####:  480:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  481:    {
    #####:  482:      if (players[i] > players[j])
        -:  483:	{
    #####:  484:	  j = i;
        -:  485:	}
        -:  486:    }
    #####:  487:  highScore = players[j];
        -:  488:
        -:  489:  //add 1 to players who had less turns
    #####:  490:  currentPlayer = whoseTurn(state);
    #####:  491:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  492:    {
    #####:  493:      if ( players[i] == highScore && i > currentPlayer )
        -:  494:	{
    #####:  495:	  players[i]++;
        -:  496:	}
        -:  497:    }
        -:  498:
        -:  499:  //find new highest score
    #####:  500:  j = 0;
    #####:  501:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  502:    {
    #####:  503:      if ( players[i] > players[j] )
        -:  504:	{
    #####:  505:	  j = i;
        -:  506:	}
        -:  507:    }
    #####:  508:  highScore = players[j];
        -:  509:
        -:  510:  //set winners in array to 1 and rest to 0
    #####:  511:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  512:    {
    #####:  513:      if ( players[i] == highScore )
        -:  514:	{
    #####:  515:	  players[i] = 1;
        -:  516:	}
        -:  517:      else
        -:  518:	{
    #####:  519:	  players[i] = 0;
        -:  520:	}
        -:  521:    }
        -:  522:
    #####:  523:  return 0;
        -:  524:}
        -:  525:
       35:  526:int drawCard(int player, struct gameState *state)
        -:  527:{	int count;
        -:  528:  int deckCounter;
       35:  529:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  530:    
        -:  531:    //Step 1 Shuffle the discard pile back into a deck
        -:  532:    int i;
        -:  533:    //Move discard to deck
    #####:  534:    for (i = 0; i < state->discardCount[player];i++){
    #####:  535:      state->deck[player][i] = state->discard[player][i];
    #####:  536:      state->discard[player][i] = -1;
        -:  537:    }
        -:  538:
    #####:  539:    state->deckCount[player] = state->discardCount[player];
    #####:  540:    state->discardCount[player] = 0;//Reset discard
        -:  541:
        -:  542:    //Shufffle the deck
    #####:  543:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  544:   
        -:  545:    if (DEBUG){//Debug statements
        -:  546:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  547:    }
        -:  548:    
    #####:  549:    state->discardCount[player] = 0;
        -:  550:
        -:  551:    //Step 2 Draw Card
    #####:  552:    count = state->handCount[player];//Get current player's hand count
        -:  553:    
        -:  554:    if (DEBUG){//Debug statements
        -:  555:      printf("Current hand count: %d\n", count);
        -:  556:    }
        -:  557:    
    #####:  558:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  559:
    #####:  560:    if (deckCounter == 0)
    #####:  561:      return -1;
        -:  562:
    #####:  563:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  564:    state->deckCount[player]--;
    #####:  565:    state->handCount[player]++;//Increment hand count
        -:  566:  }
        -:  567:
        -:  568:  else{
       35:  569:    int count = state->handCount[player];//Get current hand count for player
        -:  570:    int deckCounter;
        -:  571:    if (DEBUG){//Debug statements
        -:  572:      printf("Current hand count: %d\n", count);
        -:  573:    }
        -:  574:
       35:  575:    deckCounter = state->deckCount[player];//Create holder for the deck count
       35:  576:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
       35:  577:    state->deckCount[player]--;
       35:  578:    state->handCount[player]++;//Increment hand count
        -:  579:  }
        -:  580:
       35:  581:  return 0;
        -:  582:}
        -:  583:
       56:  584:int getCost(int cardNumber)
        -:  585:{
       56:  586:  switch( cardNumber ) 
        -:  587:    {
        -:  588:    case curse:
        2:  589:      return 0;
        -:  590:    case estate:
        2:  591:      return 2;
        -:  592:    case duchy:
        2:  593:      return 5;
        -:  594:    case province:
        2:  595:      return 8;
        -:  596:    case copper:
        2:  597:      return 0;
        -:  598:    case silver:
        2:  599:      return 3;
        -:  600:    case gold:
        2:  601:      return 6;
        -:  602:    case adventurer:
        2:  603:      return 6;
        -:  604:    case council_room:
        2:  605:      return 5;
        -:  606:    case feast:
        2:  607:      return 4;
        -:  608:    case gardens:
        2:  609:      return 4;
        -:  610:    case mine:
        2:  611:      return 5;
        -:  612:    case remodel:
        2:  613:      return 4;
        -:  614:    case smithy:
        2:  615:      return 4;
        -:  616:    case village:
        2:  617:      return 3;
        -:  618:    case baron:
        2:  619:      return 4;
        -:  620:    case great_hall:
        2:  621:      return 3;
        -:  622:    case minion:
        2:  623:      return 5;
        -:  624:    case steward:
        2:  625:      return 3;
        -:  626:    case tribute:
        2:  627:      return 5;
        -:  628:    case ambassador:
        2:  629:      return 3;
        -:  630:    case cutpurse:
        2:  631:      return 4;
        -:  632:    case embargo: 
        2:  633:      return 2;
        -:  634:    case outpost:
        2:  635:      return 5;
        -:  636:    case salvager:
        2:  637:      return 4;
        -:  638:    case sea_hag:
        2:  639:      return 4;
        -:  640:    case treasure_map:
        2:  641:      return 4;
        -:  642:    }
        -:  643:	
        2:  644:  return -1;
        -:  645:}
        -:  646:
        -:  647:
    #####:  648:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  649:{
        -:  650:  int i;
        -:  651:  int j;
        -:  652://  int k;
        -:  653:  int x;
        -:  654:  int index;
    #####:  655:  int currentPlayer = whoseTurn(state);
    #####:  656:  int nextPlayer = currentPlayer + 1;
        -:  657:
    #####:  658:  int tributeRevealedCards[2] = {-1, -1};
        -:  659:  int temphand[MAX_HAND];// moved above the if statement
    #####:  660:  int drawntreasure=0;
        -:  661:  int cardDrawn;
    #####:  662:  int z = 0;// this is the counter for the temp hand
    #####:  663:  if (nextPlayer > (state->numPlayers - 1)){
    #####:  664:    nextPlayer = 0;
        -:  665:  }
        -:  666:  
        -:  667:	
        -:  668:  //uses switch to select card and perform actions
    #####:  669:  switch( card ) 
        -:  670:    {
        -:  671:    case adventurer:
    #####:  672:	 return playAdventurer(state);
        -:  673:			
        -:  674:    case council_room:
    #####:  675:	  return playCouncil_Room(state, handPos);
        -:  676:			
        -:  677:    case feast:
        -:  678:      //gain card with cost up to 5
        -:  679:      //Backup hand
    #####:  680:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  681:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  682:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  683:      }
        -:  684:      //Backup hand
        -:  685:
        -:  686:      //Update Coins for Buy
    #####:  687:      updateCoins(currentPlayer, state, 5);
    #####:  688:      x = 1;//Condition to loop on
    #####:  689:      while( x == 1) {//Buy one card
    #####:  690:	if (supplyCount(choice1, state) <= 0){
        -:  691:	  if (DEBUG)
        -:  692:	    printf("None of that card left, sorry!\n");
        -:  693:
        -:  694:	  if (DEBUG){
        -:  695:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  696:	  }
        -:  697:	}
    #####:  698:	else if (state->coins < getCost(choice1)){
    #####:  699:	  printf("That card is too expensive!\n");
        -:  700:
        -:  701:	  if (DEBUG){
        -:  702:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  703:	  }
        -:  704:	}
        -:  705:	else{
        -:  706:
        -:  707:	  if (DEBUG){
        -:  708:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  709:	  }
        -:  710:
    #####:  711:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  712:	  x = 0;//No more buying cards
        -:  713:
        -:  714:	  if (DEBUG){
        -:  715:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  716:	  }
        -:  717:
        -:  718:	}
        -:  719:      }     
        -:  720:
        -:  721:      //Reset Hand
    #####:  722:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  723:	state->hand[currentPlayer][i] = temphand[i];
    #####:  724:	temphand[i] = -1;
        -:  725:      }
        -:  726:      //Reset Hand
        -:  727:      			
    #####:  728:      return 0;
        -:  729:			
        -:  730:    case gardens:
    #####:  731:      return -1;
        -:  732:			
        -:  733:    case mine:
    #####:  734:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  735:
    #####:  736:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  737:	{
    #####:  738:	  return -1;
        -:  739:	}
        -:  740:		
    #####:  741:      if (choice2 > treasure_map || choice2 < curse)
        -:  742:	{
    #####:  743:	  return -1;
        -:  744:	}
        -:  745:
    #####:  746:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
        -:  747:	{
    #####:  748:	  return -1;
        -:  749:	}
        -:  750:
    #####:  751:      gainCard(choice2, state, 2, currentPlayer);
        -:  752:
        -:  753:      //discard card from hand
    #####:  754:      discardCard(handPos, currentPlayer, state, 0);
        -:  755:
        -:  756:      //discard trashed card
    #####:  757:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  758:	{
    #####:  759:	  if (state->hand[currentPlayer][i] == j)
        -:  760:	    {
    #####:  761:	      discardCard(i, currentPlayer, state, 0);			
    #####:  762:	      break;
        -:  763:	    }
        -:  764:	}
        -:  765:			
    #####:  766:      return 0;
        -:  767:			
        -:  768:    case remodel:
    #####:  769:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  770:
    #####:  771:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  772:	{
    #####:  773:	  return -1;
        -:  774:	}
        -:  775:
    #####:  776:      gainCard(choice2, state, 0, currentPlayer);
        -:  777:
        -:  778:      //discard card from hand
    #####:  779:      discardCard(handPos, currentPlayer, state, 0);
        -:  780:
        -:  781:      //discard trashed card
    #####:  782:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  783:	{
    #####:  784:	  if (state->hand[currentPlayer][i] == j)
        -:  785:	    {
    #####:  786:	      discardCard(i, currentPlayer, state, 0);			
    #####:  787:	      break;
        -:  788:	    }
        -:  789:	}
        -:  790:
        -:  791:
    #####:  792:      return 0;
        -:  793:		
        -:  794:    case smithy:
    #####:  795:	  return playSmithy(state, handPos);
        -:  796:      /* //+3 Cards
        -:  797:      for (i = 0; i < 3; i++)
        -:  798:	  {
        -:  799:	    drawCard(currentPlayer, state);
        -:  800:	  }
        -:  801:			
        -:  802:      //discard card from hand
        -:  803:      discardCard(handPos, currentPlayer, state, 0);
        -:  804:      return 0; */
        -:  805:		
        -:  806:    case village:
    #####:  807:        return playVillage(state, handPos);
        -:  808:      /*
        -:  809:      //+1 Card
        -:  810:      drawCard(currentPlayer, state);
        -:  811:			
        -:  812:      //+2 Actions
        -:  813:      state->numActions = state->numActions + 2;
        -:  814:			
        -:  815:      //discard played card from hand
        -:  816:      discardCard(handPos, currentPlayer, state, 0);
        -:  817:      return 0;
        -:  818:       */	
        -:  819:    case baron:
    #####:  820:      state->numBuys++;//Increase buys by 1!
    #####:  821:      if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  822:	int p = 0;//Iterator for hand!
    #####:  823:	int card_not_discarded = 1;//Flag for discard set!
    #####:  824:	while(card_not_discarded){
    #####:  825:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
    #####:  826:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  827:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  828:	    state->discardCount[currentPlayer]++;
    #####:  829:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:  830:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  831:	    }
    #####:  832:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  833:	    state->handCount[currentPlayer]--;
    #####:  834:	    card_not_discarded = 0;//Exit the loop
        -:  835:	  }
    #####:  836:	  else if (p > state->handCount[currentPlayer]){
        -:  837:	    if(DEBUG) {
        -:  838:	      printf("No estate cards in your hand, invalid choice\n");
        -:  839:	      printf("Must gain an estate if there are any\n");
        -:  840:	    }
    #####:  841:	    if (supplyCount(estate, state) > 0){
    #####:  842:	      gainCard(estate, state, 0, currentPlayer);
    #####:  843:	      state->supplyCount[estate]--;//Decrement estates
    #####:  844:	      if (supplyCount(estate, state) == 0){
    #####:  845:		isGameOver(state);
        -:  846:	      }
        -:  847:	    }
    #####:  848:	    card_not_discarded = 0;//Exit the loop
        -:  849:	  }
        -:  850:			    
        -:  851:	  else{
    #####:  852:	    p++;//Next card
        -:  853:	  }
        -:  854:	}
        -:  855:      }
        -:  856:			    
        -:  857:      else{
    #####:  858:	if (supplyCount(estate, state) > 0){
    #####:  859:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  860:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  861:	  if (supplyCount(estate, state) == 0){
    #####:  862:	    isGameOver(state);
        -:  863:	  }
        -:  864:	}
        -:  865:      }
        -:  866:	    
        -:  867:      
    #####:  868:      return 0;
        -:  869:		
        -:  870:    case great_hall:
        -:  871:      //+1 Card
    #####:  872:      drawCard(currentPlayer, state);
        -:  873:			
        -:  874:      //+1 Actions
    #####:  875:      state->numActions++;
        -:  876:			
        -:  877:      //discard card from hand
    #####:  878:      discardCard(handPos, currentPlayer, state, 0);
    #####:  879:      return 0;
        -:  880:		
        -:  881:    case minion:
        -:  882:      //+1 action
    #####:  883:      state->numActions++;
        -:  884:			
        -:  885:      //discard card from hand
    #####:  886:      discardCard(handPos, currentPlayer, state, 0);
        -:  887:			
    #####:  888:      if (choice1)		//+2 coins
        -:  889:	{
    #####:  890:	  state->coins = state->coins + 2;
        -:  891:	}
        -:  892:			
    #####:  893:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  894:	{
        -:  895:	  //discard hand
    #####:  896:	  while(numHandCards(state) > 0)
        -:  897:	    {
    #####:  898:	      discardCard(handPos, currentPlayer, state, 0);
        -:  899:	    }
        -:  900:				
        -:  901:	  //draw 4
    #####:  902:	  for (i = 0; i < 4; i++)
        -:  903:	    {
    #####:  904:	      drawCard(currentPlayer, state);
        -:  905:	    }
        -:  906:				
        -:  907:	  //other players discard hand and redraw if hand size > 4
    #####:  908:	  for (i = 0; i < state->numPlayers; i++)
        -:  909:	    {
    #####:  910:	      if (i != currentPlayer)
        -:  911:		{
    #####:  912:		  if ( state->handCount[i] > 4 )
        -:  913:		    {
        -:  914:		      //discard hand
    #####:  915:		      while( state->handCount[i] > 0 )
        -:  916:			{
    #####:  917:			  discardCard(handPos, i, state, 0);
        -:  918:			}
        -:  919:							
        -:  920:		      //draw 4
    #####:  921:		      for (j = 0; j < 4; j++)
        -:  922:			{
    #####:  923:			  drawCard(i, state);
        -:  924:			}
        -:  925:		    }
        -:  926:		}
        -:  927:	    }
        -:  928:				
        -:  929:	}
    #####:  930:      return 0;
        -:  931:		
        -:  932:    case steward:
    #####:  933:	  return playSteward(state, handPos, choice1, choice2, choice3);
        -:  934:
        -:  935:		
        -:  936:    case tribute:
    #####:  937:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####:  938:	if (state->deckCount[nextPlayer] > 0){
    #####:  939:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  940:	  state->deckCount[nextPlayer]--;
        -:  941:	}
    #####:  942:	else if (state->discardCount[nextPlayer] > 0){
    #####:  943:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  944:	  state->discardCount[nextPlayer]--;
        -:  945:	}
        -:  946:	else{
        -:  947:	  //No Card to Reveal
        -:  948:	  if (DEBUG){
        -:  949:	    printf("No cards to reveal\n");
        -:  950:	  }
        -:  951:	}
        -:  952:      }
        -:  953:	    
        -:  954:      else{
    #####:  955:	if (state->deckCount[nextPlayer] == 0){
    #####:  956:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####:  957:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  958:	    state->deckCount[nextPlayer]++;
    #####:  959:	    state->discard[nextPlayer][i] = -1;
    #####:  960:	    state->discardCount[nextPlayer]--;
        -:  961:	  }
        -:  962:			    
    #####:  963:	  shuffle(nextPlayer,state);//Shuffle the deck
        -:  964:	} 
    #####:  965:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  966:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  967:	state->deckCount[nextPlayer]--;
    #####:  968:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  969:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  970:	state->deckCount[nextPlayer]--;
        -:  971:      }    
        -:  972:		       
    #####:  973:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####:  974:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  975:	state->playedCardCount++;
    #####:  976:	tributeRevealedCards[1] = -1;
        -:  977:      } 
        -:  978:
    #####:  979:      for (i = 0; i <= 2; i ++){
    #####:  980:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####:  981:	  state->coins += 2;
        -:  982:	}
        -:  983:		    
    #####:  984:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####:  985:	  drawCard(currentPlayer, state);
    #####:  986:	  drawCard(currentPlayer, state);
        -:  987:	}
        -:  988:	else{//Action Card
    #####:  989:	  state->numActions = state->numActions + 2;
        -:  990:	}
        -:  991:      }
        -:  992:	    
    #####:  993:      return 0;
        -:  994:		
        -:  995:    case ambassador:
    #####:  996:      j = 0;		//used to check if player has enough cards to discard
        -:  997:
    #####:  998:      if (choice2 > 2 || choice2 < 0)
        -:  999:	{
    #####: 1000:	  return -1;				
        -: 1001:	}
        -: 1002:
    #####: 1003:      if (choice1 == handPos)
        -: 1004:	{
    #####: 1005:	  return -1;
        -: 1006:	}
        -: 1007:
    #####: 1008:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1009:	{
    #####: 1010:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1011:	    {
    #####: 1012:	      j++;
        -: 1013:	    }
        -: 1014:	}
    #####: 1015:      if (j < choice2)
        -: 1016:	{
    #####: 1017:	  return -1;				
        -: 1018:	}
        -: 1019:
        -: 1020:      if (DEBUG) 
        -: 1021:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1022:
        -: 1023:      //increase supply count for choosen card by amount being discarded
    #####: 1024:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1025:			
        -: 1026:      //each other player gains a copy of revealed card
    #####: 1027:      for (i = 0; i < state->numPlayers; i++)
        -: 1028:	{
    #####: 1029:	  if (i != currentPlayer)
        -: 1030:	    {
    #####: 1031:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1032:	    }
        -: 1033:	}
        -: 1034:
        -: 1035:      //discard played card from hand
    #####: 1036:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1037:
        -: 1038:      //trash copies of cards returned to supply
    #####: 1039:      for (j = 0; j < choice2; j++)
        -: 1040:	{
    #####: 1041:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1042:	    {
    #####: 1043:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1044:		{
    #####: 1045:		  discardCard(i, currentPlayer, state, 1);
    #####: 1046:		  break;
        -: 1047:		}
        -: 1048:	    }
        -: 1049:	}			
        -: 1050:
    #####: 1051:      return 0;
        -: 1052:		
        -: 1053:    case cutpurse:
        -: 1054:
        -: 1055:/*       updateCoins(currentPlayer, state, 2);
        -: 1056:      for (i = 0; i < state->numPlayers; i++)
        -: 1057:	{
        -: 1058:	  if (i != currentPlayer)
        -: 1059:	    {
        -: 1060:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1061:		{
        -: 1062:		  if (state->hand[i][j] == copper)
        -: 1063:		    {
        -: 1064:		      discardCard(j, i, state, 0);
        -: 1065:		      break;
        -: 1066:		    }
        -: 1067:		  if (j == state->handCount[i])
        -: 1068:		    {
        -: 1069:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1070:			{
        -: 1071:			  if (DEBUG)
        -: 1072:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1073:			}	
        -: 1074:		      break;
        -: 1075:		    }		
        -: 1076:		}
        -: 1077:					
        -: 1078:	    }
        -: 1079:				
        -: 1080:	}				
        -: 1081:
        -: 1082:      //discard played card from hand
        -: 1083:      discardCard(handPos, currentPlayer, state, 0); */			
        -: 1084:
    #####: 1085:      return playCutpurse(state, handPos);
        -: 1086:
        -: 1087:		
        -: 1088:    case embargo: 
        -: 1089:      //+2 Coins
    #####: 1090:      state->coins = state->coins + 2;
        -: 1091:			
        -: 1092:      //see if selected pile is in play
    #####: 1093:      if ( state->supplyCount[choice1] == -1 )
        -: 1094:	{
    #####: 1095:	  return -1;
        -: 1096:	}
        -: 1097:			
        -: 1098:      //add embargo token to selected supply pile
    #####: 1099:      state->embargoTokens[choice1]++;
        -: 1100:			
        -: 1101:      //trash card
    #####: 1102:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1103:      return 0;
        -: 1104:		
        -: 1105:    case outpost:
        -: 1106:      //set outpost flag
    #####: 1107:      state->outpostPlayed++;
        -: 1108:			
        -: 1109:      //discard card
    #####: 1110:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1111:      return 0;
        -: 1112:		
        -: 1113:    case salvager:
        -: 1114:      //+1 buy
    #####: 1115:      state->numBuys++;
        -: 1116:			
    #####: 1117:      if (choice1)
        -: 1118:	{
        -: 1119:	  //gain coins equal to trashed card
    #####: 1120:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1121:	  //trash card
    #####: 1122:	  discardCard(choice1, currentPlayer, state, 1);	
        -: 1123:	}
        -: 1124:			
        -: 1125:      //discard card
    #####: 1126:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1127:      return 0;
        -: 1128:		
        -: 1129:    case sea_hag:
    #####: 1130:      for (i = 0; i < state->numPlayers; i++){
    #####: 1131:	if (i != currentPlayer){
    #####: 1132:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1133:	  state->discardCount[i]++;
    #####: 1134:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1135:	}
        -: 1136:      }
    #####: 1137:      return 0;
        -: 1138:		
        -: 1139:    case treasure_map:
        -: 1140:      //search hand for another treasure_map
    #####: 1141:      index = -1;
    #####: 1142:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1143:	{
    #####: 1144:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1145:	    {
    #####: 1146:	      index = i;
    #####: 1147:	      break;
        -: 1148:	    }
        -: 1149:	}
    #####: 1150:      if (index > -1)
        -: 1151:	{
        -: 1152:	  //trash both treasure cards
    #####: 1153:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1154:	  discardCard(index, currentPlayer, state, 1);
        -: 1155:
        -: 1156:	  //gain 4 Gold cards
    #####: 1157:	  for (i = 0; i < 4; i++)
        -: 1158:	    {
    #####: 1159:	      gainCard(gold, state, 1, currentPlayer);
        -: 1160:	    }
        -: 1161:				
        -: 1162:	  //return success
    #####: 1163:	  return 1;
        -: 1164:	}
        -: 1165:			
        -: 1166:      //no second treasure_map found in hand
    #####: 1167:      return -1;
        -: 1168:    }
        -: 1169:	
    #####: 1170:  return -1;
        -: 1171:}
        -: 1172:
    #####: 1173:int playAdventurer(struct gameState *state){
    #####: 1174:	int drawntreasure = 0;
        -: 1175:	int cardDrawn;
    #####: 1176:	int currentPlayer = whoseTurn(state);
        -: 1177:    int temphand[MAX_HAND];// moved above the if statement
    #####: 1178:    int z = 0;// this is the counter for the temp hand
        -: 1179:
        -: 1180:	
    #####: 1181:	while(drawntreasure<3){
    #####: 1182:		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
    #####: 1183:		  shuffle(currentPlayer, state);
        -: 1184:		}
    #####: 1185:		drawCard(currentPlayer, state);
    #####: 1186:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####: 1187:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####: 1188:		  drawntreasure++;
        -: 1189:		else{
    #####: 1190:		  temphand[z]=cardDrawn;
    #####: 1191:		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####: 1192:		  z++;
        -: 1193:		}
        -: 1194:	  }
    #####: 1195:	  while(z-1>=0){
    #####: 1196:		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####: 1197:	   z=z-1;
        -: 1198:	  }
        -: 1199:	  
    #####: 1200:	return 0;
        -: 1201:}
        -: 1202:
        -: 1203://Add 4 cards
    #####: 1204:int playCouncil_Room(struct gameState *state, int handPos){
    #####: 1205:	int currentPlayer = whoseTurn(state);
        -: 1206:	int i;
        -: 1207:  
    #####: 1208:    for (i = 0; i < 5; i++)
        -: 1209:	{
    #####: 1210:	  drawCard(currentPlayer, state);
        -: 1211:	}
        -: 1212:			
        -: 1213:    //+1 Buy
    #####: 1214:    state->numBuys++;
        -: 1215:			
        -: 1216:    //Each other player draws a card
    #####: 1217:    for (i = 0; i < state->numPlayers; i++)
        -: 1218:	{
    #####: 1219:	  if ( i != currentPlayer )
        -: 1220:	  {
    #####: 1221:	    drawCard(i, state);
        -: 1222:	  }
        -: 1223:	}
        -: 1224:			
        -: 1225:    //put played card in played card pile
    #####: 1226:    discardCard(handPos, currentPlayer, state, 0);
    #####: 1227:	return 0;
        -: 1228:}
        -: 1229:
    #####: 1230:int playSmithy(struct gameState *state, int handPos){
        -: 1231:    int i;
    #####: 1232:    int currentPlayer = whoseTurn(state);
        -: 1233:
        -: 1234:    //+3 Cards
    #####: 1235:    for (i = 0; i < 3; i++)
        -: 1236:    {
    #####: 1237:      drawCard(currentPlayer, state);
        -: 1238:    }
        -: 1239:    	
        -: 1240:    //discard card from hand
    #####: 1241:    discardCard(handPos, currentPlayer, state, 0-1);
    #####: 1242:    return 0;
        -: 1243:}
        -: 1244:
    #####: 1245:int playCutpurse(struct gameState *state, int handPos){
        -: 1246:	int i, j, k;
    #####: 1247:	int currentPlayer = whoseTurn(state);
        -: 1248:
        -: 1249:	
    #####: 1250:    updateCoins(currentPlayer, state, 2);
    #####: 1251:    for (i = 0; i < state->numPlayers; i++)
        -: 1252:	{
    #####: 1253:	  if (i != currentPlayer)
        -: 1254:	  {
    #####: 1255:	    for (j = 0; j <= state->handCount[i]; j++){
    #####: 1256:          if (state->hand[i][j] == copper){
    #####: 1257:	        discardCard(j, i, state, 0);
    #####: 1258:		    return -1;
        -: 1259:	      }
    #####: 1260:	      if (j = state->handCount[i]){
    #####: 1261:            for (k = 0; k < state->handCount[i]; k++){
        -: 1262:		      if (DEBUG)
        -: 1263:                printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1264:            }	
    #####: 1265:		  return -1;
        -: 1266:          }		
        -: 1267:		}
        -: 1268:					
        -: 1269:	  }//end != currentPlayer switch		
        -: 1270:	}
        -: 1271:
        -: 1272:    //discard played card from hand
    #####: 1273:	discardCard(handPos, currentPlayer, state, 0);
        -: 1274:	
    #####: 1275:	return 0;
        -: 1276:}
        -: 1277:
    #####: 1278:int playSteward(struct gameState *state, int handPos, int choice1, int choice2, int choice3){
    #####: 1279:  int currentPlayer = whoseTurn(state);
        -: 1280:
    #####: 1281:  if (choice1 == 1) {
        -: 1282:  //+2 cards
    #####: 1283:    drawCard(currentPlayer, state);
    #####: 1284:    drawCard(currentPlayer, state);
        -: 1285:  }
    #####: 1286:  else if (choice1 == 2) {
        -: 1287:  //+2 coins
    #####: 1288:    state->coins = state->coins + 2;
        -: 1289:  }
        -: 1290:  else {
        -: 1291:  //trash 2 cards in hand
    #####: 1292:    discardCard(choice2, currentPlayer, state, 1);
    #####: 1293:    discardCard(choice3, currentPlayer, state, 1);
        -: 1294:  }
        -: 1295:	
        -: 1296:  //discard card from hand
    #####: 1297:  discardCard(handPos, currentPlayer, state, 0);
    #####: 1298:  return 0;
        -: 1299:}
        -: 1300:
    #####: 1301:int playVillage(struct gameState *state, int handPos){
    #####: 1302:    int currentPlayer = whoseTurn(state);
        -: 1303:
        -: 1304:    //+1 Card
    #####: 1305:     drawCard(currentPlayer, state);
        -: 1306:
        -: 1307:     //+2 Actions
    #####: 1308:     state->numActions = state->numActions + 2;
        -: 1309:
        -: 1310:     //discard played card from hand
    #####: 1311:     discardCard(handPos, currentPlayer, state, 0);
    #####: 1312:     return 0;
        -: 1313:}
        -: 1314:
    #####: 1315:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1316:{
        -: 1317:	
        -: 1318:  //if card is not trashed, added to Played pile 
    #####: 1319:  if (trashFlag < 1)
        -: 1320:    {
        -: 1321:      //add card to played pile
    #####: 1322:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1323:      state->playedCardCount++;
        -: 1324:    }
        -: 1325:	
        -: 1326:  //set played card to -1
    #####: 1327:  state->hand[currentPlayer][handPos] = -1;
        -: 1328:	
        -: 1329:  //remove card from player's hand
    #####: 1330:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1331:    {
        -: 1332:      //reduce number of cards in hand
    #####: 1333:      state->handCount[currentPlayer]--;
        -: 1334:    }
    #####: 1335:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1336:    {
        -: 1337:      //reduce number of cards in hand
    #####: 1338:      state->handCount[currentPlayer]--;
        -: 1339:    }
        -: 1340:  else 	
        -: 1341:    {
        -: 1342:      //replace discarded card with last card in hand
    #####: 1343:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1344:      //set last card to -1
    #####: 1345:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1346:      //reduce number of cards in hand
    #####: 1347:      state->handCount[currentPlayer]--;
        -: 1348:    }
        -: 1349:	
    #####: 1350:  return 0;
        -: 1351:}
        -: 1352:
    #####: 1353:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1354:{
        -: 1355:  //Note: supplyPos is enum of choosen card
        -: 1356:	
        -: 1357:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1358:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1359:    {
    #####: 1360:      return -1;
        -: 1361:    }
        -: 1362:	
        -: 1363:  //added card for [whoseTurn] current player:
        -: 1364:  // toFlag = 0 : add to discard
        -: 1365:  // toFlag = 1 : add to deck
        -: 1366:  // toFlag = 2 : add to hand
        -: 1367:
    #####: 1368:  if (toFlag == 1)
        -: 1369:    {
    #####: 1370:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1371:      state->deckCount[player]++;
        -: 1372:    }
    #####: 1373:  else if (toFlag == 2)
        -: 1374:    {
    #####: 1375:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1376:      state->handCount[player]++;
        -: 1377:    }
        -: 1378:  else
        -: 1379:    {
    #####: 1380:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1381:      state->discardCount[player]++;
        -: 1382:    }
        -: 1383:	
        -: 1384:  //decrease number in supply pile
    #####: 1385:  state->supplyCount[supplyPos]--;
        -: 1386:	 
    #####: 1387:  return 0;
        -: 1388:}
        -: 1389:
      811: 1390:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1391:{
        -: 1392:  int i;
        -: 1393:	
        -: 1394:  //reset coin count
      811: 1395:  state->coins = 0;
        -: 1396:
        -: 1397:  //add coins for each Treasure card in player's hand
     3856: 1398:  for (i = 0; i < state->handCount[player]; i++)
        -: 1399:    {
     3045: 1400:      if (state->hand[player][i] == copper)
        -: 1401:	{
     1036: 1402:	  state->coins += 1;
        -: 1403:	}
     2009: 1404:      else if (state->hand[player][i] == silver)
        -: 1405:	{
     1000: 1406:	  state->coins += 2;
        -: 1407:	}
     1009: 1408:      else if (state->hand[player][i] == gold)
        -: 1409:	{
     1000: 1410:	  state->coins += 3;
        -: 1411:	}	
        -: 1412:    }	
        -: 1413:
        -: 1414:  //add bonus
      811: 1415:  state->coins += bonus;
        -: 1416:
      811: 1417:  return 0;
        -: 1418:}
        -: 1419:
        -: 1420:
        -: 1421://end of dominion.c
        -: 1422:

Testing playSmithy() with seed 1234
Game Initialized! :)
Player 1 cards: v: 4 v: 4 v: 4 v: 4 v: 1 

__ALL TESTS PASSED!__

File 'dominion.c'
Lines executed:27.46% of 568
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:9
        -:    0:Programs:5
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
      360:    8:int compare(const void* a, const void* b) {
      360:    9:  if (*(int*)a > *(int*)b)
    #####:   10:    return 1;
      360:   11:  if (*(int*)a < *(int*)b)
       96:   12:    return -1;
      264:   13:  return 0;
        -:   14:}
        -:   15:
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
        -:   21:
    #####:   22:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   23:		  int k8, int k9, int k10) {
    #####:   24:  int* k = malloc(10 * sizeof(int));
    #####:   25:  k[0] = k1;
    #####:   26:  k[1] = k2;
    #####:   27:  k[2] = k3;
    #####:   28:  k[3] = k4;
    #####:   29:  k[4] = k5;
    #####:   30:  k[5] = k6;
    #####:   31:  k[6] = k7;
    #####:   32:  k[7] = k8;
    #####:   33:  k[8] = k9;
    #####:   34:  k[9] = k10;
    #####:   35:  return k;
        -:   36:}
        -:   37:
        9:   38:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   39:		   struct gameState *state) {
        -:   40:
        -:   41:  int i;
        -:   42:  int j;
        -:   43:  int it;			
        -:   44:  //set up random number generator
        9:   45:  SelectStream(1);
        9:   46:  PutSeed((long)randomSeed);
        -:   47:  
        -:   48:  //check number of players
        9:   49:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   50:    {
    #####:   51:      return -1;
        -:   52:    }
        -:   53:
        -:   54:  //set number of players
        9:   55:  state->numPlayers = numPlayers;
        -:   56:
        -:   57:  //check selected kingdom cards are different
       99:   58:  for (i = 0; i < 10; i++)
        -:   59:    {
      990:   60:      for (j = 0; j < 10; j++)
        -:   61:        {
      900:   62:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   63:	    {
    #####:   64:	      return -1;
        -:   65:	    }
        -:   66:        }
        -:   67:    }
        -:   68:
        -:   69:
        -:   70:  //initialize supply
        -:   71:  ///////////////////////////////
        -:   72:
        -:   73:  //set number of Curse cards
        9:   74:  if (numPlayers == 2)
        -:   75:    {
        6:   76:      state->supplyCount[curse] = 10;
        -:   77:    }
        3:   78:  else if (numPlayers == 3)
        -:   79:    {
    #####:   80:      state->supplyCount[curse] = 20;
        -:   81:    }
        -:   82:  else
        -:   83:    {
        3:   84:      state->supplyCount[curse] = 30;
        -:   85:    }
        -:   86:
        -:   87:  //set number of Victory cards
        9:   88:  if (numPlayers == 2)
        -:   89:    {
        6:   90:      state->supplyCount[estate] = 8;
        6:   91:      state->supplyCount[duchy] = 8;
        6:   92:      state->supplyCount[province] = 8;
        -:   93:    }
        -:   94:  else
        -:   95:    {
        3:   96:      state->supplyCount[estate] = 12;
        3:   97:      state->supplyCount[duchy] = 12;
        3:   98:      state->supplyCount[province] = 12;
        -:   99:    }
        -:  100:
        -:  101:  //set number of Treasure cards
        9:  102:  state->supplyCount[copper] = 60 - (7 * numPlayers);
        9:  103:  state->supplyCount[silver] = 40;
        9:  104:  state->supplyCount[gold] = 30;
        -:  105:
        -:  106:  //set number of Kingdom cards
      189:  107:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  108:    {
     1485:  109:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  110:	{
     1395:  111:	  if (kingdomCards[j] == i)
        -:  112:	    {
        -:  113:	      //check if card is a 'Victory' Kingdom card
       90:  114:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  115:		{
       18:  116:		  if (numPlayers == 2){ 
        6:  117:		    state->supplyCount[i] = 8; 
        -:  118:		  }
        3:  119:		  else{ state->supplyCount[i] = 12; }
        -:  120:		}
        -:  121:	      else
        -:  122:		{
       81:  123:		  state->supplyCount[i] = 10;
        -:  124:		}
       90:  125:	      break;
        -:  126:	    }
        -:  127:	  else    //card is not in the set choosen for the game
        -:  128:	    {
     1305:  129:	      state->supplyCount[i] = -1;
        -:  130:	    }
        -:  131:	}
        -:  132:
        -:  133:    }
        -:  134:
        -:  135:  ////////////////////////
        -:  136:  //supply intilization complete
        -:  137:
        -:  138:  //set player decks
       33:  139:  for (i = 0; i < numPlayers; i++)
        -:  140:    {
       24:  141:      state->deckCount[i] = 0;
       96:  142:      for (j = 0; j < 3; j++)
        -:  143:	{
       72:  144:	  state->deck[i][j] = estate;
       72:  145:	  state->deckCount[i]++;
        -:  146:	}
      192:  147:      for (j = 3; j < 10; j++)
        -:  148:	{
      168:  149:	  state->deck[i][j] = copper;
      168:  150:	  state->deckCount[i]++;		
        -:  151:	}
        -:  152:    }
        -:  153:
        -:  154:  //shuffle player decks
       33:  155:  for (i = 0; i < numPlayers; i++)
        -:  156:    {
       24:  157:      if ( shuffle(i, state) < 0 )
        -:  158:	{
    #####:  159:	  return -1;
        -:  160:	}
        -:  161:    }
        -:  162:
        -:  163:  //draw player hands
       33:  164:  for (i = 0; i < numPlayers; i++)
        -:  165:    {  
        -:  166:      //initialize hand size to zero
       24:  167:      state->handCount[i] = 0;
       24:  168:      state->discardCount[i] = 0;
        -:  169:      //draw 5 cards
        -:  170:      // for (j = 0; j < 5; j++)
        -:  171:      //	{
        -:  172:      //	  drawCard(i, state);
        -:  173:      //	}
        -:  174:    }
        -:  175:  
        -:  176:  //set embargo tokens to 0 for all supply piles
      252:  177:  for (i = 0; i <= treasure_map; i++)
        -:  178:    {
      243:  179:      state->embargoTokens[i] = 0;
        -:  180:    }
        -:  181:
        -:  182:  //initialize first player's turn
        9:  183:  state->outpostPlayed = 0;
        9:  184:  state->phase = 0;
        9:  185:  state->numActions = 1;
        9:  186:  state->numBuys = 1;
        9:  187:  state->playedCardCount = 0;
        9:  188:  state->whoseTurn = 0;
        9:  189:  state->handCount[state->whoseTurn] = 0;
        -:  190:  //int it; move to top
        -:  191:
        -:  192:  //Moved draw cards to here, only drawing at the start of a turn
       54:  193:  for (it = 0; it < 5; it++){
       45:  194:    drawCard(state->whoseTurn, state);
        -:  195:  }
        -:  196:
        9:  197:  updateCoins(state->whoseTurn, state, 0);
        -:  198:
        9:  199:  return 0;
        -:  200:}
        -:  201:
       24:  202:int shuffle(int player, struct gameState *state) {
        -:  203: 
        -:  204:
        -:  205:  int newDeck[MAX_DECK];
       24:  206:  int newDeckPos = 0;
        -:  207:  int card;
        -:  208:  int i;
        -:  209:
       24:  210:  if (state->deckCount[player] < 1)
    #####:  211:    return -1;
       24:  212:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  213:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  214:
      288:  215:  while (state->deckCount[player] > 0) {
      240:  216:    card = floor(Random() * state->deckCount[player]);
      240:  217:    newDeck[newDeckPos] = state->deck[player][card];
      240:  218:    newDeckPos++;
      855:  219:    for (i = card; i < state->deckCount[player]-1; i++) {
      615:  220:      state->deck[player][i] = state->deck[player][i+1];
        -:  221:    }
      240:  222:    state->deckCount[player]--;
        -:  223:  }
      264:  224:  for (i = 0; i < newDeckPos; i++) {
      240:  225:    state->deck[player][i] = newDeck[i];
      240:  226:    state->deckCount[player]++;
        -:  227:  }
        -:  228:
       24:  229:  return 0;
        -:  230:}
        -:  231:
    #####:  232:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  233:{	
        -:  234:  int card;
    #####:  235:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  236:
        -:  237:  //check if it is the right phase
    #####:  238:  if (state->phase != 0)
        -:  239:    {
    #####:  240:      return -1;
        -:  241:    }
        -:  242:	
        -:  243:  //check if player has enough actions
    #####:  244:  if ( state->numActions < 1 )
        -:  245:    {
    #####:  246:      return -1;
        -:  247:    }
        -:  248:	
        -:  249:  //get card played
    #####:  250:  card = handCard(handPos, state);
        -:  251:	
        -:  252:  //check if selected card is an action
    #####:  253:  if ( card < adventurer || card > treasure_map )
        -:  254:    {
    #####:  255:      return -1;
        -:  256:    }
        -:  257:	
        -:  258:  //play card
    #####:  259:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  260:    {
    #####:  261:      return -1;
        -:  262:    }
        -:  263:	
        -:  264:  //reduce number of actions
    #####:  265:  state->numActions--;
        -:  266:
        -:  267:  //update coins (Treasure cards may be added with card draws)
    #####:  268:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  269:	
    #####:  270:  return 0;
        -:  271:}
        -:  272:
    #####:  273:int buyCard(int supplyPos, struct gameState *state) {
        -:  274:  int who;
        -:  275:  if (DEBUG){
        -:  276:    printf("Entering buyCard...\n");
        -:  277:  }
        -:  278:
        -:  279:  // I don't know what to do about the phase thing.
        -:  280:
    #####:  281:  who = state->whoseTurn;
        -:  282:
    #####:  283:  if (state->numBuys < 1){
        -:  284:    if (DEBUG)
        -:  285:      printf("You do not have any buys left\n");
    #####:  286:    return -1;
    #####:  287:  } else if (supplyCount(supplyPos, state) <1){
        -:  288:    if (DEBUG)
        -:  289:      printf("There are not any of that type of card left\n");
    #####:  290:    return -1;
    #####:  291:  } else if (state->coins < getCost(supplyPos)){
        -:  292:    if (DEBUG) 
        -:  293:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  294:    return -1;
        -:  295:  } else {
    #####:  296:    state->phase=1;
        -:  297:    //state->supplyCount[supplyPos]--;
    #####:  298:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  299:  
    #####:  300:    state->coins = (state->coins) - (getCost(supplyPos));
    #####:  301:    state->numBuys--;
        -:  302:    if (DEBUG)
        -:  303:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  304:  }
        -:  305:
        -:  306:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  307:  //state->discardCount[who]++;
        -:  308:    
    #####:  309:  return 0;
        -:  310:}
        -:  311:
    #####:  312:int numHandCards(struct gameState *state) {
    #####:  313:  return state->handCount[ whoseTurn(state) ];
        -:  314:}
        -:  315:
    #####:  316:int handCard(int handPos, struct gameState *state) {
    #####:  317:  int currentPlayer = whoseTurn(state);
    #####:  318:  return state->hand[currentPlayer][handPos];
        -:  319:}
        -:  320:
    #####:  321:int supplyCount(int card, struct gameState *state) {
    #####:  322:  return state->supplyCount[card];
        -:  323:}
        -:  324:
    #####:  325:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  326:  int i;
    #####:  327:  int count = 0;
        -:  328:
    #####:  329:  for (i = 0; i < state->deckCount[player]; i++)
        -:  330:    {
    #####:  331:      if (state->deck[player][i] == card) count++;
        -:  332:    }
        -:  333:
    #####:  334:  for (i = 0; i < state->handCount[player]; i++)
        -:  335:    {
    #####:  336:      if (state->hand[player][i] == card) count++;
        -:  337:    }
        -:  338:
    #####:  339:  for (i = 0; i < state->discardCount[player]; i++)
        -:  340:    {
    #####:  341:      if (state->discard[player][i] == card) count++;
        -:  342:    }
        -:  343:
    #####:  344:  return count;
        -:  345:}
        -:  346:
   493036:  347:int whoseTurn(struct gameState *state) {
   493036:  348:  return state->whoseTurn;
        -:  349:}
        -:  350:
    #####:  351:int endTurn(struct gameState *state) {
        -:  352:  int k;
        -:  353:  int i;
    #####:  354:  int currentPlayer = whoseTurn(state);
        -:  355:  
        -:  356:  //Discard hand
    #####:  357:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  358:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  359:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  360:  }
    #####:  361:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  362:    
        -:  363:  //Code for determining the player
    #####:  364:  if (currentPlayer < (state->numPlayers - 1)){ 
    #####:  365:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  366:  }
        -:  367:  else{
    #####:  368:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  369:  }
        -:  370:
    #####:  371:  state->outpostPlayed = 0;
    #####:  372:  state->phase = 0;
    #####:  373:  state->numActions = 1;
    #####:  374:  state->coins = 0;
    #####:  375:  state->numBuys = 1;
    #####:  376:  state->playedCardCount = 0;
    #####:  377:  state->handCount[state->whoseTurn] = 0;
        -:  378:
        -:  379:  //int k; move to top
        -:  380:  //Next player draws hand
    #####:  381:  for (k = 0; k < 5; k++){
    #####:  382:    drawCard(state->whoseTurn, state);//Draw a card
        -:  383:  }
        -:  384:
        -:  385:  //Update money
    #####:  386:  updateCoins(state->whoseTurn, state , 0);
        -:  387:
    #####:  388:  return 0;
        -:  389:}
        -:  390:
      156:  391:int isGameOver(struct gameState *state) {
        -:  392:  int i;
        -:  393:  int j;
        -:  394:	
        -:  395:  //if stack of Province cards is empty, the game ends
      156:  396:  if (state->supplyCount[province] == 0)
        -:  397:    {
        6:  398:      return 1;
        -:  399:    }
        -:  400:
        -:  401:  //if three supply pile are at 0, the game ends
      150:  402:    j = 0;
     3900:  403:    for (i = 0; i < 25; i++)
        -:  404:    {
     3750:  405:      if (state->supplyCount[i] == 0)
        -:  406:        {
      258:  407:          j++;
        -:  408:        }
        -:  409:    }
      150:  410:    if ( j >= 3)
        -:  411:    {
       40:  412:      return 1;
        -:  413:    }
        -:  414:
      110:  415:  return 0;
        -:  416:}
        -:  417:
    #####:  418:int scoreFor (int player, struct gameState *state) {
        -:  419:
        -:  420:  int i;
    #####:  421:  int score = 0;
        -:  422:  //score from hand
    #####:  423:  for (i = 0; i < state->handCount[player]; i++)
        -:  424:    {
    #####:  425:      if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  426:      if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  427:      if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  428:      if (state->hand[player][i] == province) { score = score + 6; };
    #####:  429:      if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  430:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  431:    }
        -:  432:
        -:  433:  //score from discard
    #####:  434:  for (i = 0; i < state->discardCount[player]; i++)
        -:  435:    {
    #####:  436:      if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  437:      if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  438:      if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  439:      if (state->discard[player][i] == province) { score = score + 6; };
    #####:  440:      if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  441:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  442:    }
        -:  443:
        -:  444:  //score from deck
    #####:  445:  for (i = 0; i < state->discardCount[player]; i++)
        -:  446:    {
    #####:  447:      if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  448:      if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  449:      if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  450:      if (state->deck[player][i] == province) { score = score + 6; };
    #####:  451:      if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  452:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  453:    }
        -:  454:
    #####:  455:  return score;
        -:  456:}
        -:  457:
    #####:  458:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  459:  int i;	
        -:  460:  int j;
        -:  461:  int highScore;
        -:  462:  int currentPlayer;
        -:  463:
        -:  464:  //get score for each player
    #####:  465:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  466:    {
        -:  467:      //set unused player scores to -9999
    #####:  468:      if (i >= state->numPlayers)
        -:  469:	{
    #####:  470:	  players[i] = -9999;
        -:  471:	}
        -:  472:      else
        -:  473:	{
    #####:  474:	  players[i] = scoreFor (i, state);
        -:  475:	}
        -:  476:    }
        -:  477:
        -:  478:  //find highest score
    #####:  479:  j = 0;
    #####:  480:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  481:    {
    #####:  482:      if (players[i] > players[j])
        -:  483:	{
    #####:  484:	  j = i;
        -:  485:	}
        -:  486:    }
    #####:  487:  highScore = players[j];
        -:  488:
        -:  489:  //add 1 to players who had less turns
    #####:  490:  currentPlayer = whoseTurn(state);
    #####:  491:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  492:    {
    #####:  493:      if ( players[i] == highScore && i > currentPlayer )
        -:  494:	{
    #####:  495:	  players[i]++;
        -:  496:	}
        -:  497:    }
        -:  498:
        -:  499:  //find new highest score
    #####:  500:  j = 0;
    #####:  501:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  502:    {
    #####:  503:      if ( players[i] > players[j] )
        -:  504:	{
    #####:  505:	  j = i;
        -:  506:	}
        -:  507:    }
    #####:  508:  highScore = players[j];
        -:  509:
        -:  510:  //set winners in array to 1 and rest to 0
    #####:  511:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  512:    {
    #####:  513:      if ( players[i] == highScore )
        -:  514:	{
    #####:  515:	  players[i] = 1;
        -:  516:	}
        -:  517:      else
        -:  518:	{
    #####:  519:	  players[i] = 0;
        -:  520:	}
        -:  521:    }
        -:  522:
    #####:  523:  return 0;
        -:  524:}
        -:  525:
  1479117:  526:int drawCard(int player, struct gameState *state)
        -:  527:{	int count;
        -:  528:  int deckCounter;
  1479117:  529:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  530:    
        -:  531:    //Step 1 Shuffle the discard pile back into a deck
        -:  532:    int i;
        -:  533:    //Move discard to deck
    #####:  534:    for (i = 0; i < state->discardCount[player];i++){
    #####:  535:      state->deck[player][i] = state->discard[player][i];
    #####:  536:      state->discard[player][i] = -1;
        -:  537:    }
        -:  538:
    #####:  539:    state->deckCount[player] = state->discardCount[player];
    #####:  540:    state->discardCount[player] = 0;//Reset discard
        -:  541:
        -:  542:    //Shufffle the deck
    #####:  543:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  544:   
        -:  545:    if (DEBUG){//Debug statements
        -:  546:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  547:    }
        -:  548:    
    #####:  549:    state->discardCount[player] = 0;
        -:  550:
        -:  551:    //Step 2 Draw Card
    #####:  552:    count = state->handCount[player];//Get current player's hand count
        -:  553:    
        -:  554:    if (DEBUG){//Debug statements
        -:  555:      printf("Current hand count: %d\n", count);
        -:  556:    }
        -:  557:    
    #####:  558:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  559:
    #####:  560:    if (deckCounter == 0)
    #####:  561:      return -1;
        -:  562:
    #####:  563:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  564:    state->deckCount[player]--;
    #####:  565:    state->handCount[player]++;//Increment hand count
        -:  566:  }
        -:  567:
        -:  568:  else{
  1479117:  569:    int count = state->handCount[player];//Get current hand count for player
        -:  570:    int deckCounter;
        -:  571:    if (DEBUG){//Debug statements
        -:  572:      printf("Current hand count: %d\n", count);
        -:  573:    }
        -:  574:
  1479117:  575:    deckCounter = state->deckCount[player];//Create holder for the deck count
  1479117:  576:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
  1479117:  577:    state->deckCount[player]--;
  1479117:  578:    state->handCount[player]++;//Increment hand count
        -:  579:  }
        -:  580:
  1479117:  581:  return 0;
        -:  582:}
        -:  583:
       56:  584:int getCost(int cardNumber)
        -:  585:{
       56:  586:  switch( cardNumber ) 
        -:  587:    {
        -:  588:    case curse:
        2:  589:      return 0;
        -:  590:    case estate:
        2:  591:      return 2;
        -:  592:    case duchy:
        2:  593:      return 5;
        -:  594:    case province:
        2:  595:      return 8;
        -:  596:    case copper:
        2:  597:      return 0;
        -:  598:    case silver:
        2:  599:      return 3;
        -:  600:    case gold:
        2:  601:      return 6;
        -:  602:    case adventurer:
        2:  603:      return 6;
        -:  604:    case council_room:
        2:  605:      return 5;
        -:  606:    case feast:
        2:  607:      return 4;
        -:  608:    case gardens:
        2:  609:      return 4;
        -:  610:    case mine:
        2:  611:      return 5;
        -:  612:    case remodel:
        2:  613:      return 4;
        -:  614:    case smithy:
        2:  615:      return 4;
        -:  616:    case village:
        2:  617:      return 3;
        -:  618:    case baron:
        2:  619:      return 4;
        -:  620:    case great_hall:
        2:  621:      return 3;
        -:  622:    case minion:
        2:  623:      return 5;
        -:  624:    case steward:
        2:  625:      return 3;
        -:  626:    case tribute:
        2:  627:      return 5;
        -:  628:    case ambassador:
        2:  629:      return 3;
        -:  630:    case cutpurse:
        2:  631:      return 4;
        -:  632:    case embargo: 
        2:  633:      return 2;
        -:  634:    case outpost:
        2:  635:      return 5;
        -:  636:    case salvager:
        2:  637:      return 4;
        -:  638:    case sea_hag:
        2:  639:      return 4;
        -:  640:    case treasure_map:
        2:  641:      return 4;
        -:  642:    }
        -:  643:	
        2:  644:  return -1;
        -:  645:}
        -:  646:
        -:  647:
    #####:  648:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  649:{
        -:  650:  int i;
        -:  651:  int j;
        -:  652://  int k;
        -:  653:  int x;
        -:  654:  int index;
    #####:  655:  int currentPlayer = whoseTurn(state);
    #####:  656:  int nextPlayer = currentPlayer + 1;
        -:  657:
    #####:  658:  int tributeRevealedCards[2] = {-1, -1};
        -:  659:  int temphand[MAX_HAND];// moved above the if statement
    #####:  660:  int drawntreasure=0;
        -:  661:  int cardDrawn;
    #####:  662:  int z = 0;// this is the counter for the temp hand
    #####:  663:  if (nextPlayer > (state->numPlayers - 1)){
    #####:  664:    nextPlayer = 0;
        -:  665:  }
        -:  666:  
        -:  667:	
        -:  668:  //uses switch to select card and perform actions
    #####:  669:  switch( card ) 
        -:  670:    {
        -:  671:    case adventurer:
    #####:  672:	 return playAdventurer(state);
        -:  673:			
        -:  674:    case council_room:
    #####:  675:	  return playCouncil_Room(state, handPos);
        -:  676:			
        -:  677:    case feast:
        -:  678:      //gain card with cost up to 5
        -:  679:      //Backup hand
    #####:  680:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  681:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  682:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  683:      }
        -:  684:      //Backup hand
        -:  685:
        -:  686:      //Update Coins for Buy
    #####:  687:      updateCoins(currentPlayer, state, 5);
    #####:  688:      x = 1;//Condition to loop on
    #####:  689:      while( x == 1) {//Buy one card
    #####:  690:	if (supplyCount(choice1, state) <= 0){
        -:  691:	  if (DEBUG)
        -:  692:	    printf("None of that card left, sorry!\n");
        -:  693:
        -:  694:	  if (DEBUG){
        -:  695:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  696:	  }
        -:  697:	}
    #####:  698:	else if (state->coins < getCost(choice1)){
    #####:  699:	  printf("That card is too expensive!\n");
        -:  700:
        -:  701:	  if (DEBUG){
        -:  702:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  703:	  }
        -:  704:	}
        -:  705:	else{
        -:  706:
        -:  707:	  if (DEBUG){
        -:  708:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  709:	  }
        -:  710:
    #####:  711:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  712:	  x = 0;//No more buying cards
        -:  713:
        -:  714:	  if (DEBUG){
        -:  715:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  716:	  }
        -:  717:
        -:  718:	}
        -:  719:      }     
        -:  720:
        -:  721:      //Reset Hand
    #####:  722:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  723:	state->hand[currentPlayer][i] = temphand[i];
    #####:  724:	temphand[i] = -1;
        -:  725:      }
        -:  726:      //Reset Hand
        -:  727:      			
    #####:  728:      return 0;
        -:  729:			
        -:  730:    case gardens:
    #####:  731:      return -1;
        -:  732:			
        -:  733:    case mine:
    #####:  734:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  735:
    #####:  736:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  737:	{
    #####:  738:	  return -1;
        -:  739:	}
        -:  740:		
    #####:  741:      if (choice2 > treasure_map || choice2 < curse)
        -:  742:	{
    #####:  743:	  return -1;
        -:  744:	}
        -:  745:
    #####:  746:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
        -:  747:	{
    #####:  748:	  return -1;
        -:  749:	}
        -:  750:
    #####:  751:      gainCard(choice2, state, 2, currentPlayer);
        -:  752:
        -:  753:      //discard card from hand
    #####:  754:      discardCard(handPos, currentPlayer, state, 0);
        -:  755:
        -:  756:      //discard trashed card
    #####:  757:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  758:	{
    #####:  759:	  if (state->hand[currentPlayer][i] == j)
        -:  760:	    {
    #####:  761:	      discardCard(i, currentPlayer, state, 0);			
    #####:  762:	      break;
        -:  763:	    }
        -:  764:	}
        -:  765:			
    #####:  766:      return 0;
        -:  767:			
        -:  768:    case remodel:
    #####:  769:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  770:
    #####:  771:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  772:	{
    #####:  773:	  return -1;
        -:  774:	}
        -:  775:
    #####:  776:      gainCard(choice2, state, 0, currentPlayer);
        -:  777:
        -:  778:      //discard card from hand
    #####:  779:      discardCard(handPos, currentPlayer, state, 0);
        -:  780:
        -:  781:      //discard trashed card
    #####:  782:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  783:	{
    #####:  784:	  if (state->hand[currentPlayer][i] == j)
        -:  785:	    {
    #####:  786:	      discardCard(i, currentPlayer, state, 0);			
    #####:  787:	      break;
        -:  788:	    }
        -:  789:	}
        -:  790:
        -:  791:
    #####:  792:      return 0;
        -:  793:		
        -:  794:    case smithy:
    #####:  795:	  return playSmithy(state, handPos);
        -:  796:      /* //+3 Cards
        -:  797:      for (i = 0; i < 3; i++)
        -:  798:	  {
        -:  799:	    drawCard(currentPlayer, state);
        -:  800:	  }
        -:  801:			
        -:  802:      //discard card from hand
        -:  803:      discardCard(handPos, currentPlayer, state, 0);
        -:  804:      return 0; */
        -:  805:		
        -:  806:    case village:
    #####:  807:        return playVillage(state, handPos);
        -:  808:      /*
        -:  809:      //+1 Card
        -:  810:      drawCard(currentPlayer, state);
        -:  811:			
        -:  812:      //+2 Actions
        -:  813:      state->numActions = state->numActions + 2;
        -:  814:			
        -:  815:      //discard played card from hand
        -:  816:      discardCard(handPos, currentPlayer, state, 0);
        -:  817:      return 0;
        -:  818:       */	
        -:  819:    case baron:
    #####:  820:      state->numBuys++;//Increase buys by 1!
    #####:  821:      if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  822:	int p = 0;//Iterator for hand!
    #####:  823:	int card_not_discarded = 1;//Flag for discard set!
    #####:  824:	while(card_not_discarded){
    #####:  825:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
    #####:  826:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  827:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  828:	    state->discardCount[currentPlayer]++;
    #####:  829:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:  830:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  831:	    }
    #####:  832:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  833:	    state->handCount[currentPlayer]--;
    #####:  834:	    card_not_discarded = 0;//Exit the loop
        -:  835:	  }
    #####:  836:	  else if (p > state->handCount[currentPlayer]){
        -:  837:	    if(DEBUG) {
        -:  838:	      printf("No estate cards in your hand, invalid choice\n");
        -:  839:	      printf("Must gain an estate if there are any\n");
        -:  840:	    }
    #####:  841:	    if (supplyCount(estate, state) > 0){
    #####:  842:	      gainCard(estate, state, 0, currentPlayer);
    #####:  843:	      state->supplyCount[estate]--;//Decrement estates
    #####:  844:	      if (supplyCount(estate, state) == 0){
    #####:  845:		isGameOver(state);
        -:  846:	      }
        -:  847:	    }
    #####:  848:	    card_not_discarded = 0;//Exit the loop
        -:  849:	  }
        -:  850:			    
        -:  851:	  else{
    #####:  852:	    p++;//Next card
        -:  853:	  }
        -:  854:	}
        -:  855:      }
        -:  856:			    
        -:  857:      else{
    #####:  858:	if (supplyCount(estate, state) > 0){
    #####:  859:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  860:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  861:	  if (supplyCount(estate, state) == 0){
    #####:  862:	    isGameOver(state);
        -:  863:	  }
        -:  864:	}
        -:  865:      }
        -:  866:	    
        -:  867:      
    #####:  868:      return 0;
        -:  869:		
        -:  870:    case great_hall:
        -:  871:      //+1 Card
    #####:  872:      drawCard(currentPlayer, state);
        -:  873:			
        -:  874:      //+1 Actions
    #####:  875:      state->numActions++;
        -:  876:			
        -:  877:      //discard card from hand
    #####:  878:      discardCard(handPos, currentPlayer, state, 0);
    #####:  879:      return 0;
        -:  880:		
        -:  881:    case minion:
        -:  882:      //+1 action
    #####:  883:      state->numActions++;
        -:  884:			
        -:  885:      //discard card from hand
    #####:  886:      discardCard(handPos, currentPlayer, state, 0);
        -:  887:			
    #####:  888:      if (choice1)		//+2 coins
        -:  889:	{
    #####:  890:	  state->coins = state->coins + 2;
        -:  891:	}
        -:  892:			
    #####:  893:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  894:	{
        -:  895:	  //discard hand
    #####:  896:	  while(numHandCards(state) > 0)
        -:  897:	    {
    #####:  898:	      discardCard(handPos, currentPlayer, state, 0);
        -:  899:	    }
        -:  900:				
        -:  901:	  //draw 4
    #####:  902:	  for (i = 0; i < 4; i++)
        -:  903:	    {
    #####:  904:	      drawCard(currentPlayer, state);
        -:  905:	    }
        -:  906:				
        -:  907:	  //other players discard hand and redraw if hand size > 4
    #####:  908:	  for (i = 0; i < state->numPlayers; i++)
        -:  909:	    {
    #####:  910:	      if (i != currentPlayer)
        -:  911:		{
    #####:  912:		  if ( state->handCount[i] > 4 )
        -:  913:		    {
        -:  914:		      //discard hand
    #####:  915:		      while( state->handCount[i] > 0 )
        -:  916:			{
    #####:  917:			  discardCard(handPos, i, state, 0);
        -:  918:			}
        -:  919:							
        -:  920:		      //draw 4
    #####:  921:		      for (j = 0; j < 4; j++)
        -:  922:			{
    #####:  923:			  drawCard(i, state);
        -:  924:			}
        -:  925:		    }
        -:  926:		}
        -:  927:	    }
        -:  928:				
        -:  929:	}
    #####:  930:      return 0;
        -:  931:		
        -:  932:    case steward:
    #####:  933:	  return playSteward(state, handPos, choice1, choice2, choice3);
        -:  934:
        -:  935:		
        -:  936:    case tribute:
    #####:  937:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####:  938:	if (state->deckCount[nextPlayer] > 0){
    #####:  939:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  940:	  state->deckCount[nextPlayer]--;
        -:  941:	}
    #####:  942:	else if (state->discardCount[nextPlayer] > 0){
    #####:  943:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  944:	  state->discardCount[nextPlayer]--;
        -:  945:	}
        -:  946:	else{
        -:  947:	  //No Card to Reveal
        -:  948:	  if (DEBUG){
        -:  949:	    printf("No cards to reveal\n");
        -:  950:	  }
        -:  951:	}
        -:  952:      }
        -:  953:	    
        -:  954:      else{
    #####:  955:	if (state->deckCount[nextPlayer] == 0){
    #####:  956:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####:  957:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  958:	    state->deckCount[nextPlayer]++;
    #####:  959:	    state->discard[nextPlayer][i] = -1;
    #####:  960:	    state->discardCount[nextPlayer]--;
        -:  961:	  }
        -:  962:			    
    #####:  963:	  shuffle(nextPlayer,state);//Shuffle the deck
        -:  964:	} 
    #####:  965:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  966:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  967:	state->deckCount[nextPlayer]--;
    #####:  968:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  969:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  970:	state->deckCount[nextPlayer]--;
        -:  971:      }    
        -:  972:		       
    #####:  973:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####:  974:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  975:	state->playedCardCount++;
    #####:  976:	tributeRevealedCards[1] = -1;
        -:  977:      } 
        -:  978:
    #####:  979:      for (i = 0; i <= 2; i ++){
    #####:  980:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####:  981:	  state->coins += 2;
        -:  982:	}
        -:  983:		    
    #####:  984:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####:  985:	  drawCard(currentPlayer, state);
    #####:  986:	  drawCard(currentPlayer, state);
        -:  987:	}
        -:  988:	else{//Action Card
    #####:  989:	  state->numActions = state->numActions + 2;
        -:  990:	}
        -:  991:      }
        -:  992:	    
    #####:  993:      return 0;
        -:  994:		
        -:  995:    case ambassador:
    #####:  996:      j = 0;		//used to check if player has enough cards to discard
        -:  997:
    #####:  998:      if (choice2 > 2 || choice2 < 0)
        -:  999:	{
    #####: 1000:	  return -1;				
        -: 1001:	}
        -: 1002:
    #####: 1003:      if (choice1 == handPos)
        -: 1004:	{
    #####: 1005:	  return -1;
        -: 1006:	}
        -: 1007:
    #####: 1008:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1009:	{
    #####: 1010:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1011:	    {
    #####: 1012:	      j++;
        -: 1013:	    }
        -: 1014:	}
    #####: 1015:      if (j < choice2)
        -: 1016:	{
    #####: 1017:	  return -1;				
        -: 1018:	}
        -: 1019:
        -: 1020:      if (DEBUG) 
        -: 1021:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1022:
        -: 1023:      //increase supply count for choosen card by amount being discarded
    #####: 1024:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1025:			
        -: 1026:      //each other player gains a copy of revealed card
    #####: 1027:      for (i = 0; i < state->numPlayers; i++)
        -: 1028:	{
    #####: 1029:	  if (i != currentPlayer)
        -: 1030:	    {
    #####: 1031:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1032:	    }
        -: 1033:	}
        -: 1034:
        -: 1035:      //discard played card from hand
    #####: 1036:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1037:
        -: 1038:      //trash copies of cards returned to supply
    #####: 1039:      for (j = 0; j < choice2; j++)
        -: 1040:	{
    #####: 1041:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1042:	    {
    #####: 1043:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1044:		{
    #####: 1045:		  discardCard(i, currentPlayer, state, 1);
    #####: 1046:		  break;
        -: 1047:		}
        -: 1048:	    }
        -: 1049:	}			
        -: 1050:
    #####: 1051:      return 0;
        -: 1052:		
        -: 1053:    case cutpurse:
        -: 1054:
        -: 1055:/*       updateCoins(currentPlayer, state, 2);
        -: 1056:      for (i = 0; i < state->numPlayers; i++)
        -: 1057:	{
        -: 1058:	  if (i != currentPlayer)
        -: 1059:	    {
        -: 1060:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1061:		{
        -: 1062:		  if (state->hand[i][j] == copper)
        -: 1063:		    {
        -: 1064:		      discardCard(j, i, state, 0);
        -: 1065:		      break;
        -: 1066:		    }
        -: 1067:		  if (j == state->handCount[i])
        -: 1068:		    {
        -: 1069:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1070:			{
        -: 1071:			  if (DEBUG)
        -: 1072:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1073:			}	
        -: 1074:		      break;
        -: 1075:		    }		
        -: 1076:		}
        -: 1077:					
        -: 1078:	    }
        -: 1079:				
        -: 1080:	}				
        -: 1081:
        -: 1082:      //discard played card from hand
        -: 1083:      discardCard(handPos, currentPlayer, state, 0); */			
        -: 1084:
    #####: 1085:      return playCutpurse(state, handPos);
        -: 1086:
        -: 1087:		
        -: 1088:    case embargo: 
        -: 1089:      //+2 Coins
    #####: 1090:      state->coins = state->coins + 2;
        -: 1091:			
        -: 1092:      //see if selected pile is in play
    #####: 1093:      if ( state->supplyCount[choice1] == -1 )
        -: 1094:	{
    #####: 1095:	  return -1;
        -: 1096:	}
        -: 1097:			
        -: 1098:      //add embargo token to selected supply pile
    #####: 1099:      state->embargoTokens[choice1]++;
        -: 1100:			
        -: 1101:      //trash card
    #####: 1102:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1103:      return 0;
        -: 1104:		
        -: 1105:    case outpost:
        -: 1106:      //set outpost flag
    #####: 1107:      state->outpostPlayed++;
        -: 1108:			
        -: 1109:      //discard card
    #####: 1110:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1111:      return 0;
        -: 1112:		
        -: 1113:    case salvager:
        -: 1114:      //+1 buy
    #####: 1115:      state->numBuys++;
        -: 1116:			
    #####: 1117:      if (choice1)
        -: 1118:	{
        -: 1119:	  //gain coins equal to trashed card
    #####: 1120:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1121:	  //trash card
    #####: 1122:	  discardCard(choice1, currentPlayer, state, 1);	
        -: 1123:	}
        -: 1124:			
        -: 1125:      //discard card
    #####: 1126:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1127:      return 0;
        -: 1128:		
        -: 1129:    case sea_hag:
    #####: 1130:      for (i = 0; i < state->numPlayers; i++){
    #####: 1131:	if (i != currentPlayer){
    #####: 1132:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1133:	  state->discardCount[i]++;
    #####: 1134:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1135:	}
        -: 1136:      }
    #####: 1137:      return 0;
        -: 1138:		
        -: 1139:    case treasure_map:
        -: 1140:      //search hand for another treasure_map
    #####: 1141:      index = -1;
    #####: 1142:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1143:	{
    #####: 1144:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1145:	    {
    #####: 1146:	      index = i;
    #####: 1147:	      break;
        -: 1148:	    }
        -: 1149:	}
    #####: 1150:      if (index > -1)
        -: 1151:	{
        -: 1152:	  //trash both treasure cards
    #####: 1153:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1154:	  discardCard(index, currentPlayer, state, 1);
        -: 1155:
        -: 1156:	  //gain 4 Gold cards
    #####: 1157:	  for (i = 0; i < 4; i++)
        -: 1158:	    {
    #####: 1159:	      gainCard(gold, state, 1, currentPlayer);
        -: 1160:	    }
        -: 1161:				
        -: 1162:	  //return success
    #####: 1163:	  return 1;
        -: 1164:	}
        -: 1165:			
        -: 1166:      //no second treasure_map found in hand
    #####: 1167:      return -1;
        -: 1168:    }
        -: 1169:	
    #####: 1170:  return -1;
        -: 1171:}
        -: 1172:
    #####: 1173:int playAdventurer(struct gameState *state){
    #####: 1174:	int drawntreasure = 0;
        -: 1175:	int cardDrawn;
    #####: 1176:	int currentPlayer = whoseTurn(state);
        -: 1177:    int temphand[MAX_HAND];// moved above the if statement
    #####: 1178:    int z = 0;// this is the counter for the temp hand
        -: 1179:
        -: 1180:	
    #####: 1181:	while(drawntreasure<3){
    #####: 1182:		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
    #####: 1183:		  shuffle(currentPlayer, state);
        -: 1184:		}
    #####: 1185:		drawCard(currentPlayer, state);
    #####: 1186:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####: 1187:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####: 1188:		  drawntreasure++;
        -: 1189:		else{
    #####: 1190:		  temphand[z]=cardDrawn;
    #####: 1191:		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####: 1192:		  z++;
        -: 1193:		}
        -: 1194:	  }
    #####: 1195:	  while(z-1>=0){
    #####: 1196:		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####: 1197:	   z=z-1;
        -: 1198:	  }
        -: 1199:	  
    #####: 1200:	return 0;
        -: 1201:}
        -: 1202:
        -: 1203://Add 4 cards
    #####: 1204:int playCouncil_Room(struct gameState *state, int handPos){
    #####: 1205:	int currentPlayer = whoseTurn(state);
        -: 1206:	int i;
        -: 1207:  
    #####: 1208:    for (i = 0; i < 5; i++)
        -: 1209:	{
    #####: 1210:	  drawCard(currentPlayer, state);
        -: 1211:	}
        -: 1212:			
        -: 1213:    //+1 Buy
    #####: 1214:    state->numBuys++;
        -: 1215:			
        -: 1216:    //Each other player draws a card
    #####: 1217:    for (i = 0; i < state->numPlayers; i++)
        -: 1218:	{
    #####: 1219:	  if ( i != currentPlayer )
        -: 1220:	  {
    #####: 1221:	    drawCard(i, state);
        -: 1222:	  }
        -: 1223:	}
        -: 1224:			
        -: 1225:    //put played card in played card pile
    #####: 1226:    discardCard(handPos, currentPlayer, state, 0);
    #####: 1227:	return 0;
        -: 1228:}
        -: 1229:
   493024: 1230:int playSmithy(struct gameState *state, int handPos){
        -: 1231:    int i;
   493024: 1232:    int currentPlayer = whoseTurn(state);
        -: 1233:
        -: 1234:    //+3 Cards
  1972096: 1235:    for (i = 0; i < 3; i++)
        -: 1236:    {
  1479072: 1237:      drawCard(currentPlayer, state);
        -: 1238:    }
        -: 1239:    	
        -: 1240:    //discard card from hand
   493024: 1241:    discardCard(handPos, currentPlayer, state, 0-1);
   493024: 1242:    return 0;
        -: 1243:}
        -: 1244:
    #####: 1245:int playCutpurse(struct gameState *state, int handPos){
        -: 1246:	int i, j, k;
    #####: 1247:	int currentPlayer = whoseTurn(state);
        -: 1248:
        -: 1249:	
    #####: 1250:    updateCoins(currentPlayer, state, 2);
    #####: 1251:    for (i = 0; i < state->numPlayers; i++)
        -: 1252:	{
    #####: 1253:	  if (i != currentPlayer)
        -: 1254:	  {
    #####: 1255:	    for (j = 0; j <= state->handCount[i]; j++){
    #####: 1256:          if (state->hand[i][j] == copper){
    #####: 1257:	        discardCard(j, i, state, 0);
    #####: 1258:		    return -1;
        -: 1259:	      }
    #####: 1260:	      if (j = state->handCount[i]){
    #####: 1261:            for (k = 0; k < state->handCount[i]; k++){
        -: 1262:		      if (DEBUG)
        -: 1263:                printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1264:            }	
    #####: 1265:		  return -1;
        -: 1266:          }		
        -: 1267:		}
        -: 1268:					
        -: 1269:	  }//end != currentPlayer switch		
        -: 1270:	}
        -: 1271:
        -: 1272:    //discard played card from hand
    #####: 1273:	discardCard(handPos, currentPlayer, state, 0);
        -: 1274:	
    #####: 1275:	return 0;
        -: 1276:}
        -: 1277:
    #####: 1278:int playSteward(struct gameState *state, int handPos, int choice1, int choice2, int choice3){
    #####: 1279:  int currentPlayer = whoseTurn(state);
        -: 1280:
    #####: 1281:  if (choice1 == 1) {
        -: 1282:  //+2 cards
    #####: 1283:    drawCard(currentPlayer, state);
    #####: 1284:    drawCard(currentPlayer, state);
        -: 1285:  }
    #####: 1286:  else if (choice1 == 2) {
        -: 1287:  //+2 coins
    #####: 1288:    state->coins = state->coins + 2;
        -: 1289:  }
        -: 1290:  else {
        -: 1291:  //trash 2 cards in hand
    #####: 1292:    discardCard(choice2, currentPlayer, state, 1);
    #####: 1293:    discardCard(choice3, currentPlayer, state, 1);
        -: 1294:  }
        -: 1295:	
        -: 1296:  //discard card from hand
    #####: 1297:  discardCard(handPos, currentPlayer, state, 0);
    #####: 1298:  return 0;
        -: 1299:}
        -: 1300:
    #####: 1301:int playVillage(struct gameState *state, int handPos){
    #####: 1302:    int currentPlayer = whoseTurn(state);
        -: 1303:
        -: 1304:    //+1 Card
    #####: 1305:     drawCard(currentPlayer, state);
        -: 1306:
        -: 1307:     //+2 Actions
    #####: 1308:     state->numActions = state->numActions + 2;
        -: 1309:
        -: 1310:     //discard played card from hand
    #####: 1311:     discardCard(handPos, currentPlayer, state, 0);
    #####: 1312:     return 0;
        -: 1313:}
        -: 1314:
   493024: 1315:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1316:{
        -: 1317:	
        -: 1318:  //if card is not trashed, added to Played pile 
   493024: 1319:  if (trashFlag < 1)
        -: 1320:    {
        -: 1321:      //add card to played pile
   493024: 1322:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
   493024: 1323:      state->playedCardCount++;
        -: 1324:    }
        -: 1325:	
        -: 1326:  //set played card to -1
   493024: 1327:  state->hand[currentPlayer][handPos] = -1;
        -: 1328:	
        -: 1329:  //remove card from player's hand
   493024: 1330:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1331:    {
        -: 1332:      //reduce number of cards in hand
    #####: 1333:      state->handCount[currentPlayer]--;
        -: 1334:    }
   493024: 1335:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1336:    {
        -: 1337:      //reduce number of cards in hand
    #####: 1338:      state->handCount[currentPlayer]--;
        -: 1339:    }
        -: 1340:  else 	
        -: 1341:    {
        -: 1342:      //replace discarded card with last card in hand
   493024: 1343:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1344:      //set last card to -1
   493024: 1345:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1346:      //reduce number of cards in hand
   493024: 1347:      state->handCount[currentPlayer]--;
        -: 1348:    }
        -: 1349:	
   493024: 1350:  return 0;
        -: 1351:}
        -: 1352:
    #####: 1353:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1354:{
        -: 1355:  //Note: supplyPos is enum of choosen card
        -: 1356:	
        -: 1357:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1358:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1359:    {
    #####: 1360:      return -1;
        -: 1361:    }
        -: 1362:	
        -: 1363:  //added card for [whoseTurn] current player:
        -: 1364:  // toFlag = 0 : add to discard
        -: 1365:  // toFlag = 1 : add to deck
        -: 1366:  // toFlag = 2 : add to hand
        -: 1367:
    #####: 1368:  if (toFlag == 1)
        -: 1369:    {
    #####: 1370:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1371:      state->deckCount[player]++;
        -: 1372:    }
    #####: 1373:  else if (toFlag == 2)
        -: 1374:    {
    #####: 1375:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1376:      state->handCount[player]++;
        -: 1377:    }
        -: 1378:  else
        -: 1379:    {
    #####: 1380:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1381:      state->discardCount[player]++;
        -: 1382:    }
        -: 1383:	
        -: 1384:  //decrease number in supply pile
    #####: 1385:  state->supplyCount[supplyPos]--;
        -: 1386:	 
    #####: 1387:  return 0;
        -: 1388:}
        -: 1389:
      813: 1390:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1391:{
        -: 1392:  int i;
        -: 1393:	
        -: 1394:  //reset coin count
      813: 1395:  state->coins = 0;
        -: 1396:
        -: 1397:  //add coins for each Treasure card in player's hand
     3868: 1398:  for (i = 0; i < state->handCount[player]; i++)
        -: 1399:    {
     3055: 1400:      if (state->hand[player][i] == copper)
        -: 1401:	{
     1044: 1402:	  state->coins += 1;
        -: 1403:	}
     2011: 1404:      else if (state->hand[player][i] == silver)
        -: 1405:	{
     1000: 1406:	  state->coins += 2;
        -: 1407:	}
     1011: 1408:      else if (state->hand[player][i] == gold)
        -: 1409:	{
     1000: 1410:	  state->coins += 3;
        -: 1411:	}	
        -: 1412:    }	
        -: 1413:
        -: 1414:  //add bonus
      813: 1415:  state->coins += bonus;
        -: 1416:
      813: 1417:  return 0;
        -: 1418:}
        -: 1419:
        -: 1420:
        -: 1421://end of dominion.c
        -: 1422:

Testing playAdventurer() with seed 1234
Game Initialized! :)
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!
TEST FAILED!

__3968 TESTS FAILED!__

File 'dominion.c'
Lines executed:33.10% of 568
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:11
        -:    0:Programs:6
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
    10400:    8:int compare(const void* a, const void* b) {
    10400:    9:  if (*(int*)a > *(int*)b)
    #####:   10:    return 1;
    10400:   11:  if (*(int*)a < *(int*)b)
      128:   12:    return -1;
    10272:   13:  return 0;
        -:   14:}
        -:   15:
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
        -:   21:
    #####:   22:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   23:		  int k8, int k9, int k10) {
    #####:   24:  int* k = malloc(10 * sizeof(int));
    #####:   25:  k[0] = k1;
    #####:   26:  k[1] = k2;
    #####:   27:  k[2] = k3;
    #####:   28:  k[3] = k4;
    #####:   29:  k[4] = k5;
    #####:   30:  k[5] = k6;
    #####:   31:  k[6] = k7;
    #####:   32:  k[7] = k8;
    #####:   33:  k[8] = k9;
    #####:   34:  k[9] = k10;
    #####:   35:  return k;
        -:   36:}
        -:   37:
       11:   38:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   39:		   struct gameState *state) {
        -:   40:
        -:   41:  int i;
        -:   42:  int j;
        -:   43:  int it;			
        -:   44:  //set up random number generator
       11:   45:  SelectStream(1);
       11:   46:  PutSeed((long)randomSeed);
        -:   47:  
        -:   48:  //check number of players
       11:   49:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   50:    {
    #####:   51:      return -1;
        -:   52:    }
        -:   53:
        -:   54:  //set number of players
       11:   55:  state->numPlayers = numPlayers;
        -:   56:
        -:   57:  //check selected kingdom cards are different
      121:   58:  for (i = 0; i < 10; i++)
        -:   59:    {
     1210:   60:      for (j = 0; j < 10; j++)
        -:   61:        {
     1100:   62:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   63:	    {
    #####:   64:	      return -1;
        -:   65:	    }
        -:   66:        }
        -:   67:    }
        -:   68:
        -:   69:
        -:   70:  //initialize supply
        -:   71:  ///////////////////////////////
        -:   72:
        -:   73:  //set number of Curse cards
       11:   74:  if (numPlayers == 2)
        -:   75:    {
        6:   76:      state->supplyCount[curse] = 10;
        -:   77:    }
        5:   78:  else if (numPlayers == 3)
        -:   79:    {
    #####:   80:      state->supplyCount[curse] = 20;
        -:   81:    }
        -:   82:  else
        -:   83:    {
        5:   84:      state->supplyCount[curse] = 30;
        -:   85:    }
        -:   86:
        -:   87:  //set number of Victory cards
       11:   88:  if (numPlayers == 2)
        -:   89:    {
        6:   90:      state->supplyCount[estate] = 8;
        6:   91:      state->supplyCount[duchy] = 8;
        6:   92:      state->supplyCount[province] = 8;
        -:   93:    }
        -:   94:  else
        -:   95:    {
        5:   96:      state->supplyCount[estate] = 12;
        5:   97:      state->supplyCount[duchy] = 12;
        5:   98:      state->supplyCount[province] = 12;
        -:   99:    }
        -:  100:
        -:  101:  //set number of Treasure cards
       11:  102:  state->supplyCount[copper] = 60 - (7 * numPlayers);
       11:  103:  state->supplyCount[silver] = 40;
       11:  104:  state->supplyCount[gold] = 30;
        -:  105:
        -:  106:  //set number of Kingdom cards
      231:  107:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  108:    {
     1815:  109:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  110:	{
     1705:  111:	  if (kingdomCards[j] == i)
        -:  112:	    {
        -:  113:	      //check if card is a 'Victory' Kingdom card
      110:  114:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  115:		{
       22:  116:		  if (numPlayers == 2){ 
        6:  117:		    state->supplyCount[i] = 8; 
        -:  118:		  }
        5:  119:		  else{ state->supplyCount[i] = 12; }
        -:  120:		}
        -:  121:	      else
        -:  122:		{
       99:  123:		  state->supplyCount[i] = 10;
        -:  124:		}
      110:  125:	      break;
        -:  126:	    }
        -:  127:	  else    //card is not in the set choosen for the game
        -:  128:	    {
     1595:  129:	      state->supplyCount[i] = -1;
        -:  130:	    }
        -:  131:	}
        -:  132:
        -:  133:    }
        -:  134:
        -:  135:  ////////////////////////
        -:  136:  //supply intilization complete
        -:  137:
        -:  138:  //set player decks
       43:  139:  for (i = 0; i < numPlayers; i++)
        -:  140:    {
       32:  141:      state->deckCount[i] = 0;
      128:  142:      for (j = 0; j < 3; j++)
        -:  143:	{
       96:  144:	  state->deck[i][j] = estate;
       96:  145:	  state->deckCount[i]++;
        -:  146:	}
      256:  147:      for (j = 3; j < 10; j++)
        -:  148:	{
      224:  149:	  state->deck[i][j] = copper;
      224:  150:	  state->deckCount[i]++;		
        -:  151:	}
        -:  152:    }
        -:  153:
        -:  154:  //shuffle player decks
       43:  155:  for (i = 0; i < numPlayers; i++)
        -:  156:    {
       32:  157:      if ( shuffle(i, state) < 0 )
        -:  158:	{
    #####:  159:	  return -1;
        -:  160:	}
        -:  161:    }
        -:  162:
        -:  163:  //draw player hands
       43:  164:  for (i = 0; i < numPlayers; i++)
        -:  165:    {  
        -:  166:      //initialize hand size to zero
       32:  167:      state->handCount[i] = 0;
       32:  168:      state->discardCount[i] = 0;
        -:  169:      //draw 5 cards
        -:  170:      // for (j = 0; j < 5; j++)
        -:  171:      //	{
        -:  172:      //	  drawCard(i, state);
        -:  173:      //	}
        -:  174:    }
        -:  175:  
        -:  176:  //set embargo tokens to 0 for all supply piles
      308:  177:  for (i = 0; i <= treasure_map; i++)
        -:  178:    {
      297:  179:      state->embargoTokens[i] = 0;
        -:  180:    }
        -:  181:
        -:  182:  //initialize first player's turn
       11:  183:  state->outpostPlayed = 0;
       11:  184:  state->phase = 0;
       11:  185:  state->numActions = 1;
       11:  186:  state->numBuys = 1;
       11:  187:  state->playedCardCount = 0;
       11:  188:  state->whoseTurn = 0;
       11:  189:  state->handCount[state->whoseTurn] = 0;
        -:  190:  //int it; move to top
        -:  191:
        -:  192:  //Moved draw cards to here, only drawing at the start of a turn
       66:  193:  for (it = 0; it < 5; it++){
       55:  194:    drawCard(state->whoseTurn, state);
        -:  195:  }
        -:  196:
       11:  197:  updateCoins(state->whoseTurn, state, 0);
        -:  198:
       11:  199:  return 0;
        -:  200:}
        -:  201:
     4000:  202:int shuffle(int player, struct gameState *state) {
        -:  203: 
        -:  204:
        -:  205:  int newDeck[MAX_DECK];
     4000:  206:  int newDeckPos = 0;
        -:  207:  int card;
        -:  208:  int i;
        -:  209:
     4000:  210:  if (state->deckCount[player] < 1)
     1984:  211:    return -1;
     2016:  212:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  213:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  214:
    14272:  215:  while (state->deckCount[player] > 0) {
    10240:  216:    card = floor(Random() * state->deckCount[player]);
    10240:  217:    newDeck[newDeckPos] = state->deck[player][card];
    10240:  218:    newDeckPos++;
    20961:  219:    for (i = card; i < state->deckCount[player]-1; i++) {
    10721:  220:      state->deck[player][i] = state->deck[player][i+1];
        -:  221:    }
    10240:  222:    state->deckCount[player]--;
        -:  223:  }
    12256:  224:  for (i = 0; i < newDeckPos; i++) {
    10240:  225:    state->deck[player][i] = newDeck[i];
    10240:  226:    state->deckCount[player]++;
        -:  227:  }
        -:  228:
     2016:  229:  return 0;
        -:  230:}
        -:  231:
    #####:  232:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  233:{	
        -:  234:  int card;
    #####:  235:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  236:
        -:  237:  //check if it is the right phase
    #####:  238:  if (state->phase != 0)
        -:  239:    {
    #####:  240:      return -1;
        -:  241:    }
        -:  242:	
        -:  243:  //check if player has enough actions
    #####:  244:  if ( state->numActions < 1 )
        -:  245:    {
    #####:  246:      return -1;
        -:  247:    }
        -:  248:	
        -:  249:  //get card played
    #####:  250:  card = handCard(handPos, state);
        -:  251:	
        -:  252:  //check if selected card is an action
    #####:  253:  if ( card < adventurer || card > treasure_map )
        -:  254:    {
    #####:  255:      return -1;
        -:  256:    }
        -:  257:	
        -:  258:  //play card
    #####:  259:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  260:    {
    #####:  261:      return -1;
        -:  262:    }
        -:  263:	
        -:  264:  //reduce number of actions
    #####:  265:  state->numActions--;
        -:  266:
        -:  267:  //update coins (Treasure cards may be added with card draws)
    #####:  268:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  269:	
    #####:  270:  return 0;
        -:  271:}
        -:  272:
    #####:  273:int buyCard(int supplyPos, struct gameState *state) {
        -:  274:  int who;
        -:  275:  if (DEBUG){
        -:  276:    printf("Entering buyCard...\n");
        -:  277:  }
        -:  278:
        -:  279:  // I don't know what to do about the phase thing.
        -:  280:
    #####:  281:  who = state->whoseTurn;
        -:  282:
    #####:  283:  if (state->numBuys < 1){
        -:  284:    if (DEBUG)
        -:  285:      printf("You do not have any buys left\n");
    #####:  286:    return -1;
    #####:  287:  } else if (supplyCount(supplyPos, state) <1){
        -:  288:    if (DEBUG)
        -:  289:      printf("There are not any of that type of card left\n");
    #####:  290:    return -1;
    #####:  291:  } else if (state->coins < getCost(supplyPos)){
        -:  292:    if (DEBUG) 
        -:  293:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  294:    return -1;
        -:  295:  } else {
    #####:  296:    state->phase=1;
        -:  297:    //state->supplyCount[supplyPos]--;
    #####:  298:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  299:  
    #####:  300:    state->coins = (state->coins) - (getCost(supplyPos));
    #####:  301:    state->numBuys--;
        -:  302:    if (DEBUG)
        -:  303:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  304:  }
        -:  305:
        -:  306:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  307:  //state->discardCount[who]++;
        -:  308:    
    #####:  309:  return 0;
        -:  310:}
        -:  311:
    #####:  312:int numHandCards(struct gameState *state) {
    #####:  313:  return state->handCount[ whoseTurn(state) ];
        -:  314:}
        -:  315:
    #####:  316:int handCard(int handPos, struct gameState *state) {
    #####:  317:  int currentPlayer = whoseTurn(state);
    #####:  318:  return state->hand[currentPlayer][handPos];
        -:  319:}
        -:  320:
    #####:  321:int supplyCount(int card, struct gameState *state) {
    #####:  322:  return state->supplyCount[card];
        -:  323:}
        -:  324:
    #####:  325:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  326:  int i;
    #####:  327:  int count = 0;
        -:  328:
    #####:  329:  for (i = 0; i < state->deckCount[player]; i++)
        -:  330:    {
    #####:  331:      if (state->deck[player][i] == card) count++;
        -:  332:    }
        -:  333:
    #####:  334:  for (i = 0; i < state->handCount[player]; i++)
        -:  335:    {
    #####:  336:      if (state->hand[player][i] == card) count++;
        -:  337:    }
        -:  338:
    #####:  339:  for (i = 0; i < state->discardCount[player]; i++)
        -:  340:    {
    #####:  341:      if (state->discard[player][i] == card) count++;
        -:  342:    }
        -:  343:
    #####:  344:  return count;
        -:  345:}
        -:  346:
   990028:  347:int whoseTurn(struct gameState *state) {
   990028:  348:  return state->whoseTurn;
        -:  349:}
        -:  350:
    #####:  351:int endTurn(struct gameState *state) {
        -:  352:  int k;
        -:  353:  int i;
    #####:  354:  int currentPlayer = whoseTurn(state);
        -:  355:  
        -:  356:  //Discard hand
    #####:  357:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  358:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  359:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  360:  }
    #####:  361:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  362:    
        -:  363:  //Code for determining the player
    #####:  364:  if (currentPlayer < (state->numPlayers - 1)){ 
    #####:  365:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  366:  }
        -:  367:  else{
    #####:  368:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  369:  }
        -:  370:
    #####:  371:  state->outpostPlayed = 0;
    #####:  372:  state->phase = 0;
    #####:  373:  state->numActions = 1;
    #####:  374:  state->coins = 0;
    #####:  375:  state->numBuys = 1;
    #####:  376:  state->playedCardCount = 0;
    #####:  377:  state->handCount[state->whoseTurn] = 0;
        -:  378:
        -:  379:  //int k; move to top
        -:  380:  //Next player draws hand
    #####:  381:  for (k = 0; k < 5; k++){
    #####:  382:    drawCard(state->whoseTurn, state);//Draw a card
        -:  383:  }
        -:  384:
        -:  385:  //Update money
    #####:  386:  updateCoins(state->whoseTurn, state , 0);
        -:  387:
    #####:  388:  return 0;
        -:  389:}
        -:  390:
      156:  391:int isGameOver(struct gameState *state) {
        -:  392:  int i;
        -:  393:  int j;
        -:  394:	
        -:  395:  //if stack of Province cards is empty, the game ends
      156:  396:  if (state->supplyCount[province] == 0)
        -:  397:    {
        6:  398:      return 1;
        -:  399:    }
        -:  400:
        -:  401:  //if three supply pile are at 0, the game ends
      150:  402:    j = 0;
     3900:  403:    for (i = 0; i < 25; i++)
        -:  404:    {
     3750:  405:      if (state->supplyCount[i] == 0)
        -:  406:        {
      258:  407:          j++;
        -:  408:        }
        -:  409:    }
      150:  410:    if ( j >= 3)
        -:  411:    {
       40:  412:      return 1;
        -:  413:    }
        -:  414:
      110:  415:  return 0;
        -:  416:}
        -:  417:
    #####:  418:int scoreFor (int player, struct gameState *state) {
        -:  419:
        -:  420:  int i;
    #####:  421:  int score = 0;
        -:  422:  //score from hand
    #####:  423:  for (i = 0; i < state->handCount[player]; i++)
        -:  424:    {
    #####:  425:      if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  426:      if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  427:      if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  428:      if (state->hand[player][i] == province) { score = score + 6; };
    #####:  429:      if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  430:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  431:    }
        -:  432:
        -:  433:  //score from discard
    #####:  434:  for (i = 0; i < state->discardCount[player]; i++)
        -:  435:    {
    #####:  436:      if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  437:      if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  438:      if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  439:      if (state->discard[player][i] == province) { score = score + 6; };
    #####:  440:      if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  441:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  442:    }
        -:  443:
        -:  444:  //score from deck
    #####:  445:  for (i = 0; i < state->discardCount[player]; i++)
        -:  446:    {
    #####:  447:      if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  448:      if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  449:      if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  450:      if (state->deck[player][i] == province) { score = score + 6; };
    #####:  451:      if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  452:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  453:    }
        -:  454:
    #####:  455:  return score;
        -:  456:}
        -:  457:
    #####:  458:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  459:  int i;	
        -:  460:  int j;
        -:  461:  int highScore;
        -:  462:  int currentPlayer;
        -:  463:
        -:  464:  //get score for each player
    #####:  465:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  466:    {
        -:  467:      //set unused player scores to -9999
    #####:  468:      if (i >= state->numPlayers)
        -:  469:	{
    #####:  470:	  players[i] = -9999;
        -:  471:	}
        -:  472:      else
        -:  473:	{
    #####:  474:	  players[i] = scoreFor (i, state);
        -:  475:	}
        -:  476:    }
        -:  477:
        -:  478:  //find highest score
    #####:  479:  j = 0;
    #####:  480:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  481:    {
    #####:  482:      if (players[i] > players[j])
        -:  483:	{
    #####:  484:	  j = i;
        -:  485:	}
        -:  486:    }
    #####:  487:  highScore = players[j];
        -:  488:
        -:  489:  //add 1 to players who had less turns
    #####:  490:  currentPlayer = whoseTurn(state);
    #####:  491:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  492:    {
    #####:  493:      if ( players[i] == highScore && i > currentPlayer )
        -:  494:	{
    #####:  495:	  players[i]++;
        -:  496:	}
        -:  497:    }
        -:  498:
        -:  499:  //find new highest score
    #####:  500:  j = 0;
    #####:  501:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  502:    {
    #####:  503:      if ( players[i] > players[j] )
        -:  504:	{
    #####:  505:	  j = i;
        -:  506:	}
        -:  507:    }
    #####:  508:  highScore = players[j];
        -:  509:
        -:  510:  //set winners in array to 1 and rest to 0
    #####:  511:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  512:    {
    #####:  513:      if ( players[i] == highScore )
        -:  514:	{
    #####:  515:	  players[i] = 1;
        -:  516:	}
        -:  517:      else
        -:  518:	{
    #####:  519:	  players[i] = 0;
        -:  520:	}
        -:  521:    }
        -:  522:
    #####:  523:  return 0;
        -:  524:}
        -:  525:
  2973575:  526:int drawCard(int player, struct gameState *state)
        -:  527:{	int count;
        -:  528:  int deckCounter;
  2973575:  529:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  530:    
        -:  531:    //Step 1 Shuffle the discard pile back into a deck
        -:  532:    int i;
        -:  533:    //Move discard to deck
    11904:  534:    for (i = 0; i < state->discardCount[player];i++){
     9920:  535:      state->deck[player][i] = state->discard[player][i];
     9920:  536:      state->discard[player][i] = -1;
        -:  537:    }
        -:  538:
     1984:  539:    state->deckCount[player] = state->discardCount[player];
     1984:  540:    state->discardCount[player] = 0;//Reset discard
        -:  541:
        -:  542:    //Shufffle the deck
     1984:  543:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  544:   
        -:  545:    if (DEBUG){//Debug statements
        -:  546:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  547:    }
        -:  548:    
     1984:  549:    state->discardCount[player] = 0;
        -:  550:
        -:  551:    //Step 2 Draw Card
     1984:  552:    count = state->handCount[player];//Get current player's hand count
        -:  553:    
        -:  554:    if (DEBUG){//Debug statements
        -:  555:      printf("Current hand count: %d\n", count);
        -:  556:    }
        -:  557:    
     1984:  558:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  559:
     1984:  560:    if (deckCounter == 0)
    #####:  561:      return -1;
        -:  562:
     1984:  563:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
     1984:  564:    state->deckCount[player]--;
     1984:  565:    state->handCount[player]++;//Increment hand count
        -:  566:  }
        -:  567:
        -:  568:  else{
  2971591:  569:    int count = state->handCount[player];//Get current hand count for player
        -:  570:    int deckCounter;
        -:  571:    if (DEBUG){//Debug statements
        -:  572:      printf("Current hand count: %d\n", count);
        -:  573:    }
        -:  574:
  2971591:  575:    deckCounter = state->deckCount[player];//Create holder for the deck count
  2971591:  576:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
  2971591:  577:    state->deckCount[player]--;
  2971591:  578:    state->handCount[player]++;//Increment hand count
        -:  579:  }
        -:  580:
  2973575:  581:  return 0;
        -:  582:}
        -:  583:
       56:  584:int getCost(int cardNumber)
        -:  585:{
       56:  586:  switch( cardNumber ) 
        -:  587:    {
        -:  588:    case curse:
        2:  589:      return 0;
        -:  590:    case estate:
        2:  591:      return 2;
        -:  592:    case duchy:
        2:  593:      return 5;
        -:  594:    case province:
        2:  595:      return 8;
        -:  596:    case copper:
        2:  597:      return 0;
        -:  598:    case silver:
        2:  599:      return 3;
        -:  600:    case gold:
        2:  601:      return 6;
        -:  602:    case adventurer:
        2:  603:      return 6;
        -:  604:    case council_room:
        2:  605:      return 5;
        -:  606:    case feast:
        2:  607:      return 4;
        -:  608:    case gardens:
        2:  609:      return 4;
        -:  610:    case mine:
        2:  611:      return 5;
        -:  612:    case remodel:
        2:  613:      return 4;
        -:  614:    case smithy:
        2:  615:      return 4;
        -:  616:    case village:
        2:  617:      return 3;
        -:  618:    case baron:
        2:  619:      return 4;
        -:  620:    case great_hall:
        2:  621:      return 3;
        -:  622:    case minion:
        2:  623:      return 5;
        -:  624:    case steward:
        2:  625:      return 3;
        -:  626:    case tribute:
        2:  627:      return 5;
        -:  628:    case ambassador:
        2:  629:      return 3;
        -:  630:    case cutpurse:
        2:  631:      return 4;
        -:  632:    case embargo: 
        2:  633:      return 2;
        -:  634:    case outpost:
        2:  635:      return 5;
        -:  636:    case salvager:
        2:  637:      return 4;
        -:  638:    case sea_hag:
        2:  639:      return 4;
        -:  640:    case treasure_map:
        2:  641:      return 4;
        -:  642:    }
        -:  643:	
        2:  644:  return -1;
        -:  645:}
        -:  646:
        -:  647:
    #####:  648:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  649:{
        -:  650:  int i;
        -:  651:  int j;
        -:  652://  int k;
        -:  653:  int x;
        -:  654:  int index;
    #####:  655:  int currentPlayer = whoseTurn(state);
    #####:  656:  int nextPlayer = currentPlayer + 1;
        -:  657:
    #####:  658:  int tributeRevealedCards[2] = {-1, -1};
        -:  659:  int temphand[MAX_HAND];// moved above the if statement
    #####:  660:  int drawntreasure=0;
        -:  661:  int cardDrawn;
    #####:  662:  int z = 0;// this is the counter for the temp hand
    #####:  663:  if (nextPlayer > (state->numPlayers - 1)){
    #####:  664:    nextPlayer = 0;
        -:  665:  }
        -:  666:  
        -:  667:	
        -:  668:  //uses switch to select card and perform actions
    #####:  669:  switch( card ) 
        -:  670:    {
        -:  671:    case adventurer:
    #####:  672:	 return playAdventurer(state);
        -:  673:			
        -:  674:    case council_room:
    #####:  675:	  return playCouncil_Room(state, handPos);
        -:  676:			
        -:  677:    case feast:
        -:  678:      //gain card with cost up to 5
        -:  679:      //Backup hand
    #####:  680:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  681:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  682:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  683:      }
        -:  684:      //Backup hand
        -:  685:
        -:  686:      //Update Coins for Buy
    #####:  687:      updateCoins(currentPlayer, state, 5);
    #####:  688:      x = 1;//Condition to loop on
    #####:  689:      while( x == 1) {//Buy one card
    #####:  690:	if (supplyCount(choice1, state) <= 0){
        -:  691:	  if (DEBUG)
        -:  692:	    printf("None of that card left, sorry!\n");
        -:  693:
        -:  694:	  if (DEBUG){
        -:  695:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  696:	  }
        -:  697:	}
    #####:  698:	else if (state->coins < getCost(choice1)){
    #####:  699:	  printf("That card is too expensive!\n");
        -:  700:
        -:  701:	  if (DEBUG){
        -:  702:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  703:	  }
        -:  704:	}
        -:  705:	else{
        -:  706:
        -:  707:	  if (DEBUG){
        -:  708:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  709:	  }
        -:  710:
    #####:  711:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  712:	  x = 0;//No more buying cards
        -:  713:
        -:  714:	  if (DEBUG){
        -:  715:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  716:	  }
        -:  717:
        -:  718:	}
        -:  719:      }     
        -:  720:
        -:  721:      //Reset Hand
    #####:  722:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  723:	state->hand[currentPlayer][i] = temphand[i];
    #####:  724:	temphand[i] = -1;
        -:  725:      }
        -:  726:      //Reset Hand
        -:  727:      			
    #####:  728:      return 0;
        -:  729:			
        -:  730:    case gardens:
    #####:  731:      return -1;
        -:  732:			
        -:  733:    case mine:
    #####:  734:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  735:
    #####:  736:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  737:	{
    #####:  738:	  return -1;
        -:  739:	}
        -:  740:		
    #####:  741:      if (choice2 > treasure_map || choice2 < curse)
        -:  742:	{
    #####:  743:	  return -1;
        -:  744:	}
        -:  745:
    #####:  746:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
        -:  747:	{
    #####:  748:	  return -1;
        -:  749:	}
        -:  750:
    #####:  751:      gainCard(choice2, state, 2, currentPlayer);
        -:  752:
        -:  753:      //discard card from hand
    #####:  754:      discardCard(handPos, currentPlayer, state, 0);
        -:  755:
        -:  756:      //discard trashed card
    #####:  757:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  758:	{
    #####:  759:	  if (state->hand[currentPlayer][i] == j)
        -:  760:	    {
    #####:  761:	      discardCard(i, currentPlayer, state, 0);			
    #####:  762:	      break;
        -:  763:	    }
        -:  764:	}
        -:  765:			
    #####:  766:      return 0;
        -:  767:			
        -:  768:    case remodel:
    #####:  769:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  770:
    #####:  771:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  772:	{
    #####:  773:	  return -1;
        -:  774:	}
        -:  775:
    #####:  776:      gainCard(choice2, state, 0, currentPlayer);
        -:  777:
        -:  778:      //discard card from hand
    #####:  779:      discardCard(handPos, currentPlayer, state, 0);
        -:  780:
        -:  781:      //discard trashed card
    #####:  782:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  783:	{
    #####:  784:	  if (state->hand[currentPlayer][i] == j)
        -:  785:	    {
    #####:  786:	      discardCard(i, currentPlayer, state, 0);			
    #####:  787:	      break;
        -:  788:	    }
        -:  789:	}
        -:  790:
        -:  791:
    #####:  792:      return 0;
        -:  793:		
        -:  794:    case smithy:
    #####:  795:	  return playSmithy(state, handPos);
        -:  796:      /* //+3 Cards
        -:  797:      for (i = 0; i < 3; i++)
        -:  798:	  {
        -:  799:	    drawCard(currentPlayer, state);
        -:  800:	  }
        -:  801:			
        -:  802:      //discard card from hand
        -:  803:      discardCard(handPos, currentPlayer, state, 0);
        -:  804:      return 0; */
        -:  805:		
        -:  806:    case village:
    #####:  807:        return playVillage(state, handPos);
        -:  808:      /*
        -:  809:      //+1 Card
        -:  810:      drawCard(currentPlayer, state);
        -:  811:			
        -:  812:      //+2 Actions
        -:  813:      state->numActions = state->numActions + 2;
        -:  814:			
        -:  815:      //discard played card from hand
        -:  816:      discardCard(handPos, currentPlayer, state, 0);
        -:  817:      return 0;
        -:  818:       */	
        -:  819:    case baron:
    #####:  820:      state->numBuys++;//Increase buys by 1!
    #####:  821:      if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  822:	int p = 0;//Iterator for hand!
    #####:  823:	int card_not_discarded = 1;//Flag for discard set!
    #####:  824:	while(card_not_discarded){
    #####:  825:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
    #####:  826:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  827:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  828:	    state->discardCount[currentPlayer]++;
    #####:  829:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:  830:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  831:	    }
    #####:  832:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  833:	    state->handCount[currentPlayer]--;
    #####:  834:	    card_not_discarded = 0;//Exit the loop
        -:  835:	  }
    #####:  836:	  else if (p > state->handCount[currentPlayer]){
        -:  837:	    if(DEBUG) {
        -:  838:	      printf("No estate cards in your hand, invalid choice\n");
        -:  839:	      printf("Must gain an estate if there are any\n");
        -:  840:	    }
    #####:  841:	    if (supplyCount(estate, state) > 0){
    #####:  842:	      gainCard(estate, state, 0, currentPlayer);
    #####:  843:	      state->supplyCount[estate]--;//Decrement estates
    #####:  844:	      if (supplyCount(estate, state) == 0){
    #####:  845:		isGameOver(state);
        -:  846:	      }
        -:  847:	    }
    #####:  848:	    card_not_discarded = 0;//Exit the loop
        -:  849:	  }
        -:  850:			    
        -:  851:	  else{
    #####:  852:	    p++;//Next card
        -:  853:	  }
        -:  854:	}
        -:  855:      }
        -:  856:			    
        -:  857:      else{
    #####:  858:	if (supplyCount(estate, state) > 0){
    #####:  859:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  860:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  861:	  if (supplyCount(estate, state) == 0){
    #####:  862:	    isGameOver(state);
        -:  863:	  }
        -:  864:	}
        -:  865:      }
        -:  866:	    
        -:  867:      
    #####:  868:      return 0;
        -:  869:		
        -:  870:    case great_hall:
        -:  871:      //+1 Card
    #####:  872:      drawCard(currentPlayer, state);
        -:  873:			
        -:  874:      //+1 Actions
    #####:  875:      state->numActions++;
        -:  876:			
        -:  877:      //discard card from hand
    #####:  878:      discardCard(handPos, currentPlayer, state, 0);
    #####:  879:      return 0;
        -:  880:		
        -:  881:    case minion:
        -:  882:      //+1 action
    #####:  883:      state->numActions++;
        -:  884:			
        -:  885:      //discard card from hand
    #####:  886:      discardCard(handPos, currentPlayer, state, 0);
        -:  887:			
    #####:  888:      if (choice1)		//+2 coins
        -:  889:	{
    #####:  890:	  state->coins = state->coins + 2;
        -:  891:	}
        -:  892:			
    #####:  893:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  894:	{
        -:  895:	  //discard hand
    #####:  896:	  while(numHandCards(state) > 0)
        -:  897:	    {
    #####:  898:	      discardCard(handPos, currentPlayer, state, 0);
        -:  899:	    }
        -:  900:				
        -:  901:	  //draw 4
    #####:  902:	  for (i = 0; i < 4; i++)
        -:  903:	    {
    #####:  904:	      drawCard(currentPlayer, state);
        -:  905:	    }
        -:  906:				
        -:  907:	  //other players discard hand and redraw if hand size > 4
    #####:  908:	  for (i = 0; i < state->numPlayers; i++)
        -:  909:	    {
    #####:  910:	      if (i != currentPlayer)
        -:  911:		{
    #####:  912:		  if ( state->handCount[i] > 4 )
        -:  913:		    {
        -:  914:		      //discard hand
    #####:  915:		      while( state->handCount[i] > 0 )
        -:  916:			{
    #####:  917:			  discardCard(handPos, i, state, 0);
        -:  918:			}
        -:  919:							
        -:  920:		      //draw 4
    #####:  921:		      for (j = 0; j < 4; j++)
        -:  922:			{
    #####:  923:			  drawCard(i, state);
        -:  924:			}
        -:  925:		    }
        -:  926:		}
        -:  927:	    }
        -:  928:				
        -:  929:	}
    #####:  930:      return 0;
        -:  931:		
        -:  932:    case steward:
    #####:  933:	  return playSteward(state, handPos, choice1, choice2, choice3);
        -:  934:
        -:  935:		
        -:  936:    case tribute:
    #####:  937:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####:  938:	if (state->deckCount[nextPlayer] > 0){
    #####:  939:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  940:	  state->deckCount[nextPlayer]--;
        -:  941:	}
    #####:  942:	else if (state->discardCount[nextPlayer] > 0){
    #####:  943:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  944:	  state->discardCount[nextPlayer]--;
        -:  945:	}
        -:  946:	else{
        -:  947:	  //No Card to Reveal
        -:  948:	  if (DEBUG){
        -:  949:	    printf("No cards to reveal\n");
        -:  950:	  }
        -:  951:	}
        -:  952:      }
        -:  953:	    
        -:  954:      else{
    #####:  955:	if (state->deckCount[nextPlayer] == 0){
    #####:  956:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####:  957:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  958:	    state->deckCount[nextPlayer]++;
    #####:  959:	    state->discard[nextPlayer][i] = -1;
    #####:  960:	    state->discardCount[nextPlayer]--;
        -:  961:	  }
        -:  962:			    
    #####:  963:	  shuffle(nextPlayer,state);//Shuffle the deck
        -:  964:	} 
    #####:  965:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  966:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  967:	state->deckCount[nextPlayer]--;
    #####:  968:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  969:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  970:	state->deckCount[nextPlayer]--;
        -:  971:      }    
        -:  972:		       
    #####:  973:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####:  974:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  975:	state->playedCardCount++;
    #####:  976:	tributeRevealedCards[1] = -1;
        -:  977:      } 
        -:  978:
    #####:  979:      for (i = 0; i <= 2; i ++){
    #####:  980:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####:  981:	  state->coins += 2;
        -:  982:	}
        -:  983:		    
    #####:  984:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####:  985:	  drawCard(currentPlayer, state);
    #####:  986:	  drawCard(currentPlayer, state);
        -:  987:	}
        -:  988:	else{//Action Card
    #####:  989:	  state->numActions = state->numActions + 2;
        -:  990:	}
        -:  991:      }
        -:  992:	    
    #####:  993:      return 0;
        -:  994:		
        -:  995:    case ambassador:
    #####:  996:      j = 0;		//used to check if player has enough cards to discard
        -:  997:
    #####:  998:      if (choice2 > 2 || choice2 < 0)
        -:  999:	{
    #####: 1000:	  return -1;				
        -: 1001:	}
        -: 1002:
    #####: 1003:      if (choice1 == handPos)
        -: 1004:	{
    #####: 1005:	  return -1;
        -: 1006:	}
        -: 1007:
    #####: 1008:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1009:	{
    #####: 1010:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1011:	    {
    #####: 1012:	      j++;
        -: 1013:	    }
        -: 1014:	}
    #####: 1015:      if (j < choice2)
        -: 1016:	{
    #####: 1017:	  return -1;				
        -: 1018:	}
        -: 1019:
        -: 1020:      if (DEBUG) 
        -: 1021:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1022:
        -: 1023:      //increase supply count for choosen card by amount being discarded
    #####: 1024:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1025:			
        -: 1026:      //each other player gains a copy of revealed card
    #####: 1027:      for (i = 0; i < state->numPlayers; i++)
        -: 1028:	{
    #####: 1029:	  if (i != currentPlayer)
        -: 1030:	    {
    #####: 1031:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1032:	    }
        -: 1033:	}
        -: 1034:
        -: 1035:      //discard played card from hand
    #####: 1036:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1037:
        -: 1038:      //trash copies of cards returned to supply
    #####: 1039:      for (j = 0; j < choice2; j++)
        -: 1040:	{
    #####: 1041:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1042:	    {
    #####: 1043:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1044:		{
    #####: 1045:		  discardCard(i, currentPlayer, state, 1);
    #####: 1046:		  break;
        -: 1047:		}
        -: 1048:	    }
        -: 1049:	}			
        -: 1050:
    #####: 1051:      return 0;
        -: 1052:		
        -: 1053:    case cutpurse:
        -: 1054:
        -: 1055:/*       updateCoins(currentPlayer, state, 2);
        -: 1056:      for (i = 0; i < state->numPlayers; i++)
        -: 1057:	{
        -: 1058:	  if (i != currentPlayer)
        -: 1059:	    {
        -: 1060:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1061:		{
        -: 1062:		  if (state->hand[i][j] == copper)
        -: 1063:		    {
        -: 1064:		      discardCard(j, i, state, 0);
        -: 1065:		      break;
        -: 1066:		    }
        -: 1067:		  if (j == state->handCount[i])
        -: 1068:		    {
        -: 1069:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1070:			{
        -: 1071:			  if (DEBUG)
        -: 1072:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1073:			}	
        -: 1074:		      break;
        -: 1075:		    }		
        -: 1076:		}
        -: 1077:					
        -: 1078:	    }
        -: 1079:				
        -: 1080:	}				
        -: 1081:
        -: 1082:      //discard played card from hand
        -: 1083:      discardCard(handPos, currentPlayer, state, 0); */			
        -: 1084:
    #####: 1085:      return playCutpurse(state, handPos);
        -: 1086:
        -: 1087:		
        -: 1088:    case embargo: 
        -: 1089:      //+2 Coins
    #####: 1090:      state->coins = state->coins + 2;
        -: 1091:			
        -: 1092:      //see if selected pile is in play
    #####: 1093:      if ( state->supplyCount[choice1] == -1 )
        -: 1094:	{
    #####: 1095:	  return -1;
        -: 1096:	}
        -: 1097:			
        -: 1098:      //add embargo token to selected supply pile
    #####: 1099:      state->embargoTokens[choice1]++;
        -: 1100:			
        -: 1101:      //trash card
    #####: 1102:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1103:      return 0;
        -: 1104:		
        -: 1105:    case outpost:
        -: 1106:      //set outpost flag
    #####: 1107:      state->outpostPlayed++;
        -: 1108:			
        -: 1109:      //discard card
    #####: 1110:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1111:      return 0;
        -: 1112:		
        -: 1113:    case salvager:
        -: 1114:      //+1 buy
    #####: 1115:      state->numBuys++;
        -: 1116:			
    #####: 1117:      if (choice1)
        -: 1118:	{
        -: 1119:	  //gain coins equal to trashed card
    #####: 1120:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1121:	  //trash card
    #####: 1122:	  discardCard(choice1, currentPlayer, state, 1);	
        -: 1123:	}
        -: 1124:			
        -: 1125:      //discard card
    #####: 1126:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1127:      return 0;
        -: 1128:		
        -: 1129:    case sea_hag:
    #####: 1130:      for (i = 0; i < state->numPlayers; i++){
    #####: 1131:	if (i != currentPlayer){
    #####: 1132:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1133:	  state->discardCount[i]++;
    #####: 1134:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1135:	}
        -: 1136:      }
    #####: 1137:      return 0;
        -: 1138:		
        -: 1139:    case treasure_map:
        -: 1140:      //search hand for another treasure_map
    #####: 1141:      index = -1;
    #####: 1142:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1143:	{
    #####: 1144:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1145:	    {
    #####: 1146:	      index = i;
    #####: 1147:	      break;
        -: 1148:	    }
        -: 1149:	}
    #####: 1150:      if (index > -1)
        -: 1151:	{
        -: 1152:	  //trash both treasure cards
    #####: 1153:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1154:	  discardCard(index, currentPlayer, state, 1);
        -: 1155:
        -: 1156:	  //gain 4 Gold cards
    #####: 1157:	  for (i = 0; i < 4; i++)
        -: 1158:	    {
    #####: 1159:	      gainCard(gold, state, 1, currentPlayer);
        -: 1160:	    }
        -: 1161:				
        -: 1162:	  //return success
    #####: 1163:	  return 1;
        -: 1164:	}
        -: 1165:			
        -: 1166:      //no second treasure_map found in hand
    #####: 1167:      return -1;
        -: 1168:    }
        -: 1169:	
    #####: 1170:  return -1;
        -: 1171:}
        -: 1172:
     3968: 1173:int playAdventurer(struct gameState *state){
     3968: 1174:	int drawntreasure = 0;
        -: 1175:	int cardDrawn;
     3968: 1176:	int currentPlayer = whoseTurn(state);
        -: 1177:    int temphand[MAX_HAND];// moved above the if statement
     3968: 1178:    int z = 0;// this is the counter for the temp hand
        -: 1179:
        -: 1180:	
    23312: 1181:	while(drawntreasure<3){
    15376: 1182:		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
     1984: 1183:		  shuffle(currentPlayer, state);
        -: 1184:		}
    15376: 1185:		drawCard(currentPlayer, state);
    15376: 1186:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    15376: 1187:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    11904: 1188:		  drawntreasure++;
        -: 1189:		else{
     3472: 1190:		  temphand[z]=cardDrawn;
     3472: 1191:		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
     3472: 1192:		  z++;
        -: 1193:		}
        -: 1194:	  }
    11408: 1195:	  while(z-1>=0){
     3472: 1196:		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
     3472: 1197:	   z=z-1;
        -: 1198:	  }
        -: 1199:	  
     3968: 1200:	return 0;
        -: 1201:}
        -: 1202:
        -: 1203://Add 4 cards
    #####: 1204:int playCouncil_Room(struct gameState *state, int handPos){
    #####: 1205:	int currentPlayer = whoseTurn(state);
        -: 1206:	int i;
        -: 1207:  
    #####: 1208:    for (i = 0; i < 5; i++)
        -: 1209:	{
    #####: 1210:	  drawCard(currentPlayer, state);
        -: 1211:	}
        -: 1212:			
        -: 1213:    //+1 Buy
    #####: 1214:    state->numBuys++;
        -: 1215:			
        -: 1216:    //Each other player draws a card
    #####: 1217:    for (i = 0; i < state->numPlayers; i++)
        -: 1218:	{
    #####: 1219:	  if ( i != currentPlayer )
        -: 1220:	  {
    #####: 1221:	    drawCard(i, state);
        -: 1222:	  }
        -: 1223:	}
        -: 1224:			
        -: 1225:    //put played card in played card pile
    #####: 1226:    discardCard(handPos, currentPlayer, state, 0);
    #####: 1227:	return 0;
        -: 1228:}
        -: 1229:
   986048: 1230:int playSmithy(struct gameState *state, int handPos){
        -: 1231:    int i;
   986048: 1232:    int currentPlayer = whoseTurn(state);
        -: 1233:
        -: 1234:    //+3 Cards
  3944192: 1235:    for (i = 0; i < 3; i++)
        -: 1236:    {
  2958144: 1237:      drawCard(currentPlayer, state);
        -: 1238:    }
        -: 1239:    	
        -: 1240:    //discard card from hand
   986048: 1241:    discardCard(handPos, currentPlayer, state, 0-1);
   986048: 1242:    return 0;
        -: 1243:}
        -: 1244:
    #####: 1245:int playCutpurse(struct gameState *state, int handPos){
        -: 1246:	int i, j, k;
    #####: 1247:	int currentPlayer = whoseTurn(state);
        -: 1248:
        -: 1249:	
    #####: 1250:    updateCoins(currentPlayer, state, 2);
    #####: 1251:    for (i = 0; i < state->numPlayers; i++)
        -: 1252:	{
    #####: 1253:	  if (i != currentPlayer)
        -: 1254:	  {
    #####: 1255:	    for (j = 0; j <= state->handCount[i]; j++){
    #####: 1256:          if (state->hand[i][j] == copper){
    #####: 1257:	        discardCard(j, i, state, 0);
    #####: 1258:		    return -1;
        -: 1259:	      }
    #####: 1260:	      if (j = state->handCount[i]){
    #####: 1261:            for (k = 0; k < state->handCount[i]; k++){
        -: 1262:		      if (DEBUG)
        -: 1263:                printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1264:            }	
    #####: 1265:		  return -1;
        -: 1266:          }		
        -: 1267:		}
        -: 1268:					
        -: 1269:	  }//end != currentPlayer switch		
        -: 1270:	}
        -: 1271:
        -: 1272:    //discard played card from hand
    #####: 1273:	discardCard(handPos, currentPlayer, state, 0);
        -: 1274:	
    #####: 1275:	return 0;
        -: 1276:}
        -: 1277:
    #####: 1278:int playSteward(struct gameState *state, int handPos, int choice1, int choice2, int choice3){
    #####: 1279:  int currentPlayer = whoseTurn(state);
        -: 1280:
    #####: 1281:  if (choice1 == 1) {
        -: 1282:  //+2 cards
    #####: 1283:    drawCard(currentPlayer, state);
    #####: 1284:    drawCard(currentPlayer, state);
        -: 1285:  }
    #####: 1286:  else if (choice1 == 2) {
        -: 1287:  //+2 coins
    #####: 1288:    state->coins = state->coins + 2;
        -: 1289:  }
        -: 1290:  else {
        -: 1291:  //trash 2 cards in hand
    #####: 1292:    discardCard(choice2, currentPlayer, state, 1);
    #####: 1293:    discardCard(choice3, currentPlayer, state, 1);
        -: 1294:  }
        -: 1295:	
        -: 1296:  //discard card from hand
    #####: 1297:  discardCard(handPos, currentPlayer, state, 0);
    #####: 1298:  return 0;
        -: 1299:}
        -: 1300:
    #####: 1301:int playVillage(struct gameState *state, int handPos){
    #####: 1302:    int currentPlayer = whoseTurn(state);
        -: 1303:
        -: 1304:    //+1 Card
    #####: 1305:     drawCard(currentPlayer, state);
        -: 1306:
        -: 1307:     //+2 Actions
    #####: 1308:     state->numActions = state->numActions + 2;
        -: 1309:
        -: 1310:     //discard played card from hand
    #####: 1311:     discardCard(handPos, currentPlayer, state, 0);
    #####: 1312:     return 0;
        -: 1313:}
        -: 1314:
   986048: 1315:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1316:{
        -: 1317:	
        -: 1318:  //if card is not trashed, added to Played pile 
   986048: 1319:  if (trashFlag < 1)
        -: 1320:    {
        -: 1321:      //add card to played pile
   986048: 1322:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
   986048: 1323:      state->playedCardCount++;
        -: 1324:    }
        -: 1325:	
        -: 1326:  //set played card to -1
   986048: 1327:  state->hand[currentPlayer][handPos] = -1;
        -: 1328:	
        -: 1329:  //remove card from player's hand
   986048: 1330:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1331:    {
        -: 1332:      //reduce number of cards in hand
    #####: 1333:      state->handCount[currentPlayer]--;
        -: 1334:    }
   986048: 1335:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1336:    {
        -: 1337:      //reduce number of cards in hand
    #####: 1338:      state->handCount[currentPlayer]--;
        -: 1339:    }
        -: 1340:  else 	
        -: 1341:    {
        -: 1342:      //replace discarded card with last card in hand
   986048: 1343:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1344:      //set last card to -1
   986048: 1345:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1346:      //reduce number of cards in hand
   986048: 1347:      state->handCount[currentPlayer]--;
        -: 1348:    }
        -: 1349:	
   986048: 1350:  return 0;
        -: 1351:}
        -: 1352:
    #####: 1353:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1354:{
        -: 1355:  //Note: supplyPos is enum of choosen card
        -: 1356:	
        -: 1357:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1358:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1359:    {
    #####: 1360:      return -1;
        -: 1361:    }
        -: 1362:	
        -: 1363:  //added card for [whoseTurn] current player:
        -: 1364:  // toFlag = 0 : add to discard
        -: 1365:  // toFlag = 1 : add to deck
        -: 1366:  // toFlag = 2 : add to hand
        -: 1367:
    #####: 1368:  if (toFlag == 1)
        -: 1369:    {
    #####: 1370:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1371:      state->deckCount[player]++;
        -: 1372:    }
    #####: 1373:  else if (toFlag == 2)
        -: 1374:    {
    #####: 1375:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1376:      state->handCount[player]++;
        -: 1377:    }
        -: 1378:  else
        -: 1379:    {
    #####: 1380:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1381:      state->discardCount[player]++;
        -: 1382:    }
        -: 1383:	
        -: 1384:  //decrease number in supply pile
    #####: 1385:  state->supplyCount[supplyPos]--;
        -: 1386:	 
    #####: 1387:  return 0;
        -: 1388:}
        -: 1389:
      815: 1390:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1391:{
        -: 1392:  int i;
        -: 1393:	
        -: 1394:  //reset coin count
      815: 1395:  state->coins = 0;
        -: 1396:
        -: 1397:  //add coins for each Treasure card in player's hand
     3880: 1398:  for (i = 0; i < state->handCount[player]; i++)
        -: 1399:    {
     3065: 1400:      if (state->hand[player][i] == copper)
        -: 1401:	{
     1052: 1402:	  state->coins += 1;
        -: 1403:	}
     2013: 1404:      else if (state->hand[player][i] == silver)
        -: 1405:	{
     1000: 1406:	  state->coins += 2;
        -: 1407:	}
     1013: 1408:      else if (state->hand[player][i] == gold)
        -: 1409:	{
     1000: 1410:	  state->coins += 3;
        -: 1411:	}	
        -: 1412:    }	
        -: 1413:
        -: 1414:  //add bonus
      815: 1415:  state->coins += bonus;
        -: 1416:
      815: 1417:  return 0;
        -: 1418:}
        -: 1419:
        -: 1420:
        -: 1421://end of dominion.c
        -: 1422:

Testing playVillage() with seed 1234
Game Initialized! :)

__ALL TESTS PASSED!__

File 'dominion.c'
Lines executed:34.33% of 568
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:13
        -:    0:Programs:7
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
    20440:    8:int compare(const void* a, const void* b) {
    20440:    9:  if (*(int*)a > *(int*)b)
    #####:   10:    return 1;
    20440:   11:  if (*(int*)a < *(int*)b)
      160:   12:    return -1;
    20280:   13:  return 0;
        -:   14:}
        -:   15:
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
        -:   21:
    #####:   22:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   23:		  int k8, int k9, int k10) {
    #####:   24:  int* k = malloc(10 * sizeof(int));
    #####:   25:  k[0] = k1;
    #####:   26:  k[1] = k2;
    #####:   27:  k[2] = k3;
    #####:   28:  k[3] = k4;
    #####:   29:  k[4] = k5;
    #####:   30:  k[5] = k6;
    #####:   31:  k[6] = k7;
    #####:   32:  k[7] = k8;
    #####:   33:  k[8] = k9;
    #####:   34:  k[9] = k10;
    #####:   35:  return k;
        -:   36:}
        -:   37:
       13:   38:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   39:		   struct gameState *state) {
        -:   40:
        -:   41:  int i;
        -:   42:  int j;
        -:   43:  int it;			
        -:   44:  //set up random number generator
       13:   45:  SelectStream(1);
       13:   46:  PutSeed((long)randomSeed);
        -:   47:  
        -:   48:  //check number of players
       13:   49:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   50:    {
    #####:   51:      return -1;
        -:   52:    }
        -:   53:
        -:   54:  //set number of players
       13:   55:  state->numPlayers = numPlayers;
        -:   56:
        -:   57:  //check selected kingdom cards are different
      143:   58:  for (i = 0; i < 10; i++)
        -:   59:    {
     1430:   60:      for (j = 0; j < 10; j++)
        -:   61:        {
     1300:   62:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   63:	    {
    #####:   64:	      return -1;
        -:   65:	    }
        -:   66:        }
        -:   67:    }
        -:   68:
        -:   69:
        -:   70:  //initialize supply
        -:   71:  ///////////////////////////////
        -:   72:
        -:   73:  //set number of Curse cards
       13:   74:  if (numPlayers == 2)
        -:   75:    {
        6:   76:      state->supplyCount[curse] = 10;
        -:   77:    }
        7:   78:  else if (numPlayers == 3)
        -:   79:    {
    #####:   80:      state->supplyCount[curse] = 20;
        -:   81:    }
        -:   82:  else
        -:   83:    {
        7:   84:      state->supplyCount[curse] = 30;
        -:   85:    }
        -:   86:
        -:   87:  //set number of Victory cards
       13:   88:  if (numPlayers == 2)
        -:   89:    {
        6:   90:      state->supplyCount[estate] = 8;
        6:   91:      state->supplyCount[duchy] = 8;
        6:   92:      state->supplyCount[province] = 8;
        -:   93:    }
        -:   94:  else
        -:   95:    {
        7:   96:      state->supplyCount[estate] = 12;
        7:   97:      state->supplyCount[duchy] = 12;
        7:   98:      state->supplyCount[province] = 12;
        -:   99:    }
        -:  100:
        -:  101:  //set number of Treasure cards
       13:  102:  state->supplyCount[copper] = 60 - (7 * numPlayers);
       13:  103:  state->supplyCount[silver] = 40;
       13:  104:  state->supplyCount[gold] = 30;
        -:  105:
        -:  106:  //set number of Kingdom cards
      273:  107:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  108:    {
     2145:  109:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  110:	{
     2015:  111:	  if (kingdomCards[j] == i)
        -:  112:	    {
        -:  113:	      //check if card is a 'Victory' Kingdom card
      130:  114:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  115:		{
       26:  116:		  if (numPlayers == 2){ 
        6:  117:		    state->supplyCount[i] = 8; 
        -:  118:		  }
        7:  119:		  else{ state->supplyCount[i] = 12; }
        -:  120:		}
        -:  121:	      else
        -:  122:		{
      117:  123:		  state->supplyCount[i] = 10;
        -:  124:		}
      130:  125:	      break;
        -:  126:	    }
        -:  127:	  else    //card is not in the set choosen for the game
        -:  128:	    {
     1885:  129:	      state->supplyCount[i] = -1;
        -:  130:	    }
        -:  131:	}
        -:  132:
        -:  133:    }
        -:  134:
        -:  135:  ////////////////////////
        -:  136:  //supply intilization complete
        -:  137:
        -:  138:  //set player decks
       53:  139:  for (i = 0; i < numPlayers; i++)
        -:  140:    {
       40:  141:      state->deckCount[i] = 0;
      160:  142:      for (j = 0; j < 3; j++)
        -:  143:	{
      120:  144:	  state->deck[i][j] = estate;
      120:  145:	  state->deckCount[i]++;
        -:  146:	}
      320:  147:      for (j = 3; j < 10; j++)
        -:  148:	{
      280:  149:	  state->deck[i][j] = copper;
      280:  150:	  state->deckCount[i]++;		
        -:  151:	}
        -:  152:    }
        -:  153:
        -:  154:  //shuffle player decks
       53:  155:  for (i = 0; i < numPlayers; i++)
        -:  156:    {
       40:  157:      if ( shuffle(i, state) < 0 )
        -:  158:	{
    #####:  159:	  return -1;
        -:  160:	}
        -:  161:    }
        -:  162:
        -:  163:  //draw player hands
       53:  164:  for (i = 0; i < numPlayers; i++)
        -:  165:    {  
        -:  166:      //initialize hand size to zero
       40:  167:      state->handCount[i] = 0;
       40:  168:      state->discardCount[i] = 0;
        -:  169:      //draw 5 cards
        -:  170:      // for (j = 0; j < 5; j++)
        -:  171:      //	{
        -:  172:      //	  drawCard(i, state);
        -:  173:      //	}
        -:  174:    }
        -:  175:  
        -:  176:  //set embargo tokens to 0 for all supply piles
      364:  177:  for (i = 0; i <= treasure_map; i++)
        -:  178:    {
      351:  179:      state->embargoTokens[i] = 0;
        -:  180:    }
        -:  181:
        -:  182:  //initialize first player's turn
       13:  183:  state->outpostPlayed = 0;
       13:  184:  state->phase = 0;
       13:  185:  state->numActions = 1;
       13:  186:  state->numBuys = 1;
       13:  187:  state->playedCardCount = 0;
       13:  188:  state->whoseTurn = 0;
       13:  189:  state->handCount[state->whoseTurn] = 0;
        -:  190:  //int it; move to top
        -:  191:
        -:  192:  //Moved draw cards to here, only drawing at the start of a turn
       78:  193:  for (it = 0; it < 5; it++){
       65:  194:    drawCard(state->whoseTurn, state);
        -:  195:  }
        -:  196:
       13:  197:  updateCoins(state->whoseTurn, state, 0);
        -:  198:
       13:  199:  return 0;
        -:  200:}
        -:  201:
     7976:  202:int shuffle(int player, struct gameState *state) {
        -:  203: 
        -:  204:
        -:  205:  int newDeck[MAX_DECK];
     7976:  206:  int newDeckPos = 0;
        -:  207:  int card;
        -:  208:  int i;
        -:  209:
     7976:  210:  if (state->deckCount[player] < 1)
     3968:  211:    return -1;
     4008:  212:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  213:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  214:
    28256:  215:  while (state->deckCount[player] > 0) {
    20240:  216:    card = floor(Random() * state->deckCount[player]);
    20240:  217:    newDeck[newDeckPos] = state->deck[player][card];
    20240:  218:    newDeckPos++;
    41067:  219:    for (i = card; i < state->deckCount[player]-1; i++) {
    20827:  220:      state->deck[player][i] = state->deck[player][i+1];
        -:  221:    }
    20240:  222:    state->deckCount[player]--;
        -:  223:  }
    24248:  224:  for (i = 0; i < newDeckPos; i++) {
    20240:  225:    state->deck[player][i] = newDeck[i];
    20240:  226:    state->deckCount[player]++;
        -:  227:  }
        -:  228:
     4008:  229:  return 0;
        -:  230:}
        -:  231:
    #####:  232:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  233:{	
        -:  234:  int card;
    #####:  235:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  236:
        -:  237:  //check if it is the right phase
    #####:  238:  if (state->phase != 0)
        -:  239:    {
    #####:  240:      return -1;
        -:  241:    }
        -:  242:	
        -:  243:  //check if player has enough actions
    #####:  244:  if ( state->numActions < 1 )
        -:  245:    {
    #####:  246:      return -1;
        -:  247:    }
        -:  248:	
        -:  249:  //get card played
    #####:  250:  card = handCard(handPos, state);
        -:  251:	
        -:  252:  //check if selected card is an action
    #####:  253:  if ( card < adventurer || card > treasure_map )
        -:  254:    {
    #####:  255:      return -1;
        -:  256:    }
        -:  257:	
        -:  258:  //play card
    #####:  259:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  260:    {
    #####:  261:      return -1;
        -:  262:    }
        -:  263:	
        -:  264:  //reduce number of actions
    #####:  265:  state->numActions--;
        -:  266:
        -:  267:  //update coins (Treasure cards may be added with card draws)
    #####:  268:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  269:	
    #####:  270:  return 0;
        -:  271:}
        -:  272:
    #####:  273:int buyCard(int supplyPos, struct gameState *state) {
        -:  274:  int who;
        -:  275:  if (DEBUG){
        -:  276:    printf("Entering buyCard...\n");
        -:  277:  }
        -:  278:
        -:  279:  // I don't know what to do about the phase thing.
        -:  280:
    #####:  281:  who = state->whoseTurn;
        -:  282:
    #####:  283:  if (state->numBuys < 1){
        -:  284:    if (DEBUG)
        -:  285:      printf("You do not have any buys left\n");
    #####:  286:    return -1;
    #####:  287:  } else if (supplyCount(supplyPos, state) <1){
        -:  288:    if (DEBUG)
        -:  289:      printf("There are not any of that type of card left\n");
    #####:  290:    return -1;
    #####:  291:  } else if (state->coins < getCost(supplyPos)){
        -:  292:    if (DEBUG) 
        -:  293:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  294:    return -1;
        -:  295:  } else {
    #####:  296:    state->phase=1;
        -:  297:    //state->supplyCount[supplyPos]--;
    #####:  298:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  299:  
    #####:  300:    state->coins = (state->coins) - (getCost(supplyPos));
    #####:  301:    state->numBuys--;
        -:  302:    if (DEBUG)
        -:  303:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  304:  }
        -:  305:
        -:  306:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  307:  //state->discardCount[who]++;
        -:  308:    
    #####:  309:  return 0;
        -:  310:}
        -:  311:
    #####:  312:int numHandCards(struct gameState *state) {
    #####:  313:  return state->handCount[ whoseTurn(state) ];
        -:  314:}
        -:  315:
    #####:  316:int handCard(int handPos, struct gameState *state) {
    #####:  317:  int currentPlayer = whoseTurn(state);
    #####:  318:  return state->hand[currentPlayer][handPos];
        -:  319:}
        -:  320:
    #####:  321:int supplyCount(int card, struct gameState *state) {
    #####:  322:  return state->supplyCount[card];
        -:  323:}
        -:  324:
    #####:  325:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  326:  int i;
    #####:  327:  int count = 0;
        -:  328:
    #####:  329:  for (i = 0; i < state->deckCount[player]; i++)
        -:  330:    {
    #####:  331:      if (state->deck[player][i] == card) count++;
        -:  332:    }
        -:  333:
    #####:  334:  for (i = 0; i < state->handCount[player]; i++)
        -:  335:    {
    #####:  336:      if (state->hand[player][i] == card) count++;
        -:  337:    }
        -:  338:
    #####:  339:  for (i = 0; i < state->discardCount[player]; i++)
        -:  340:    {
    #####:  341:      if (state->discard[player][i] == card) count++;
        -:  342:    }
        -:  343:
    #####:  344:  return count;
        -:  345:}
        -:  346:
   995980:  347:int whoseTurn(struct gameState *state) {
   995980:  348:  return state->whoseTurn;
        -:  349:}
        -:  350:
    #####:  351:int endTurn(struct gameState *state) {
        -:  352:  int k;
        -:  353:  int i;
    #####:  354:  int currentPlayer = whoseTurn(state);
        -:  355:  
        -:  356:  //Discard hand
    #####:  357:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  358:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  359:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  360:  }
    #####:  361:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  362:    
        -:  363:  //Code for determining the player
    #####:  364:  if (currentPlayer < (state->numPlayers - 1)){ 
    #####:  365:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  366:  }
        -:  367:  else{
    #####:  368:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  369:  }
        -:  370:
    #####:  371:  state->outpostPlayed = 0;
    #####:  372:  state->phase = 0;
    #####:  373:  state->numActions = 1;
    #####:  374:  state->coins = 0;
    #####:  375:  state->numBuys = 1;
    #####:  376:  state->playedCardCount = 0;
    #####:  377:  state->handCount[state->whoseTurn] = 0;
        -:  378:
        -:  379:  //int k; move to top
        -:  380:  //Next player draws hand
    #####:  381:  for (k = 0; k < 5; k++){
    #####:  382:    drawCard(state->whoseTurn, state);//Draw a card
        -:  383:  }
        -:  384:
        -:  385:  //Update money
    #####:  386:  updateCoins(state->whoseTurn, state , 0);
        -:  387:
    #####:  388:  return 0;
        -:  389:}
        -:  390:
      156:  391:int isGameOver(struct gameState *state) {
        -:  392:  int i;
        -:  393:  int j;
        -:  394:	
        -:  395:  //if stack of Province cards is empty, the game ends
      156:  396:  if (state->supplyCount[province] == 0)
        -:  397:    {
        6:  398:      return 1;
        -:  399:    }
        -:  400:
        -:  401:  //if three supply pile are at 0, the game ends
      150:  402:    j = 0;
     3900:  403:    for (i = 0; i < 25; i++)
        -:  404:    {
     3750:  405:      if (state->supplyCount[i] == 0)
        -:  406:        {
      258:  407:          j++;
        -:  408:        }
        -:  409:    }
      150:  410:    if ( j >= 3)
        -:  411:    {
       40:  412:      return 1;
        -:  413:    }
        -:  414:
      110:  415:  return 0;
        -:  416:}
        -:  417:
    #####:  418:int scoreFor (int player, struct gameState *state) {
        -:  419:
        -:  420:  int i;
    #####:  421:  int score = 0;
        -:  422:  //score from hand
    #####:  423:  for (i = 0; i < state->handCount[player]; i++)
        -:  424:    {
    #####:  425:      if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  426:      if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  427:      if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  428:      if (state->hand[player][i] == province) { score = score + 6; };
    #####:  429:      if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  430:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  431:    }
        -:  432:
        -:  433:  //score from discard
    #####:  434:  for (i = 0; i < state->discardCount[player]; i++)
        -:  435:    {
    #####:  436:      if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  437:      if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  438:      if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  439:      if (state->discard[player][i] == province) { score = score + 6; };
    #####:  440:      if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  441:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  442:    }
        -:  443:
        -:  444:  //score from deck
    #####:  445:  for (i = 0; i < state->discardCount[player]; i++)
        -:  446:    {
    #####:  447:      if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  448:      if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  449:      if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  450:      if (state->deck[player][i] == province) { score = score + 6; };
    #####:  451:      if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  452:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  453:    }
        -:  454:
    #####:  455:  return score;
        -:  456:}
        -:  457:
    #####:  458:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  459:  int i;	
        -:  460:  int j;
        -:  461:  int highScore;
        -:  462:  int currentPlayer;
        -:  463:
        -:  464:  //get score for each player
    #####:  465:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  466:    {
        -:  467:      //set unused player scores to -9999
    #####:  468:      if (i >= state->numPlayers)
        -:  469:	{
    #####:  470:	  players[i] = -9999;
        -:  471:	}
        -:  472:      else
        -:  473:	{
    #####:  474:	  players[i] = scoreFor (i, state);
        -:  475:	}
        -:  476:    }
        -:  477:
        -:  478:  //find highest score
    #####:  479:  j = 0;
    #####:  480:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  481:    {
    #####:  482:      if (players[i] > players[j])
        -:  483:	{
    #####:  484:	  j = i;
        -:  485:	}
        -:  486:    }
    #####:  487:  highScore = players[j];
        -:  488:
        -:  489:  //add 1 to players who had less turns
    #####:  490:  currentPlayer = whoseTurn(state);
    #####:  491:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  492:    {
    #####:  493:      if ( players[i] == highScore && i > currentPlayer )
        -:  494:	{
    #####:  495:	  players[i]++;
        -:  496:	}
        -:  497:    }
        -:  498:
        -:  499:  //find new highest score
    #####:  500:  j = 0;
    #####:  501:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  502:    {
    #####:  503:      if ( players[i] > players[j] )
        -:  504:	{
    #####:  505:	  j = i;
        -:  506:	}
        -:  507:    }
    #####:  508:  highScore = players[j];
        -:  509:
        -:  510:  //set winners in array to 1 and rest to 0
    #####:  511:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  512:    {
    #####:  513:      if ( players[i] == highScore )
        -:  514:	{
    #####:  515:	  players[i] = 1;
        -:  516:	}
        -:  517:      else
        -:  518:	{
    #####:  519:	  players[i] = 0;
        -:  520:	}
        -:  521:    }
        -:  522:
    #####:  523:  return 0;
        -:  524:}
        -:  525:
  2990945:  526:int drawCard(int player, struct gameState *state)
        -:  527:{	int count;
        -:  528:  int deckCounter;
  2990945:  529:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  530:    
        -:  531:    //Step 1 Shuffle the discard pile back into a deck
        -:  532:    int i;
        -:  533:    //Move discard to deck
    23808:  534:    for (i = 0; i < state->discardCount[player];i++){
    19840:  535:      state->deck[player][i] = state->discard[player][i];
    19840:  536:      state->discard[player][i] = -1;
        -:  537:    }
        -:  538:
     3968:  539:    state->deckCount[player] = state->discardCount[player];
     3968:  540:    state->discardCount[player] = 0;//Reset discard
        -:  541:
        -:  542:    //Shufffle the deck
     3968:  543:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  544:   
        -:  545:    if (DEBUG){//Debug statements
        -:  546:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  547:    }
        -:  548:    
     3968:  549:    state->discardCount[player] = 0;
        -:  550:
        -:  551:    //Step 2 Draw Card
     3968:  552:    count = state->handCount[player];//Get current player's hand count
        -:  553:    
        -:  554:    if (DEBUG){//Debug statements
        -:  555:      printf("Current hand count: %d\n", count);
        -:  556:    }
        -:  557:    
     3968:  558:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  559:
     3968:  560:    if (deckCounter == 0)
    #####:  561:      return -1;
        -:  562:
     3968:  563:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
     3968:  564:    state->deckCount[player]--;
     3968:  565:    state->handCount[player]++;//Increment hand count
        -:  566:  }
        -:  567:
        -:  568:  else{
  2986977:  569:    int count = state->handCount[player];//Get current hand count for player
        -:  570:    int deckCounter;
        -:  571:    if (DEBUG){//Debug statements
        -:  572:      printf("Current hand count: %d\n", count);
        -:  573:    }
        -:  574:
  2986977:  575:    deckCounter = state->deckCount[player];//Create holder for the deck count
  2986977:  576:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
  2986977:  577:    state->deckCount[player]--;
  2986977:  578:    state->handCount[player]++;//Increment hand count
        -:  579:  }
        -:  580:
  2990945:  581:  return 0;
        -:  582:}
        -:  583:
       56:  584:int getCost(int cardNumber)
        -:  585:{
       56:  586:  switch( cardNumber ) 
        -:  587:    {
        -:  588:    case curse:
        2:  589:      return 0;
        -:  590:    case estate:
        2:  591:      return 2;
        -:  592:    case duchy:
        2:  593:      return 5;
        -:  594:    case province:
        2:  595:      return 8;
        -:  596:    case copper:
        2:  597:      return 0;
        -:  598:    case silver:
        2:  599:      return 3;
        -:  600:    case gold:
        2:  601:      return 6;
        -:  602:    case adventurer:
        2:  603:      return 6;
        -:  604:    case council_room:
        2:  605:      return 5;
        -:  606:    case feast:
        2:  607:      return 4;
        -:  608:    case gardens:
        2:  609:      return 4;
        -:  610:    case mine:
        2:  611:      return 5;
        -:  612:    case remodel:
        2:  613:      return 4;
        -:  614:    case smithy:
        2:  615:      return 4;
        -:  616:    case village:
        2:  617:      return 3;
        -:  618:    case baron:
        2:  619:      return 4;
        -:  620:    case great_hall:
        2:  621:      return 3;
        -:  622:    case minion:
        2:  623:      return 5;
        -:  624:    case steward:
        2:  625:      return 3;
        -:  626:    case tribute:
        2:  627:      return 5;
        -:  628:    case ambassador:
        2:  629:      return 3;
        -:  630:    case cutpurse:
        2:  631:      return 4;
        -:  632:    case embargo: 
        2:  633:      return 2;
        -:  634:    case outpost:
        2:  635:      return 5;
        -:  636:    case salvager:
        2:  637:      return 4;
        -:  638:    case sea_hag:
        2:  639:      return 4;
        -:  640:    case treasure_map:
        2:  641:      return 4;
        -:  642:    }
        -:  643:	
        2:  644:  return -1;
        -:  645:}
        -:  646:
        -:  647:
    #####:  648:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  649:{
        -:  650:  int i;
        -:  651:  int j;
        -:  652://  int k;
        -:  653:  int x;
        -:  654:  int index;
    #####:  655:  int currentPlayer = whoseTurn(state);
    #####:  656:  int nextPlayer = currentPlayer + 1;
        -:  657:
    #####:  658:  int tributeRevealedCards[2] = {-1, -1};
        -:  659:  int temphand[MAX_HAND];// moved above the if statement
    #####:  660:  int drawntreasure=0;
        -:  661:  int cardDrawn;
    #####:  662:  int z = 0;// this is the counter for the temp hand
    #####:  663:  if (nextPlayer > (state->numPlayers - 1)){
    #####:  664:    nextPlayer = 0;
        -:  665:  }
        -:  666:  
        -:  667:	
        -:  668:  //uses switch to select card and perform actions
    #####:  669:  switch( card ) 
        -:  670:    {
        -:  671:    case adventurer:
    #####:  672:	 return playAdventurer(state);
        -:  673:			
        -:  674:    case council_room:
    #####:  675:	  return playCouncil_Room(state, handPos);
        -:  676:			
        -:  677:    case feast:
        -:  678:      //gain card with cost up to 5
        -:  679:      //Backup hand
    #####:  680:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  681:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  682:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  683:      }
        -:  684:      //Backup hand
        -:  685:
        -:  686:      //Update Coins for Buy
    #####:  687:      updateCoins(currentPlayer, state, 5);
    #####:  688:      x = 1;//Condition to loop on
    #####:  689:      while( x == 1) {//Buy one card
    #####:  690:	if (supplyCount(choice1, state) <= 0){
        -:  691:	  if (DEBUG)
        -:  692:	    printf("None of that card left, sorry!\n");
        -:  693:
        -:  694:	  if (DEBUG){
        -:  695:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  696:	  }
        -:  697:	}
    #####:  698:	else if (state->coins < getCost(choice1)){
    #####:  699:	  printf("That card is too expensive!\n");
        -:  700:
        -:  701:	  if (DEBUG){
        -:  702:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  703:	  }
        -:  704:	}
        -:  705:	else{
        -:  706:
        -:  707:	  if (DEBUG){
        -:  708:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  709:	  }
        -:  710:
    #####:  711:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  712:	  x = 0;//No more buying cards
        -:  713:
        -:  714:	  if (DEBUG){
        -:  715:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  716:	  }
        -:  717:
        -:  718:	}
        -:  719:      }     
        -:  720:
        -:  721:      //Reset Hand
    #####:  722:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  723:	state->hand[currentPlayer][i] = temphand[i];
    #####:  724:	temphand[i] = -1;
        -:  725:      }
        -:  726:      //Reset Hand
        -:  727:      			
    #####:  728:      return 0;
        -:  729:			
        -:  730:    case gardens:
    #####:  731:      return -1;
        -:  732:			
        -:  733:    case mine:
    #####:  734:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  735:
    #####:  736:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  737:	{
    #####:  738:	  return -1;
        -:  739:	}
        -:  740:		
    #####:  741:      if (choice2 > treasure_map || choice2 < curse)
        -:  742:	{
    #####:  743:	  return -1;
        -:  744:	}
        -:  745:
    #####:  746:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
        -:  747:	{
    #####:  748:	  return -1;
        -:  749:	}
        -:  750:
    #####:  751:      gainCard(choice2, state, 2, currentPlayer);
        -:  752:
        -:  753:      //discard card from hand
    #####:  754:      discardCard(handPos, currentPlayer, state, 0);
        -:  755:
        -:  756:      //discard trashed card
    #####:  757:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  758:	{
    #####:  759:	  if (state->hand[currentPlayer][i] == j)
        -:  760:	    {
    #####:  761:	      discardCard(i, currentPlayer, state, 0);			
    #####:  762:	      break;
        -:  763:	    }
        -:  764:	}
        -:  765:			
    #####:  766:      return 0;
        -:  767:			
        -:  768:    case remodel:
    #####:  769:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  770:
    #####:  771:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  772:	{
    #####:  773:	  return -1;
        -:  774:	}
        -:  775:
    #####:  776:      gainCard(choice2, state, 0, currentPlayer);
        -:  777:
        -:  778:      //discard card from hand
    #####:  779:      discardCard(handPos, currentPlayer, state, 0);
        -:  780:
        -:  781:      //discard trashed card
    #####:  782:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  783:	{
    #####:  784:	  if (state->hand[currentPlayer][i] == j)
        -:  785:	    {
    #####:  786:	      discardCard(i, currentPlayer, state, 0);			
    #####:  787:	      break;
        -:  788:	    }
        -:  789:	}
        -:  790:
        -:  791:
    #####:  792:      return 0;
        -:  793:		
        -:  794:    case smithy:
    #####:  795:	  return playSmithy(state, handPos);
        -:  796:      /* //+3 Cards
        -:  797:      for (i = 0; i < 3; i++)
        -:  798:	  {
        -:  799:	    drawCard(currentPlayer, state);
        -:  800:	  }
        -:  801:			
        -:  802:      //discard card from hand
        -:  803:      discardCard(handPos, currentPlayer, state, 0);
        -:  804:      return 0; */
        -:  805:		
        -:  806:    case village:
    #####:  807:        return playVillage(state, handPos);
        -:  808:      /*
        -:  809:      //+1 Card
        -:  810:      drawCard(currentPlayer, state);
        -:  811:			
        -:  812:      //+2 Actions
        -:  813:      state->numActions = state->numActions + 2;
        -:  814:			
        -:  815:      //discard played card from hand
        -:  816:      discardCard(handPos, currentPlayer, state, 0);
        -:  817:      return 0;
        -:  818:       */	
        -:  819:    case baron:
    #####:  820:      state->numBuys++;//Increase buys by 1!
    #####:  821:      if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  822:	int p = 0;//Iterator for hand!
    #####:  823:	int card_not_discarded = 1;//Flag for discard set!
    #####:  824:	while(card_not_discarded){
    #####:  825:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
    #####:  826:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  827:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  828:	    state->discardCount[currentPlayer]++;
    #####:  829:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:  830:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  831:	    }
    #####:  832:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  833:	    state->handCount[currentPlayer]--;
    #####:  834:	    card_not_discarded = 0;//Exit the loop
        -:  835:	  }
    #####:  836:	  else if (p > state->handCount[currentPlayer]){
        -:  837:	    if(DEBUG) {
        -:  838:	      printf("No estate cards in your hand, invalid choice\n");
        -:  839:	      printf("Must gain an estate if there are any\n");
        -:  840:	    }
    #####:  841:	    if (supplyCount(estate, state) > 0){
    #####:  842:	      gainCard(estate, state, 0, currentPlayer);
    #####:  843:	      state->supplyCount[estate]--;//Decrement estates
    #####:  844:	      if (supplyCount(estate, state) == 0){
    #####:  845:		isGameOver(state);
        -:  846:	      }
        -:  847:	    }
    #####:  848:	    card_not_discarded = 0;//Exit the loop
        -:  849:	  }
        -:  850:			    
        -:  851:	  else{
    #####:  852:	    p++;//Next card
        -:  853:	  }
        -:  854:	}
        -:  855:      }
        -:  856:			    
        -:  857:      else{
    #####:  858:	if (supplyCount(estate, state) > 0){
    #####:  859:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  860:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  861:	  if (supplyCount(estate, state) == 0){
    #####:  862:	    isGameOver(state);
        -:  863:	  }
        -:  864:	}
        -:  865:      }
        -:  866:	    
        -:  867:      
    #####:  868:      return 0;
        -:  869:		
        -:  870:    case great_hall:
        -:  871:      //+1 Card
    #####:  872:      drawCard(currentPlayer, state);
        -:  873:			
        -:  874:      //+1 Actions
    #####:  875:      state->numActions++;
        -:  876:			
        -:  877:      //discard card from hand
    #####:  878:      discardCard(handPos, currentPlayer, state, 0);
    #####:  879:      return 0;
        -:  880:		
        -:  881:    case minion:
        -:  882:      //+1 action
    #####:  883:      state->numActions++;
        -:  884:			
        -:  885:      //discard card from hand
    #####:  886:      discardCard(handPos, currentPlayer, state, 0);
        -:  887:			
    #####:  888:      if (choice1)		//+2 coins
        -:  889:	{
    #####:  890:	  state->coins = state->coins + 2;
        -:  891:	}
        -:  892:			
    #####:  893:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  894:	{
        -:  895:	  //discard hand
    #####:  896:	  while(numHandCards(state) > 0)
        -:  897:	    {
    #####:  898:	      discardCard(handPos, currentPlayer, state, 0);
        -:  899:	    }
        -:  900:				
        -:  901:	  //draw 4
    #####:  902:	  for (i = 0; i < 4; i++)
        -:  903:	    {
    #####:  904:	      drawCard(currentPlayer, state);
        -:  905:	    }
        -:  906:				
        -:  907:	  //other players discard hand and redraw if hand size > 4
    #####:  908:	  for (i = 0; i < state->numPlayers; i++)
        -:  909:	    {
    #####:  910:	      if (i != currentPlayer)
        -:  911:		{
    #####:  912:		  if ( state->handCount[i] > 4 )
        -:  913:		    {
        -:  914:		      //discard hand
    #####:  915:		      while( state->handCount[i] > 0 )
        -:  916:			{
    #####:  917:			  discardCard(handPos, i, state, 0);
        -:  918:			}
        -:  919:							
        -:  920:		      //draw 4
    #####:  921:		      for (j = 0; j < 4; j++)
        -:  922:			{
    #####:  923:			  drawCard(i, state);
        -:  924:			}
        -:  925:		    }
        -:  926:		}
        -:  927:	    }
        -:  928:				
        -:  929:	}
    #####:  930:      return 0;
        -:  931:		
        -:  932:    case steward:
    #####:  933:	  return playSteward(state, handPos, choice1, choice2, choice3);
        -:  934:
        -:  935:		
        -:  936:    case tribute:
    #####:  937:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####:  938:	if (state->deckCount[nextPlayer] > 0){
    #####:  939:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  940:	  state->deckCount[nextPlayer]--;
        -:  941:	}
    #####:  942:	else if (state->discardCount[nextPlayer] > 0){
    #####:  943:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  944:	  state->discardCount[nextPlayer]--;
        -:  945:	}
        -:  946:	else{
        -:  947:	  //No Card to Reveal
        -:  948:	  if (DEBUG){
        -:  949:	    printf("No cards to reveal\n");
        -:  950:	  }
        -:  951:	}
        -:  952:      }
        -:  953:	    
        -:  954:      else{
    #####:  955:	if (state->deckCount[nextPlayer] == 0){
    #####:  956:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####:  957:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  958:	    state->deckCount[nextPlayer]++;
    #####:  959:	    state->discard[nextPlayer][i] = -1;
    #####:  960:	    state->discardCount[nextPlayer]--;
        -:  961:	  }
        -:  962:			    
    #####:  963:	  shuffle(nextPlayer,state);//Shuffle the deck
        -:  964:	} 
    #####:  965:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  966:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  967:	state->deckCount[nextPlayer]--;
    #####:  968:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  969:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  970:	state->deckCount[nextPlayer]--;
        -:  971:      }    
        -:  972:		       
    #####:  973:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####:  974:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  975:	state->playedCardCount++;
    #####:  976:	tributeRevealedCards[1] = -1;
        -:  977:      } 
        -:  978:
    #####:  979:      for (i = 0; i <= 2; i ++){
    #####:  980:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####:  981:	  state->coins += 2;
        -:  982:	}
        -:  983:		    
    #####:  984:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####:  985:	  drawCard(currentPlayer, state);
    #####:  986:	  drawCard(currentPlayer, state);
        -:  987:	}
        -:  988:	else{//Action Card
    #####:  989:	  state->numActions = state->numActions + 2;
        -:  990:	}
        -:  991:      }
        -:  992:	    
    #####:  993:      return 0;
        -:  994:		
        -:  995:    case ambassador:
    #####:  996:      j = 0;		//used to check if player has enough cards to discard
        -:  997:
    #####:  998:      if (choice2 > 2 || choice2 < 0)
        -:  999:	{
    #####: 1000:	  return -1;				
        -: 1001:	}
        -: 1002:
    #####: 1003:      if (choice1 == handPos)
        -: 1004:	{
    #####: 1005:	  return -1;
        -: 1006:	}
        -: 1007:
    #####: 1008:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1009:	{
    #####: 1010:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1011:	    {
    #####: 1012:	      j++;
        -: 1013:	    }
        -: 1014:	}
    #####: 1015:      if (j < choice2)
        -: 1016:	{
    #####: 1017:	  return -1;				
        -: 1018:	}
        -: 1019:
        -: 1020:      if (DEBUG) 
        -: 1021:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1022:
        -: 1023:      //increase supply count for choosen card by amount being discarded
    #####: 1024:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1025:			
        -: 1026:      //each other player gains a copy of revealed card
    #####: 1027:      for (i = 0; i < state->numPlayers; i++)
        -: 1028:	{
    #####: 1029:	  if (i != currentPlayer)
        -: 1030:	    {
    #####: 1031:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1032:	    }
        -: 1033:	}
        -: 1034:
        -: 1035:      //discard played card from hand
    #####: 1036:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1037:
        -: 1038:      //trash copies of cards returned to supply
    #####: 1039:      for (j = 0; j < choice2; j++)
        -: 1040:	{
    #####: 1041:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1042:	    {
    #####: 1043:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1044:		{
    #####: 1045:		  discardCard(i, currentPlayer, state, 1);
    #####: 1046:		  break;
        -: 1047:		}
        -: 1048:	    }
        -: 1049:	}			
        -: 1050:
    #####: 1051:      return 0;
        -: 1052:		
        -: 1053:    case cutpurse:
        -: 1054:
        -: 1055:/*       updateCoins(currentPlayer, state, 2);
        -: 1056:      for (i = 0; i < state->numPlayers; i++)
        -: 1057:	{
        -: 1058:	  if (i != currentPlayer)
        -: 1059:	    {
        -: 1060:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1061:		{
        -: 1062:		  if (state->hand[i][j] == copper)
        -: 1063:		    {
        -: 1064:		      discardCard(j, i, state, 0);
        -: 1065:		      break;
        -: 1066:		    }
        -: 1067:		  if (j == state->handCount[i])
        -: 1068:		    {
        -: 1069:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1070:			{
        -: 1071:			  if (DEBUG)
        -: 1072:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1073:			}	
        -: 1074:		      break;
        -: 1075:		    }		
        -: 1076:		}
        -: 1077:					
        -: 1078:	    }
        -: 1079:				
        -: 1080:	}				
        -: 1081:
        -: 1082:      //discard played card from hand
        -: 1083:      discardCard(handPos, currentPlayer, state, 0); */			
        -: 1084:
    #####: 1085:      return playCutpurse(state, handPos);
        -: 1086:
        -: 1087:		
        -: 1088:    case embargo: 
        -: 1089:      //+2 Coins
    #####: 1090:      state->coins = state->coins + 2;
        -: 1091:			
        -: 1092:      //see if selected pile is in play
    #####: 1093:      if ( state->supplyCount[choice1] == -1 )
        -: 1094:	{
    #####: 1095:	  return -1;
        -: 1096:	}
        -: 1097:			
        -: 1098:      //add embargo token to selected supply pile
    #####: 1099:      state->embargoTokens[choice1]++;
        -: 1100:			
        -: 1101:      //trash card
    #####: 1102:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1103:      return 0;
        -: 1104:		
        -: 1105:    case outpost:
        -: 1106:      //set outpost flag
    #####: 1107:      state->outpostPlayed++;
        -: 1108:			
        -: 1109:      //discard card
    #####: 1110:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1111:      return 0;
        -: 1112:		
        -: 1113:    case salvager:
        -: 1114:      //+1 buy
    #####: 1115:      state->numBuys++;
        -: 1116:			
    #####: 1117:      if (choice1)
        -: 1118:	{
        -: 1119:	  //gain coins equal to trashed card
    #####: 1120:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1121:	  //trash card
    #####: 1122:	  discardCard(choice1, currentPlayer, state, 1);	
        -: 1123:	}
        -: 1124:			
        -: 1125:      //discard card
    #####: 1126:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1127:      return 0;
        -: 1128:		
        -: 1129:    case sea_hag:
    #####: 1130:      for (i = 0; i < state->numPlayers; i++){
    #####: 1131:	if (i != currentPlayer){
    #####: 1132:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1133:	  state->discardCount[i]++;
    #####: 1134:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1135:	}
        -: 1136:      }
    #####: 1137:      return 0;
        -: 1138:		
        -: 1139:    case treasure_map:
        -: 1140:      //search hand for another treasure_map
    #####: 1141:      index = -1;
    #####: 1142:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1143:	{
    #####: 1144:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1145:	    {
    #####: 1146:	      index = i;
    #####: 1147:	      break;
        -: 1148:	    }
        -: 1149:	}
    #####: 1150:      if (index > -1)
        -: 1151:	{
        -: 1152:	  //trash both treasure cards
    #####: 1153:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1154:	  discardCard(index, currentPlayer, state, 1);
        -: 1155:
        -: 1156:	  //gain 4 Gold cards
    #####: 1157:	  for (i = 0; i < 4; i++)
        -: 1158:	    {
    #####: 1159:	      gainCard(gold, state, 1, currentPlayer);
        -: 1160:	    }
        -: 1161:				
        -: 1162:	  //return success
    #####: 1163:	  return 1;
        -: 1164:	}
        -: 1165:			
        -: 1166:      //no second treasure_map found in hand
    #####: 1167:      return -1;
        -: 1168:    }
        -: 1169:	
    #####: 1170:  return -1;
        -: 1171:}
        -: 1172:
     7936: 1173:int playAdventurer(struct gameState *state){
     7936: 1174:	int drawntreasure = 0;
        -: 1175:	int cardDrawn;
     7936: 1176:	int currentPlayer = whoseTurn(state);
        -: 1177:    int temphand[MAX_HAND];// moved above the if statement
     7936: 1178:    int z = 0;// this is the counter for the temp hand
        -: 1179:
        -: 1180:	
    46624: 1181:	while(drawntreasure<3){
    30752: 1182:		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
     3968: 1183:		  shuffle(currentPlayer, state);
        -: 1184:		}
    30752: 1185:		drawCard(currentPlayer, state);
    30752: 1186:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    30752: 1187:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    23808: 1188:		  drawntreasure++;
        -: 1189:		else{
     6944: 1190:		  temphand[z]=cardDrawn;
     6944: 1191:		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
     6944: 1192:		  z++;
        -: 1193:		}
        -: 1194:	  }
    22816: 1195:	  while(z-1>=0){
     6944: 1196:		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
     6944: 1197:	   z=z-1;
        -: 1198:	  }
        -: 1199:	  
     7936: 1200:	return 0;
        -: 1201:}
        -: 1202:
        -: 1203://Add 4 cards
    #####: 1204:int playCouncil_Room(struct gameState *state, int handPos){
    #####: 1205:	int currentPlayer = whoseTurn(state);
        -: 1206:	int i;
        -: 1207:  
    #####: 1208:    for (i = 0; i < 5; i++)
        -: 1209:	{
    #####: 1210:	  drawCard(currentPlayer, state);
        -: 1211:	}
        -: 1212:			
        -: 1213:    //+1 Buy
    #####: 1214:    state->numBuys++;
        -: 1215:			
        -: 1216:    //Each other player draws a card
    #####: 1217:    for (i = 0; i < state->numPlayers; i++)
        -: 1218:	{
    #####: 1219:	  if ( i != currentPlayer )
        -: 1220:	  {
    #####: 1221:	    drawCard(i, state);
        -: 1222:	  }
        -: 1223:	}
        -: 1224:			
        -: 1225:    //put played card in played card pile
    #####: 1226:    discardCard(handPos, currentPlayer, state, 0);
    #####: 1227:	return 0;
        -: 1228:}
        -: 1229:
   986048: 1230:int playSmithy(struct gameState *state, int handPos){
        -: 1231:    int i;
   986048: 1232:    int currentPlayer = whoseTurn(state);
        -: 1233:
        -: 1234:    //+3 Cards
  3944192: 1235:    for (i = 0; i < 3; i++)
        -: 1236:    {
  2958144: 1237:      drawCard(currentPlayer, state);
        -: 1238:    }
        -: 1239:    	
        -: 1240:    //discard card from hand
   986048: 1241:    discardCard(handPos, currentPlayer, state, 0-1);
   986048: 1242:    return 0;
        -: 1243:}
        -: 1244:
    #####: 1245:int playCutpurse(struct gameState *state, int handPos){
        -: 1246:	int i, j, k;
    #####: 1247:	int currentPlayer = whoseTurn(state);
        -: 1248:
        -: 1249:	
    #####: 1250:    updateCoins(currentPlayer, state, 2);
    #####: 1251:    for (i = 0; i < state->numPlayers; i++)
        -: 1252:	{
    #####: 1253:	  if (i != currentPlayer)
        -: 1254:	  {
    #####: 1255:	    for (j = 0; j <= state->handCount[i]; j++){
    #####: 1256:          if (state->hand[i][j] == copper){
    #####: 1257:	        discardCard(j, i, state, 0);
    #####: 1258:		    return -1;
        -: 1259:	      }
    #####: 1260:	      if (j = state->handCount[i]){
    #####: 1261:            for (k = 0; k < state->handCount[i]; k++){
        -: 1262:		      if (DEBUG)
        -: 1263:                printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1264:            }	
    #####: 1265:		  return -1;
        -: 1266:          }		
        -: 1267:		}
        -: 1268:					
        -: 1269:	  }//end != currentPlayer switch		
        -: 1270:	}
        -: 1271:
        -: 1272:    //discard played card from hand
    #####: 1273:	discardCard(handPos, currentPlayer, state, 0);
        -: 1274:	
    #####: 1275:	return 0;
        -: 1276:}
        -: 1277:
    #####: 1278:int playSteward(struct gameState *state, int handPos, int choice1, int choice2, int choice3){
    #####: 1279:  int currentPlayer = whoseTurn(state);
        -: 1280:
    #####: 1281:  if (choice1 == 1) {
        -: 1282:  //+2 cards
    #####: 1283:    drawCard(currentPlayer, state);
    #####: 1284:    drawCard(currentPlayer, state);
        -: 1285:  }
    #####: 1286:  else if (choice1 == 2) {
        -: 1287:  //+2 coins
    #####: 1288:    state->coins = state->coins + 2;
        -: 1289:  }
        -: 1290:  else {
        -: 1291:  //trash 2 cards in hand
    #####: 1292:    discardCard(choice2, currentPlayer, state, 1);
    #####: 1293:    discardCard(choice3, currentPlayer, state, 1);
        -: 1294:  }
        -: 1295:	
        -: 1296:  //discard card from hand
    #####: 1297:  discardCard(handPos, currentPlayer, state, 0);
    #####: 1298:  return 0;
        -: 1299:}
        -: 1300:
     1984: 1301:int playVillage(struct gameState *state, int handPos){
     1984: 1302:    int currentPlayer = whoseTurn(state);
        -: 1303:
        -: 1304:    //+1 Card
     1984: 1305:     drawCard(currentPlayer, state);
        -: 1306:
        -: 1307:     //+2 Actions
     1984: 1308:     state->numActions = state->numActions + 2;
        -: 1309:
        -: 1310:     //discard played card from hand
     1984: 1311:     discardCard(handPos, currentPlayer, state, 0);
     1984: 1312:     return 0;
        -: 1313:}
        -: 1314:
   988032: 1315:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1316:{
        -: 1317:	
        -: 1318:  //if card is not trashed, added to Played pile 
   988032: 1319:  if (trashFlag < 1)
        -: 1320:    {
        -: 1321:      //add card to played pile
   988032: 1322:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
   988032: 1323:      state->playedCardCount++;
        -: 1324:    }
        -: 1325:	
        -: 1326:  //set played card to -1
   988032: 1327:  state->hand[currentPlayer][handPos] = -1;
        -: 1328:	
        -: 1329:  //remove card from player's hand
   988032: 1330:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1331:    {
        -: 1332:      //reduce number of cards in hand
     1984: 1333:      state->handCount[currentPlayer]--;
        -: 1334:    }
   986048: 1335:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1336:    {
        -: 1337:      //reduce number of cards in hand
    #####: 1338:      state->handCount[currentPlayer]--;
        -: 1339:    }
        -: 1340:  else 	
        -: 1341:    {
        -: 1342:      //replace discarded card with last card in hand
   986048: 1343:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1344:      //set last card to -1
   986048: 1345:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1346:      //reduce number of cards in hand
   986048: 1347:      state->handCount[currentPlayer]--;
        -: 1348:    }
        -: 1349:	
   988032: 1350:  return 0;
        -: 1351:}
        -: 1352:
    #####: 1353:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1354:{
        -: 1355:  //Note: supplyPos is enum of choosen card
        -: 1356:	
        -: 1357:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1358:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1359:    {
    #####: 1360:      return -1;
        -: 1361:    }
        -: 1362:	
        -: 1363:  //added card for [whoseTurn] current player:
        -: 1364:  // toFlag = 0 : add to discard
        -: 1365:  // toFlag = 1 : add to deck
        -: 1366:  // toFlag = 2 : add to hand
        -: 1367:
    #####: 1368:  if (toFlag == 1)
        -: 1369:    {
    #####: 1370:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1371:      state->deckCount[player]++;
        -: 1372:    }
    #####: 1373:  else if (toFlag == 2)
        -: 1374:    {
    #####: 1375:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1376:      state->handCount[player]++;
        -: 1377:    }
        -: 1378:  else
        -: 1379:    {
    #####: 1380:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1381:      state->discardCount[player]++;
        -: 1382:    }
        -: 1383:	
        -: 1384:  //decrease number in supply pile
    #####: 1385:  state->supplyCount[supplyPos]--;
        -: 1386:	 
    #####: 1387:  return 0;
        -: 1388:}
        -: 1389:
      817: 1390:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1391:{
        -: 1392:  int i;
        -: 1393:	
        -: 1394:  //reset coin count
      817: 1395:  state->coins = 0;
        -: 1396:
        -: 1397:  //add coins for each Treasure card in player's hand
     3892: 1398:  for (i = 0; i < state->handCount[player]; i++)
        -: 1399:    {
     3075: 1400:      if (state->hand[player][i] == copper)
        -: 1401:	{
     1060: 1402:	  state->coins += 1;
        -: 1403:	}
     2015: 1404:      else if (state->hand[player][i] == silver)
        -: 1405:	{
     1000: 1406:	  state->coins += 2;
        -: 1407:	}
     1015: 1408:      else if (state->hand[player][i] == gold)
        -: 1409:	{
     1000: 1410:	  state->coins += 3;
        -: 1411:	}	
        -: 1412:    }	
        -: 1413:
        -: 1414:  //add bonus
      817: 1415:  state->coins += bonus;
        -: 1416:
      817: 1417:  return 0;
        -: 1418:}
        -: 1419:
        -: 1420:
        -: 1421://end of dominion.c
        -: 1422:

Testing playCouncil_Room() with seed 1234
Game Initialized! :)
Stored 5 Stored 0 Stored 0 Stored 0 Handocount for p0: 5
Player 1 cards: v: 4 v: 4 v: 4 v: 4 v: 1 
Player 2 cards: 
Player 3 cards: 
Player 4 cards: 
Player 1 cards: v: 4 v: 4 v: 0 v: 4 v: 1 v: 0 v: 0 v: 0 v: 0 
Player 2 cards: v: 1 
Player 3 cards: v: 4 
Player 4 cards: v: 4 
TEST FAILED!
Compared 8 and 9 Compared 1 and 1 Compared 1 and 1 Compared 1 and 1 Stored 5 Stored 0 Stored 0 Stored 0 Handocount for p1: 0
Player 1 cards: v: 4 v: 4 v: 4 v: 4 v: 1 
Player 2 cards: 
Player 3 cards: 
Player 4 cards: 
Player 1 cards: v: 4 v: 4 v: 4 v: 4 v: 1 v: 4 
Player 2 cards: v: 0 v: 0 v: 0 v: 0 
Player 3 cards: v: 4 
Player 4 cards: v: 4 
Compared 6 and 6 TEST FAILED!
Compared 3 and 4 Compared 1 and 1 Compared 1 and 1 Stored 5 Stored 0 Stored 0 Stored 0 Handocount for p2: 0
Player 1 cards: v: 4 v: 4 v: 4 v: 4 v: 1 
Player 2 cards: 
Player 3 cards: 
Player 4 cards: 
Player 1 cards: v: 4 v: 4 v: 4 v: 4 v: 1 v: 4 
Player 2 cards: v: 1 
Player 3 cards: v: 0 v: 0 v: 0 v: 0 
Player 4 cards: v: 4 
Compared 6 and 6 Compared 1 and 1 TEST FAILED!
Compared 3 and 4 Compared 1 and 1 Stored 5 Stored 0 Stored 0 Stored 0 Handocount for p3: 0
Player 1 cards: v: 4 v: 4 v: 4 v: 4 v: 1 
Player 2 cards: 
Player 3 cards: 
Player 4 cards: 
Player 1 cards: v: 4 v: 4 v: 4 v: 4 v: 1 v: 4 
Player 2 cards: v: 1 
Player 3 cards: v: 4 
Player 4 cards: v: 0 v: 0 v: 0 v: 0 
Compared 6 and 6 Compared 1 and 1 Compared 1 and 1 TEST FAILED!
Compared 3 and 4 
__4 TESTS FAILED!__

File 'dominion.c'
Lines executed:36.09% of 568
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:15
        -:    0:Programs:8
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
    20560:    8:int compare(const void* a, const void* b) {
    20560:    9:  if (*(int*)a > *(int*)b)
    #####:   10:    return 1;
    20560:   11:  if (*(int*)a < *(int*)b)
      192:   12:    return -1;
    20368:   13:  return 0;
        -:   14:}
        -:   15:
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
        -:   21:
    #####:   22:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   23:		  int k8, int k9, int k10) {
    #####:   24:  int* k = malloc(10 * sizeof(int));
    #####:   25:  k[0] = k1;
    #####:   26:  k[1] = k2;
    #####:   27:  k[2] = k3;
    #####:   28:  k[3] = k4;
    #####:   29:  k[4] = k5;
    #####:   30:  k[5] = k6;
    #####:   31:  k[6] = k7;
    #####:   32:  k[7] = k8;
    #####:   33:  k[8] = k9;
    #####:   34:  k[9] = k10;
    #####:   35:  return k;
        -:   36:}
        -:   37:
       15:   38:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   39:		   struct gameState *state) {
        -:   40:
        -:   41:  int i;
        -:   42:  int j;
        -:   43:  int it;			
        -:   44:  //set up random number generator
       15:   45:  SelectStream(1);
       15:   46:  PutSeed((long)randomSeed);
        -:   47:  
        -:   48:  //check number of players
       15:   49:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   50:    {
    #####:   51:      return -1;
        -:   52:    }
        -:   53:
        -:   54:  //set number of players
       15:   55:  state->numPlayers = numPlayers;
        -:   56:
        -:   57:  //check selected kingdom cards are different
      165:   58:  for (i = 0; i < 10; i++)
        -:   59:    {
     1650:   60:      for (j = 0; j < 10; j++)
        -:   61:        {
     1500:   62:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   63:	    {
    #####:   64:	      return -1;
        -:   65:	    }
        -:   66:        }
        -:   67:    }
        -:   68:
        -:   69:
        -:   70:  //initialize supply
        -:   71:  ///////////////////////////////
        -:   72:
        -:   73:  //set number of Curse cards
       15:   74:  if (numPlayers == 2)
        -:   75:    {
        6:   76:      state->supplyCount[curse] = 10;
        -:   77:    }
        9:   78:  else if (numPlayers == 3)
        -:   79:    {
    #####:   80:      state->supplyCount[curse] = 20;
        -:   81:    }
        -:   82:  else
        -:   83:    {
        9:   84:      state->supplyCount[curse] = 30;
        -:   85:    }
        -:   86:
        -:   87:  //set number of Victory cards
       15:   88:  if (numPlayers == 2)
        -:   89:    {
        6:   90:      state->supplyCount[estate] = 8;
        6:   91:      state->supplyCount[duchy] = 8;
        6:   92:      state->supplyCount[province] = 8;
        -:   93:    }
        -:   94:  else
        -:   95:    {
        9:   96:      state->supplyCount[estate] = 12;
        9:   97:      state->supplyCount[duchy] = 12;
        9:   98:      state->supplyCount[province] = 12;
        -:   99:    }
        -:  100:
        -:  101:  //set number of Treasure cards
       15:  102:  state->supplyCount[copper] = 60 - (7 * numPlayers);
       15:  103:  state->supplyCount[silver] = 40;
       15:  104:  state->supplyCount[gold] = 30;
        -:  105:
        -:  106:  //set number of Kingdom cards
      315:  107:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  108:    {
     2475:  109:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  110:	{
     2325:  111:	  if (kingdomCards[j] == i)
        -:  112:	    {
        -:  113:	      //check if card is a 'Victory' Kingdom card
      150:  114:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  115:		{
       30:  116:		  if (numPlayers == 2){ 
        6:  117:		    state->supplyCount[i] = 8; 
        -:  118:		  }
        9:  119:		  else{ state->supplyCount[i] = 12; }
        -:  120:		}
        -:  121:	      else
        -:  122:		{
      135:  123:		  state->supplyCount[i] = 10;
        -:  124:		}
      150:  125:	      break;
        -:  126:	    }
        -:  127:	  else    //card is not in the set choosen for the game
        -:  128:	    {
     2175:  129:	      state->supplyCount[i] = -1;
        -:  130:	    }
        -:  131:	}
        -:  132:
        -:  133:    }
        -:  134:
        -:  135:  ////////////////////////
        -:  136:  //supply intilization complete
        -:  137:
        -:  138:  //set player decks
       63:  139:  for (i = 0; i < numPlayers; i++)
        -:  140:    {
       48:  141:      state->deckCount[i] = 0;
      192:  142:      for (j = 0; j < 3; j++)
        -:  143:	{
      144:  144:	  state->deck[i][j] = estate;
      144:  145:	  state->deckCount[i]++;
        -:  146:	}
      384:  147:      for (j = 3; j < 10; j++)
        -:  148:	{
      336:  149:	  state->deck[i][j] = copper;
      336:  150:	  state->deckCount[i]++;		
        -:  151:	}
        -:  152:    }
        -:  153:
        -:  154:  //shuffle player decks
       63:  155:  for (i = 0; i < numPlayers; i++)
        -:  156:    {
       48:  157:      if ( shuffle(i, state) < 0 )
        -:  158:	{
    #####:  159:	  return -1;
        -:  160:	}
        -:  161:    }
        -:  162:
        -:  163:  //draw player hands
       63:  164:  for (i = 0; i < numPlayers; i++)
        -:  165:    {  
        -:  166:      //initialize hand size to zero
       48:  167:      state->handCount[i] = 0;
       48:  168:      state->discardCount[i] = 0;
        -:  169:      //draw 5 cards
        -:  170:      // for (j = 0; j < 5; j++)
        -:  171:      //	{
        -:  172:      //	  drawCard(i, state);
        -:  173:      //	}
        -:  174:    }
        -:  175:  
        -:  176:  //set embargo tokens to 0 for all supply piles
      420:  177:  for (i = 0; i <= treasure_map; i++)
        -:  178:    {
      405:  179:      state->embargoTokens[i] = 0;
        -:  180:    }
        -:  181:
        -:  182:  //initialize first player's turn
       15:  183:  state->outpostPlayed = 0;
       15:  184:  state->phase = 0;
       15:  185:  state->numActions = 1;
       15:  186:  state->numBuys = 1;
       15:  187:  state->playedCardCount = 0;
       15:  188:  state->whoseTurn = 0;
       15:  189:  state->handCount[state->whoseTurn] = 0;
        -:  190:  //int it; move to top
        -:  191:
        -:  192:  //Moved draw cards to here, only drawing at the start of a turn
       90:  193:  for (it = 0; it < 5; it++){
       75:  194:    drawCard(state->whoseTurn, state);
        -:  195:  }
        -:  196:
       15:  197:  updateCoins(state->whoseTurn, state, 0);
        -:  198:
       15:  199:  return 0;
        -:  200:}
        -:  201:
     7984:  202:int shuffle(int player, struct gameState *state) {
        -:  203: 
        -:  204:
        -:  205:  int newDeck[MAX_DECK];
     7984:  206:  int newDeckPos = 0;
        -:  207:  int card;
        -:  208:  int i;
        -:  209:
     7984:  210:  if (state->deckCount[player] < 1)
     3968:  211:    return -1;
     4016:  212:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  213:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  214:
    28352:  215:  while (state->deckCount[player] > 0) {
    20320:  216:    card = floor(Random() * state->deckCount[player]);
    20320:  217:    newDeck[newDeckPos] = state->deck[player][card];
    20320:  218:    newDeckPos++;
    41329:  219:    for (i = card; i < state->deckCount[player]-1; i++) {
    21009:  220:      state->deck[player][i] = state->deck[player][i+1];
        -:  221:    }
    20320:  222:    state->deckCount[player]--;
        -:  223:  }
    24336:  224:  for (i = 0; i < newDeckPos; i++) {
    20320:  225:    state->deck[player][i] = newDeck[i];
    20320:  226:    state->deckCount[player]++;
        -:  227:  }
        -:  228:
     4016:  229:  return 0;
        -:  230:}
        -:  231:
    #####:  232:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  233:{	
        -:  234:  int card;
    #####:  235:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  236:
        -:  237:  //check if it is the right phase
    #####:  238:  if (state->phase != 0)
        -:  239:    {
    #####:  240:      return -1;
        -:  241:    }
        -:  242:	
        -:  243:  //check if player has enough actions
    #####:  244:  if ( state->numActions < 1 )
        -:  245:    {
    #####:  246:      return -1;
        -:  247:    }
        -:  248:	
        -:  249:  //get card played
    #####:  250:  card = handCard(handPos, state);
        -:  251:	
        -:  252:  //check if selected card is an action
    #####:  253:  if ( card < adventurer || card > treasure_map )
        -:  254:    {
    #####:  255:      return -1;
        -:  256:    }
        -:  257:	
        -:  258:  //play card
    #####:  259:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  260:    {
    #####:  261:      return -1;
        -:  262:    }
        -:  263:	
        -:  264:  //reduce number of actions
    #####:  265:  state->numActions--;
        -:  266:
        -:  267:  //update coins (Treasure cards may be added with card draws)
    #####:  268:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  269:	
    #####:  270:  return 0;
        -:  271:}
        -:  272:
    #####:  273:int buyCard(int supplyPos, struct gameState *state) {
        -:  274:  int who;
        -:  275:  if (DEBUG){
        -:  276:    printf("Entering buyCard...\n");
        -:  277:  }
        -:  278:
        -:  279:  // I don't know what to do about the phase thing.
        -:  280:
    #####:  281:  who = state->whoseTurn;
        -:  282:
    #####:  283:  if (state->numBuys < 1){
        -:  284:    if (DEBUG)
        -:  285:      printf("You do not have any buys left\n");
    #####:  286:    return -1;
    #####:  287:  } else if (supplyCount(supplyPos, state) <1){
        -:  288:    if (DEBUG)
        -:  289:      printf("There are not any of that type of card left\n");
    #####:  290:    return -1;
    #####:  291:  } else if (state->coins < getCost(supplyPos)){
        -:  292:    if (DEBUG) 
        -:  293:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  294:    return -1;
        -:  295:  } else {
    #####:  296:    state->phase=1;
        -:  297:    //state->supplyCount[supplyPos]--;
    #####:  298:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  299:  
    #####:  300:    state->coins = (state->coins) - (getCost(supplyPos));
    #####:  301:    state->numBuys--;
        -:  302:    if (DEBUG)
        -:  303:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  304:  }
        -:  305:
        -:  306:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  307:  //state->discardCount[who]++;
        -:  308:    
    #####:  309:  return 0;
        -:  310:}
        -:  311:
    #####:  312:int numHandCards(struct gameState *state) {
    #####:  313:  return state->handCount[ whoseTurn(state) ];
        -:  314:}
        -:  315:
    #####:  316:int handCard(int handPos, struct gameState *state) {
    #####:  317:  int currentPlayer = whoseTurn(state);
    #####:  318:  return state->hand[currentPlayer][handPos];
        -:  319:}
        -:  320:
    #####:  321:int supplyCount(int card, struct gameState *state) {
    #####:  322:  return state->supplyCount[card];
        -:  323:}
        -:  324:
    #####:  325:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  326:  int i;
    #####:  327:  int count = 0;
        -:  328:
    #####:  329:  for (i = 0; i < state->deckCount[player]; i++)
        -:  330:    {
    #####:  331:      if (state->deck[player][i] == card) count++;
        -:  332:    }
        -:  333:
    #####:  334:  for (i = 0; i < state->handCount[player]; i++)
        -:  335:    {
    #####:  336:      if (state->hand[player][i] == card) count++;
        -:  337:    }
        -:  338:
    #####:  339:  for (i = 0; i < state->discardCount[player]; i++)
        -:  340:    {
    #####:  341:      if (state->discard[player][i] == card) count++;
        -:  342:    }
        -:  343:
    #####:  344:  return count;
        -:  345:}
        -:  346:
   997968:  347:int whoseTurn(struct gameState *state) {
   997968:  348:  return state->whoseTurn;
        -:  349:}
        -:  350:
    #####:  351:int endTurn(struct gameState *state) {
        -:  352:  int k;
        -:  353:  int i;
    #####:  354:  int currentPlayer = whoseTurn(state);
        -:  355:  
        -:  356:  //Discard hand
    #####:  357:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  358:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  359:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  360:  }
    #####:  361:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  362:    
        -:  363:  //Code for determining the player
    #####:  364:  if (currentPlayer < (state->numPlayers - 1)){ 
    #####:  365:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  366:  }
        -:  367:  else{
    #####:  368:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  369:  }
        -:  370:
    #####:  371:  state->outpostPlayed = 0;
    #####:  372:  state->phase = 0;
    #####:  373:  state->numActions = 1;
    #####:  374:  state->coins = 0;
    #####:  375:  state->numBuys = 1;
    #####:  376:  state->playedCardCount = 0;
    #####:  377:  state->handCount[state->whoseTurn] = 0;
        -:  378:
        -:  379:  //int k; move to top
        -:  380:  //Next player draws hand
    #####:  381:  for (k = 0; k < 5; k++){
    #####:  382:    drawCard(state->whoseTurn, state);//Draw a card
        -:  383:  }
        -:  384:
        -:  385:  //Update money
    #####:  386:  updateCoins(state->whoseTurn, state , 0);
        -:  387:
    #####:  388:  return 0;
        -:  389:}
        -:  390:
      156:  391:int isGameOver(struct gameState *state) {
        -:  392:  int i;
        -:  393:  int j;
        -:  394:	
        -:  395:  //if stack of Province cards is empty, the game ends
      156:  396:  if (state->supplyCount[province] == 0)
        -:  397:    {
        6:  398:      return 1;
        -:  399:    }
        -:  400:
        -:  401:  //if three supply pile are at 0, the game ends
      150:  402:    j = 0;
     3900:  403:    for (i = 0; i < 25; i++)
        -:  404:    {
     3750:  405:      if (state->supplyCount[i] == 0)
        -:  406:        {
      258:  407:          j++;
        -:  408:        }
        -:  409:    }
      150:  410:    if ( j >= 3)
        -:  411:    {
       40:  412:      return 1;
        -:  413:    }
        -:  414:
      110:  415:  return 0;
        -:  416:}
        -:  417:
    #####:  418:int scoreFor (int player, struct gameState *state) {
        -:  419:
        -:  420:  int i;
    #####:  421:  int score = 0;
        -:  422:  //score from hand
    #####:  423:  for (i = 0; i < state->handCount[player]; i++)
        -:  424:    {
    #####:  425:      if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  426:      if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  427:      if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  428:      if (state->hand[player][i] == province) { score = score + 6; };
    #####:  429:      if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  430:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  431:    }
        -:  432:
        -:  433:  //score from discard
    #####:  434:  for (i = 0; i < state->discardCount[player]; i++)
        -:  435:    {
    #####:  436:      if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  437:      if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  438:      if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  439:      if (state->discard[player][i] == province) { score = score + 6; };
    #####:  440:      if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  441:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  442:    }
        -:  443:
        -:  444:  //score from deck
    #####:  445:  for (i = 0; i < state->discardCount[player]; i++)
        -:  446:    {
    #####:  447:      if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  448:      if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  449:      if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  450:      if (state->deck[player][i] == province) { score = score + 6; };
    #####:  451:      if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  452:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  453:    }
        -:  454:
    #####:  455:  return score;
        -:  456:}
        -:  457:
    #####:  458:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  459:  int i;	
        -:  460:  int j;
        -:  461:  int highScore;
        -:  462:  int currentPlayer;
        -:  463:
        -:  464:  //get score for each player
    #####:  465:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  466:    {
        -:  467:      //set unused player scores to -9999
    #####:  468:      if (i >= state->numPlayers)
        -:  469:	{
    #####:  470:	  players[i] = -9999;
        -:  471:	}
        -:  472:      else
        -:  473:	{
    #####:  474:	  players[i] = scoreFor (i, state);
        -:  475:	}
        -:  476:    }
        -:  477:
        -:  478:  //find highest score
    #####:  479:  j = 0;
    #####:  480:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  481:    {
    #####:  482:      if (players[i] > players[j])
        -:  483:	{
    #####:  484:	  j = i;
        -:  485:	}
        -:  486:    }
    #####:  487:  highScore = players[j];
        -:  488:
        -:  489:  //add 1 to players who had less turns
    #####:  490:  currentPlayer = whoseTurn(state);
    #####:  491:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  492:    {
    #####:  493:      if ( players[i] == highScore && i > currentPlayer )
        -:  494:	{
    #####:  495:	  players[i]++;
        -:  496:	}
        -:  497:    }
        -:  498:
        -:  499:  //find new highest score
    #####:  500:  j = 0;
    #####:  501:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  502:    {
    #####:  503:      if ( players[i] > players[j] )
        -:  504:	{
    #####:  505:	  j = i;
        -:  506:	}
        -:  507:    }
    #####:  508:  highScore = players[j];
        -:  509:
        -:  510:  //set winners in array to 1 and rest to 0
    #####:  511:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  512:    {
    #####:  513:      if ( players[i] == highScore )
        -:  514:	{
    #####:  515:	  players[i] = 1;
        -:  516:	}
        -:  517:      else
        -:  518:	{
    #####:  519:	  players[i] = 0;
        -:  520:	}
        -:  521:    }
        -:  522:
    #####:  523:  return 0;
        -:  524:}
        -:  525:
  2992971:  526:int drawCard(int player, struct gameState *state)
        -:  527:{	int count;
        -:  528:  int deckCounter;
  2992971:  529:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  530:    
        -:  531:    //Step 1 Shuffle the discard pile back into a deck
        -:  532:    int i;
        -:  533:    //Move discard to deck
    23808:  534:    for (i = 0; i < state->discardCount[player];i++){
    19840:  535:      state->deck[player][i] = state->discard[player][i];
    19840:  536:      state->discard[player][i] = -1;
        -:  537:    }
        -:  538:
     3968:  539:    state->deckCount[player] = state->discardCount[player];
     3968:  540:    state->discardCount[player] = 0;//Reset discard
        -:  541:
        -:  542:    //Shufffle the deck
     3968:  543:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  544:   
        -:  545:    if (DEBUG){//Debug statements
        -:  546:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  547:    }
        -:  548:    
     3968:  549:    state->discardCount[player] = 0;
        -:  550:
        -:  551:    //Step 2 Draw Card
     3968:  552:    count = state->handCount[player];//Get current player's hand count
        -:  553:    
        -:  554:    if (DEBUG){//Debug statements
        -:  555:      printf("Current hand count: %d\n", count);
        -:  556:    }
        -:  557:    
     3968:  558:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  559:
     3968:  560:    if (deckCounter == 0)
    #####:  561:      return -1;
        -:  562:
     3968:  563:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
     3968:  564:    state->deckCount[player]--;
     3968:  565:    state->handCount[player]++;//Increment hand count
        -:  566:  }
        -:  567:
        -:  568:  else{
  2989003:  569:    int count = state->handCount[player];//Get current hand count for player
        -:  570:    int deckCounter;
        -:  571:    if (DEBUG){//Debug statements
        -:  572:      printf("Current hand count: %d\n", count);
        -:  573:    }
        -:  574:
  2989003:  575:    deckCounter = state->deckCount[player];//Create holder for the deck count
  2989003:  576:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
  2989003:  577:    state->deckCount[player]--;
  2989003:  578:    state->handCount[player]++;//Increment hand count
        -:  579:  }
        -:  580:
  2992971:  581:  return 0;
        -:  582:}
        -:  583:
       56:  584:int getCost(int cardNumber)
        -:  585:{
       56:  586:  switch( cardNumber ) 
        -:  587:    {
        -:  588:    case curse:
        2:  589:      return 0;
        -:  590:    case estate:
        2:  591:      return 2;
        -:  592:    case duchy:
        2:  593:      return 5;
        -:  594:    case province:
        2:  595:      return 8;
        -:  596:    case copper:
        2:  597:      return 0;
        -:  598:    case silver:
        2:  599:      return 3;
        -:  600:    case gold:
        2:  601:      return 6;
        -:  602:    case adventurer:
        2:  603:      return 6;
        -:  604:    case council_room:
        2:  605:      return 5;
        -:  606:    case feast:
        2:  607:      return 4;
        -:  608:    case gardens:
        2:  609:      return 4;
        -:  610:    case mine:
        2:  611:      return 5;
        -:  612:    case remodel:
        2:  613:      return 4;
        -:  614:    case smithy:
        2:  615:      return 4;
        -:  616:    case village:
        2:  617:      return 3;
        -:  618:    case baron:
        2:  619:      return 4;
        -:  620:    case great_hall:
        2:  621:      return 3;
        -:  622:    case minion:
        2:  623:      return 5;
        -:  624:    case steward:
        2:  625:      return 3;
        -:  626:    case tribute:
        2:  627:      return 5;
        -:  628:    case ambassador:
        2:  629:      return 3;
        -:  630:    case cutpurse:
        2:  631:      return 4;
        -:  632:    case embargo: 
        2:  633:      return 2;
        -:  634:    case outpost:
        2:  635:      return 5;
        -:  636:    case salvager:
        2:  637:      return 4;
        -:  638:    case sea_hag:
        2:  639:      return 4;
        -:  640:    case treasure_map:
        2:  641:      return 4;
        -:  642:    }
        -:  643:	
        2:  644:  return -1;
        -:  645:}
        -:  646:
        -:  647:
    #####:  648:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  649:{
        -:  650:  int i;
        -:  651:  int j;
        -:  652://  int k;
        -:  653:  int x;
        -:  654:  int index;
    #####:  655:  int currentPlayer = whoseTurn(state);
    #####:  656:  int nextPlayer = currentPlayer + 1;
        -:  657:
    #####:  658:  int tributeRevealedCards[2] = {-1, -1};
        -:  659:  int temphand[MAX_HAND];// moved above the if statement
    #####:  660:  int drawntreasure=0;
        -:  661:  int cardDrawn;
    #####:  662:  int z = 0;// this is the counter for the temp hand
    #####:  663:  if (nextPlayer > (state->numPlayers - 1)){
    #####:  664:    nextPlayer = 0;
        -:  665:  }
        -:  666:  
        -:  667:	
        -:  668:  //uses switch to select card and perform actions
    #####:  669:  switch( card ) 
        -:  670:    {
        -:  671:    case adventurer:
    #####:  672:	 return playAdventurer(state);
        -:  673:			
        -:  674:    case council_room:
    #####:  675:	  return playCouncil_Room(state, handPos);
        -:  676:			
        -:  677:    case feast:
        -:  678:      //gain card with cost up to 5
        -:  679:      //Backup hand
    #####:  680:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  681:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  682:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  683:      }
        -:  684:      //Backup hand
        -:  685:
        -:  686:      //Update Coins for Buy
    #####:  687:      updateCoins(currentPlayer, state, 5);
    #####:  688:      x = 1;//Condition to loop on
    #####:  689:      while( x == 1) {//Buy one card
    #####:  690:	if (supplyCount(choice1, state) <= 0){
        -:  691:	  if (DEBUG)
        -:  692:	    printf("None of that card left, sorry!\n");
        -:  693:
        -:  694:	  if (DEBUG){
        -:  695:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  696:	  }
        -:  697:	}
    #####:  698:	else if (state->coins < getCost(choice1)){
    #####:  699:	  printf("That card is too expensive!\n");
        -:  700:
        -:  701:	  if (DEBUG){
        -:  702:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  703:	  }
        -:  704:	}
        -:  705:	else{
        -:  706:
        -:  707:	  if (DEBUG){
        -:  708:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  709:	  }
        -:  710:
    #####:  711:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  712:	  x = 0;//No more buying cards
        -:  713:
        -:  714:	  if (DEBUG){
        -:  715:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  716:	  }
        -:  717:
        -:  718:	}
        -:  719:      }     
        -:  720:
        -:  721:      //Reset Hand
    #####:  722:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  723:	state->hand[currentPlayer][i] = temphand[i];
    #####:  724:	temphand[i] = -1;
        -:  725:      }
        -:  726:      //Reset Hand
        -:  727:      			
    #####:  728:      return 0;
        -:  729:			
        -:  730:    case gardens:
    #####:  731:      return -1;
        -:  732:			
        -:  733:    case mine:
    #####:  734:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  735:
    #####:  736:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  737:	{
    #####:  738:	  return -1;
        -:  739:	}
        -:  740:		
    #####:  741:      if (choice2 > treasure_map || choice2 < curse)
        -:  742:	{
    #####:  743:	  return -1;
        -:  744:	}
        -:  745:
    #####:  746:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
        -:  747:	{
    #####:  748:	  return -1;
        -:  749:	}
        -:  750:
    #####:  751:      gainCard(choice2, state, 2, currentPlayer);
        -:  752:
        -:  753:      //discard card from hand
    #####:  754:      discardCard(handPos, currentPlayer, state, 0);
        -:  755:
        -:  756:      //discard trashed card
    #####:  757:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  758:	{
    #####:  759:	  if (state->hand[currentPlayer][i] == j)
        -:  760:	    {
    #####:  761:	      discardCard(i, currentPlayer, state, 0);			
    #####:  762:	      break;
        -:  763:	    }
        -:  764:	}
        -:  765:			
    #####:  766:      return 0;
        -:  767:			
        -:  768:    case remodel:
    #####:  769:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  770:
    #####:  771:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  772:	{
    #####:  773:	  return -1;
        -:  774:	}
        -:  775:
    #####:  776:      gainCard(choice2, state, 0, currentPlayer);
        -:  777:
        -:  778:      //discard card from hand
    #####:  779:      discardCard(handPos, currentPlayer, state, 0);
        -:  780:
        -:  781:      //discard trashed card
    #####:  782:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  783:	{
    #####:  784:	  if (state->hand[currentPlayer][i] == j)
        -:  785:	    {
    #####:  786:	      discardCard(i, currentPlayer, state, 0);			
    #####:  787:	      break;
        -:  788:	    }
        -:  789:	}
        -:  790:
        -:  791:
    #####:  792:      return 0;
        -:  793:		
        -:  794:    case smithy:
    #####:  795:	  return playSmithy(state, handPos);
        -:  796:      /* //+3 Cards
        -:  797:      for (i = 0; i < 3; i++)
        -:  798:	  {
        -:  799:	    drawCard(currentPlayer, state);
        -:  800:	  }
        -:  801:			
        -:  802:      //discard card from hand
        -:  803:      discardCard(handPos, currentPlayer, state, 0);
        -:  804:      return 0; */
        -:  805:		
        -:  806:    case village:
    #####:  807:        return playVillage(state, handPos);
        -:  808:      /*
        -:  809:      //+1 Card
        -:  810:      drawCard(currentPlayer, state);
        -:  811:			
        -:  812:      //+2 Actions
        -:  813:      state->numActions = state->numActions + 2;
        -:  814:			
        -:  815:      //discard played card from hand
        -:  816:      discardCard(handPos, currentPlayer, state, 0);
        -:  817:      return 0;
        -:  818:       */	
        -:  819:    case baron:
    #####:  820:      state->numBuys++;//Increase buys by 1!
    #####:  821:      if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  822:	int p = 0;//Iterator for hand!
    #####:  823:	int card_not_discarded = 1;//Flag for discard set!
    #####:  824:	while(card_not_discarded){
    #####:  825:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
    #####:  826:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  827:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  828:	    state->discardCount[currentPlayer]++;
    #####:  829:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:  830:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  831:	    }
    #####:  832:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  833:	    state->handCount[currentPlayer]--;
    #####:  834:	    card_not_discarded = 0;//Exit the loop
        -:  835:	  }
    #####:  836:	  else if (p > state->handCount[currentPlayer]){
        -:  837:	    if(DEBUG) {
        -:  838:	      printf("No estate cards in your hand, invalid choice\n");
        -:  839:	      printf("Must gain an estate if there are any\n");
        -:  840:	    }
    #####:  841:	    if (supplyCount(estate, state) > 0){
    #####:  842:	      gainCard(estate, state, 0, currentPlayer);
    #####:  843:	      state->supplyCount[estate]--;//Decrement estates
    #####:  844:	      if (supplyCount(estate, state) == 0){
    #####:  845:		isGameOver(state);
        -:  846:	      }
        -:  847:	    }
    #####:  848:	    card_not_discarded = 0;//Exit the loop
        -:  849:	  }
        -:  850:			    
        -:  851:	  else{
    #####:  852:	    p++;//Next card
        -:  853:	  }
        -:  854:	}
        -:  855:      }
        -:  856:			    
        -:  857:      else{
    #####:  858:	if (supplyCount(estate, state) > 0){
    #####:  859:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  860:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  861:	  if (supplyCount(estate, state) == 0){
    #####:  862:	    isGameOver(state);
        -:  863:	  }
        -:  864:	}
        -:  865:      }
        -:  866:	    
        -:  867:      
    #####:  868:      return 0;
        -:  869:		
        -:  870:    case great_hall:
        -:  871:      //+1 Card
    #####:  872:      drawCard(currentPlayer, state);
        -:  873:			
        -:  874:      //+1 Actions
    #####:  875:      state->numActions++;
        -:  876:			
        -:  877:      //discard card from hand
    #####:  878:      discardCard(handPos, currentPlayer, state, 0);
    #####:  879:      return 0;
        -:  880:		
        -:  881:    case minion:
        -:  882:      //+1 action
    #####:  883:      state->numActions++;
        -:  884:			
        -:  885:      //discard card from hand
    #####:  886:      discardCard(handPos, currentPlayer, state, 0);
        -:  887:			
    #####:  888:      if (choice1)		//+2 coins
        -:  889:	{
    #####:  890:	  state->coins = state->coins + 2;
        -:  891:	}
        -:  892:			
    #####:  893:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  894:	{
        -:  895:	  //discard hand
    #####:  896:	  while(numHandCards(state) > 0)
        -:  897:	    {
    #####:  898:	      discardCard(handPos, currentPlayer, state, 0);
        -:  899:	    }
        -:  900:				
        -:  901:	  //draw 4
    #####:  902:	  for (i = 0; i < 4; i++)
        -:  903:	    {
    #####:  904:	      drawCard(currentPlayer, state);
        -:  905:	    }
        -:  906:				
        -:  907:	  //other players discard hand and redraw if hand size > 4
    #####:  908:	  for (i = 0; i < state->numPlayers; i++)
        -:  909:	    {
    #####:  910:	      if (i != currentPlayer)
        -:  911:		{
    #####:  912:		  if ( state->handCount[i] > 4 )
        -:  913:		    {
        -:  914:		      //discard hand
    #####:  915:		      while( state->handCount[i] > 0 )
        -:  916:			{
    #####:  917:			  discardCard(handPos, i, state, 0);
        -:  918:			}
        -:  919:							
        -:  920:		      //draw 4
    #####:  921:		      for (j = 0; j < 4; j++)
        -:  922:			{
    #####:  923:			  drawCard(i, state);
        -:  924:			}
        -:  925:		    }
        -:  926:		}
        -:  927:	    }
        -:  928:				
        -:  929:	}
    #####:  930:      return 0;
        -:  931:		
        -:  932:    case steward:
    #####:  933:	  return playSteward(state, handPos, choice1, choice2, choice3);
        -:  934:
        -:  935:		
        -:  936:    case tribute:
    #####:  937:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####:  938:	if (state->deckCount[nextPlayer] > 0){
    #####:  939:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  940:	  state->deckCount[nextPlayer]--;
        -:  941:	}
    #####:  942:	else if (state->discardCount[nextPlayer] > 0){
    #####:  943:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  944:	  state->discardCount[nextPlayer]--;
        -:  945:	}
        -:  946:	else{
        -:  947:	  //No Card to Reveal
        -:  948:	  if (DEBUG){
        -:  949:	    printf("No cards to reveal\n");
        -:  950:	  }
        -:  951:	}
        -:  952:      }
        -:  953:	    
        -:  954:      else{
    #####:  955:	if (state->deckCount[nextPlayer] == 0){
    #####:  956:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####:  957:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  958:	    state->deckCount[nextPlayer]++;
    #####:  959:	    state->discard[nextPlayer][i] = -1;
    #####:  960:	    state->discardCount[nextPlayer]--;
        -:  961:	  }
        -:  962:			    
    #####:  963:	  shuffle(nextPlayer,state);//Shuffle the deck
        -:  964:	} 
    #####:  965:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  966:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  967:	state->deckCount[nextPlayer]--;
    #####:  968:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  969:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  970:	state->deckCount[nextPlayer]--;
        -:  971:      }    
        -:  972:		       
    #####:  973:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####:  974:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  975:	state->playedCardCount++;
    #####:  976:	tributeRevealedCards[1] = -1;
        -:  977:      } 
        -:  978:
    #####:  979:      for (i = 0; i <= 2; i ++){
    #####:  980:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####:  981:	  state->coins += 2;
        -:  982:	}
        -:  983:		    
    #####:  984:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####:  985:	  drawCard(currentPlayer, state);
    #####:  986:	  drawCard(currentPlayer, state);
        -:  987:	}
        -:  988:	else{//Action Card
    #####:  989:	  state->numActions = state->numActions + 2;
        -:  990:	}
        -:  991:      }
        -:  992:	    
    #####:  993:      return 0;
        -:  994:		
        -:  995:    case ambassador:
    #####:  996:      j = 0;		//used to check if player has enough cards to discard
        -:  997:
    #####:  998:      if (choice2 > 2 || choice2 < 0)
        -:  999:	{
    #####: 1000:	  return -1;				
        -: 1001:	}
        -: 1002:
    #####: 1003:      if (choice1 == handPos)
        -: 1004:	{
    #####: 1005:	  return -1;
        -: 1006:	}
        -: 1007:
    #####: 1008:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1009:	{
    #####: 1010:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1011:	    {
    #####: 1012:	      j++;
        -: 1013:	    }
        -: 1014:	}
    #####: 1015:      if (j < choice2)
        -: 1016:	{
    #####: 1017:	  return -1;				
        -: 1018:	}
        -: 1019:
        -: 1020:      if (DEBUG) 
        -: 1021:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1022:
        -: 1023:      //increase supply count for choosen card by amount being discarded
    #####: 1024:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1025:			
        -: 1026:      //each other player gains a copy of revealed card
    #####: 1027:      for (i = 0; i < state->numPlayers; i++)
        -: 1028:	{
    #####: 1029:	  if (i != currentPlayer)
        -: 1030:	    {
    #####: 1031:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1032:	    }
        -: 1033:	}
        -: 1034:
        -: 1035:      //discard played card from hand
    #####: 1036:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1037:
        -: 1038:      //trash copies of cards returned to supply
    #####: 1039:      for (j = 0; j < choice2; j++)
        -: 1040:	{
    #####: 1041:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1042:	    {
    #####: 1043:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1044:		{
    #####: 1045:		  discardCard(i, currentPlayer, state, 1);
    #####: 1046:		  break;
        -: 1047:		}
        -: 1048:	    }
        -: 1049:	}			
        -: 1050:
    #####: 1051:      return 0;
        -: 1052:		
        -: 1053:    case cutpurse:
        -: 1054:
        -: 1055:/*       updateCoins(currentPlayer, state, 2);
        -: 1056:      for (i = 0; i < state->numPlayers; i++)
        -: 1057:	{
        -: 1058:	  if (i != currentPlayer)
        -: 1059:	    {
        -: 1060:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1061:		{
        -: 1062:		  if (state->hand[i][j] == copper)
        -: 1063:		    {
        -: 1064:		      discardCard(j, i, state, 0);
        -: 1065:		      break;
        -: 1066:		    }
        -: 1067:		  if (j == state->handCount[i])
        -: 1068:		    {
        -: 1069:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1070:			{
        -: 1071:			  if (DEBUG)
        -: 1072:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1073:			}	
        -: 1074:		      break;
        -: 1075:		    }		
        -: 1076:		}
        -: 1077:					
        -: 1078:	    }
        -: 1079:				
        -: 1080:	}				
        -: 1081:
        -: 1082:      //discard played card from hand
        -: 1083:      discardCard(handPos, currentPlayer, state, 0); */			
        -: 1084:
    #####: 1085:      return playCutpurse(state, handPos);
        -: 1086:
        -: 1087:		
        -: 1088:    case embargo: 
        -: 1089:      //+2 Coins
    #####: 1090:      state->coins = state->coins + 2;
        -: 1091:			
        -: 1092:      //see if selected pile is in play
    #####: 1093:      if ( state->supplyCount[choice1] == -1 )
        -: 1094:	{
    #####: 1095:	  return -1;
        -: 1096:	}
        -: 1097:			
        -: 1098:      //add embargo token to selected supply pile
    #####: 1099:      state->embargoTokens[choice1]++;
        -: 1100:			
        -: 1101:      //trash card
    #####: 1102:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1103:      return 0;
        -: 1104:		
        -: 1105:    case outpost:
        -: 1106:      //set outpost flag
    #####: 1107:      state->outpostPlayed++;
        -: 1108:			
        -: 1109:      //discard card
    #####: 1110:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1111:      return 0;
        -: 1112:		
        -: 1113:    case salvager:
        -: 1114:      //+1 buy
    #####: 1115:      state->numBuys++;
        -: 1116:			
    #####: 1117:      if (choice1)
        -: 1118:	{
        -: 1119:	  //gain coins equal to trashed card
    #####: 1120:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1121:	  //trash card
    #####: 1122:	  discardCard(choice1, currentPlayer, state, 1);	
        -: 1123:	}
        -: 1124:			
        -: 1125:      //discard card
    #####: 1126:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1127:      return 0;
        -: 1128:		
        -: 1129:    case sea_hag:
    #####: 1130:      for (i = 0; i < state->numPlayers; i++){
    #####: 1131:	if (i != currentPlayer){
    #####: 1132:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1133:	  state->discardCount[i]++;
    #####: 1134:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1135:	}
        -: 1136:      }
    #####: 1137:      return 0;
        -: 1138:		
        -: 1139:    case treasure_map:
        -: 1140:      //search hand for another treasure_map
    #####: 1141:      index = -1;
    #####: 1142:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1143:	{
    #####: 1144:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1145:	    {
    #####: 1146:	      index = i;
    #####: 1147:	      break;
        -: 1148:	    }
        -: 1149:	}
    #####: 1150:      if (index > -1)
        -: 1151:	{
        -: 1152:	  //trash both treasure cards
    #####: 1153:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1154:	  discardCard(index, currentPlayer, state, 1);
        -: 1155:
        -: 1156:	  //gain 4 Gold cards
    #####: 1157:	  for (i = 0; i < 4; i++)
        -: 1158:	    {
    #####: 1159:	      gainCard(gold, state, 1, currentPlayer);
        -: 1160:	    }
        -: 1161:				
        -: 1162:	  //return success
    #####: 1163:	  return 1;
        -: 1164:	}
        -: 1165:			
        -: 1166:      //no second treasure_map found in hand
    #####: 1167:      return -1;
        -: 1168:    }
        -: 1169:	
    #####: 1170:  return -1;
        -: 1171:}
        -: 1172:
     7936: 1173:int playAdventurer(struct gameState *state){
     7936: 1174:	int drawntreasure = 0;
        -: 1175:	int cardDrawn;
     7936: 1176:	int currentPlayer = whoseTurn(state);
        -: 1177:    int temphand[MAX_HAND];// moved above the if statement
     7936: 1178:    int z = 0;// this is the counter for the temp hand
        -: 1179:
        -: 1180:	
    46624: 1181:	while(drawntreasure<3){
    30752: 1182:		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
     3968: 1183:		  shuffle(currentPlayer, state);
        -: 1184:		}
    30752: 1185:		drawCard(currentPlayer, state);
    30752: 1186:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    30752: 1187:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    23808: 1188:		  drawntreasure++;
        -: 1189:		else{
     6944: 1190:		  temphand[z]=cardDrawn;
     6944: 1191:		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
     6944: 1192:		  z++;
        -: 1193:		}
        -: 1194:	  }
    22816: 1195:	  while(z-1>=0){
     6944: 1196:		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
     6944: 1197:	   z=z-1;
        -: 1198:	  }
        -: 1199:	  
     7936: 1200:	return 0;
        -: 1201:}
        -: 1202:
        -: 1203://Add 4 cards
        4: 1204:int playCouncil_Room(struct gameState *state, int handPos){
        4: 1205:	int currentPlayer = whoseTurn(state);
        -: 1206:	int i;
        -: 1207:  
       24: 1208:    for (i = 0; i < 5; i++)
        -: 1209:	{
       20: 1210:	  drawCard(currentPlayer, state);
        -: 1211:	}
        -: 1212:			
        -: 1213:    //+1 Buy
        4: 1214:    state->numBuys++;
        -: 1215:			
        -: 1216:    //Each other player draws a card
       20: 1217:    for (i = 0; i < state->numPlayers; i++)
        -: 1218:	{
       16: 1219:	  if ( i != currentPlayer )
        -: 1220:	  {
       12: 1221:	    drawCard(i, state);
        -: 1222:	  }
        -: 1223:	}
        -: 1224:			
        -: 1225:    //put played card in played card pile
        4: 1226:    discardCard(handPos, currentPlayer, state, 0);
        4: 1227:	return 0;
        -: 1228:}
        -: 1229:
   986048: 1230:int playSmithy(struct gameState *state, int handPos){
        -: 1231:    int i;
   986048: 1232:    int currentPlayer = whoseTurn(state);
        -: 1233:
        -: 1234:    //+3 Cards
  3944192: 1235:    for (i = 0; i < 3; i++)
        -: 1236:    {
  2958144: 1237:      drawCard(currentPlayer, state);
        -: 1238:    }
        -: 1239:    	
        -: 1240:    //discard card from hand
   986048: 1241:    discardCard(handPos, currentPlayer, state, 0-1);
   986048: 1242:    return 0;
        -: 1243:}
        -: 1244:
    #####: 1245:int playCutpurse(struct gameState *state, int handPos){
        -: 1246:	int i, j, k;
    #####: 1247:	int currentPlayer = whoseTurn(state);
        -: 1248:
        -: 1249:	
    #####: 1250:    updateCoins(currentPlayer, state, 2);
    #####: 1251:    for (i = 0; i < state->numPlayers; i++)
        -: 1252:	{
    #####: 1253:	  if (i != currentPlayer)
        -: 1254:	  {
    #####: 1255:	    for (j = 0; j <= state->handCount[i]; j++){
    #####: 1256:          if (state->hand[i][j] == copper){
    #####: 1257:	        discardCard(j, i, state, 0);
    #####: 1258:		    return -1;
        -: 1259:	      }
    #####: 1260:	      if (j = state->handCount[i]){
    #####: 1261:            for (k = 0; k < state->handCount[i]; k++){
        -: 1262:		      if (DEBUG)
        -: 1263:                printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1264:            }	
    #####: 1265:		  return -1;
        -: 1266:          }		
        -: 1267:		}
        -: 1268:					
        -: 1269:	  }//end != currentPlayer switch		
        -: 1270:	}
        -: 1271:
        -: 1272:    //discard played card from hand
    #####: 1273:	discardCard(handPos, currentPlayer, state, 0);
        -: 1274:	
    #####: 1275:	return 0;
        -: 1276:}
        -: 1277:
    #####: 1278:int playSteward(struct gameState *state, int handPos, int choice1, int choice2, int choice3){
    #####: 1279:  int currentPlayer = whoseTurn(state);
        -: 1280:
    #####: 1281:  if (choice1 == 1) {
        -: 1282:  //+2 cards
    #####: 1283:    drawCard(currentPlayer, state);
    #####: 1284:    drawCard(currentPlayer, state);
        -: 1285:  }
    #####: 1286:  else if (choice1 == 2) {
        -: 1287:  //+2 coins
    #####: 1288:    state->coins = state->coins + 2;
        -: 1289:  }
        -: 1290:  else {
        -: 1291:  //trash 2 cards in hand
    #####: 1292:    discardCard(choice2, currentPlayer, state, 1);
    #####: 1293:    discardCard(choice3, currentPlayer, state, 1);
        -: 1294:  }
        -: 1295:	
        -: 1296:  //discard card from hand
    #####: 1297:  discardCard(handPos, currentPlayer, state, 0);
    #####: 1298:  return 0;
        -: 1299:}
        -: 1300:
     3968: 1301:int playVillage(struct gameState *state, int handPos){
     3968: 1302:    int currentPlayer = whoseTurn(state);
        -: 1303:
        -: 1304:    //+1 Card
     3968: 1305:     drawCard(currentPlayer, state);
        -: 1306:
        -: 1307:     //+2 Actions
     3968: 1308:     state->numActions = state->numActions + 2;
        -: 1309:
        -: 1310:     //discard played card from hand
     3968: 1311:     discardCard(handPos, currentPlayer, state, 0);
     3968: 1312:     return 0;
        -: 1313:}
        -: 1314:
   990020: 1315:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1316:{
        -: 1317:	
        -: 1318:  //if card is not trashed, added to Played pile 
   990020: 1319:  if (trashFlag < 1)
        -: 1320:    {
        -: 1321:      //add card to played pile
   990020: 1322:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
   990020: 1323:      state->playedCardCount++;
        -: 1324:    }
        -: 1325:	
        -: 1326:  //set played card to -1
   990020: 1327:  state->hand[currentPlayer][handPos] = -1;
        -: 1328:	
        -: 1329:  //remove card from player's hand
   990020: 1330:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1331:    {
        -: 1332:      //reduce number of cards in hand
     3968: 1333:      state->handCount[currentPlayer]--;
        -: 1334:    }
   986052: 1335:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1336:    {
        -: 1337:      //reduce number of cards in hand
    #####: 1338:      state->handCount[currentPlayer]--;
        -: 1339:    }
        -: 1340:  else 	
        -: 1341:    {
        -: 1342:      //replace discarded card with last card in hand
   986052: 1343:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1344:      //set last card to -1
   986052: 1345:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1346:      //reduce number of cards in hand
   986052: 1347:      state->handCount[currentPlayer]--;
        -: 1348:    }
        -: 1349:	
   990020: 1350:  return 0;
        -: 1351:}
        -: 1352:
    #####: 1353:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1354:{
        -: 1355:  //Note: supplyPos is enum of choosen card
        -: 1356:	
        -: 1357:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1358:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1359:    {
    #####: 1360:      return -1;
        -: 1361:    }
        -: 1362:	
        -: 1363:  //added card for [whoseTurn] current player:
        -: 1364:  // toFlag = 0 : add to discard
        -: 1365:  // toFlag = 1 : add to deck
        -: 1366:  // toFlag = 2 : add to hand
        -: 1367:
    #####: 1368:  if (toFlag == 1)
        -: 1369:    {
    #####: 1370:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1371:      state->deckCount[player]++;
        -: 1372:    }
    #####: 1373:  else if (toFlag == 2)
        -: 1374:    {
    #####: 1375:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1376:      state->handCount[player]++;
        -: 1377:    }
        -: 1378:  else
        -: 1379:    {
    #####: 1380:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1381:      state->discardCount[player]++;
        -: 1382:    }
        -: 1383:	
        -: 1384:  //decrease number in supply pile
    #####: 1385:  state->supplyCount[supplyPos]--;
        -: 1386:	 
    #####: 1387:  return 0;
        -: 1388:}
        -: 1389:
      819: 1390:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1391:{
        -: 1392:  int i;
        -: 1393:	
        -: 1394:  //reset coin count
      819: 1395:  state->coins = 0;
        -: 1396:
        -: 1397:  //add coins for each Treasure card in player's hand
     3904: 1398:  for (i = 0; i < state->handCount[player]; i++)
        -: 1399:    {
     3085: 1400:      if (state->hand[player][i] == copper)
        -: 1401:	{
     1068: 1402:	  state->coins += 1;
        -: 1403:	}
     2017: 1404:      else if (state->hand[player][i] == silver)
        -: 1405:	{
     1000: 1406:	  state->coins += 2;
        -: 1407:	}
     1017: 1408:      else if (state->hand[player][i] == gold)
        -: 1409:	{
     1000: 1410:	  state->coins += 3;
        -: 1411:	}	
        -: 1412:    }	
        -: 1413:
        -: 1414:  //add bonus
      819: 1415:  state->coins += bonus;
        -: 1416:
      819: 1417:  return 0;
        -: 1418:}
        -: 1419:
        -: 1420:
        -: 1421://end of dominion.c
        -: 1422:
